<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/23/%E7%A2%B3%E6%8E%92%E6%94%BE%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/23/%E7%A2%B3%E6%8E%92%E6%94%BE%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">碳排放分析模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-23 11:27:17 / Modified: 17:07:28" itemprop="dateCreated datePublished" datetime="2022-04-23T11:27:17+08:00">2022-04-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>用两个模型来预测，再用三组数据比较分析。</p>
<p>同时为了避免大环境的干扰，应对未试点的省份也进行预测。同时证明模型的合理性。</p>
<h2 id="机制设计及实验研究"><a href="#机制设计及实验研究" class="headerlink" title="机制设计及实验研究"></a>机制设计及实验研究</h2><p>整体思路：</p>
<p>上海实施试点是2014年，所以我们采取14-19年作为政策采取后的数据，采用08-13作为政策采取前的数据。</p>
<p>通过08-13年的数据，采用合成控制法与..模型两种方式，预测分析政策未被实施的情况下上海地区的碳排放量，</p>
<p>模型中需要注意：</p>
<p>由于碳排放量所受的影响因素是多方面的，基于控制变量的原则，我们采用合成控制法预测上海地区的碳排放量时，所选择的其他地区应是未被试点的地区，同时我们假设，国家各地区整体的经济发展趋势大致拟合经济发展曲线，可消除一部分经济等其他因素对于实验数据的干扰。对于..模型，我们同样假设经济发展拟合经济发展曲线。通过这两种方式，我们可扩大我们所研究的试点政策对于碳排放量的影响。</p>
<p>为了验证我们预测模型的正确性，我们进行了稳健性检验，平行趋势检验，异质性分析。</p>
<p>稳健性检验：对于未试点的地区，同样用该模型进行预测，对预测数据与实际数据比较，发现拟合度较高，验证模型基本正确。</p>
<p>平行趋势检验：对于上海地区与选择的其他地区，在试点政策颁布前，有关碳排放政策大致相同。同时碳排放曲线大致相同。</p>
<p>异质性检验：</p>
<p>最后，对于模拟产生的两组数据，与实际数据，我们通过..分析法，对于三组数据进行分析，得出…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/22/CMIS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/22/CMIS/" class="post-title-link" itemprop="url">CMIS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-22 10:59:18" itemprop="dateCreated datePublished" datetime="2022-04-22T10:59:18+08:00">2022-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-25 20:41:47" itemprop="dateModified" datetime="2022-04-25T20:41:47+08:00">2022-04-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="教室管理信息系统"><a href="#教室管理信息系统" class="headerlink" title="教室管理信息系统"></a>教室管理信息系统</h1><p>在之前的基础上进行改进，优化了数据结构和存储设计，改进了索引结构，满足第四范式。</p>
<h2 id="数据库部分"><a href="#数据库部分" class="headerlink" title="数据库部分"></a>数据库部分</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">create database CMIS</span><br><span class="line">on primary</span><br><span class="line">(</span><br><span class="line">name=&#x27;f1&#x27;,</span><br><span class="line">filename=&#x27;F:\sqlserver\sqlwj\cmis\f1.mdf&#x27;,</span><br><span class="line">size=3mb,</span><br><span class="line">maxsize=unlimited,</span><br><span class="line">filegrowth=3%</span><br><span class="line">),</span><br><span class="line">(</span><br><span class="line">name=&#x27;f2&#x27;,																																																																																																					</span><br><span class="line">filename=&#x27;F:\sqlserver\sqlwj\cmis\f2.ndf&#x27;,</span><br><span class="line">size=10mb,</span><br><span class="line">maxsize=500mb,</span><br><span class="line">filegrowth=6mb</span><br><span class="line">)</span><br><span class="line">log on</span><br><span class="line">(</span><br><span class="line">name=&#x27;f3&#x27;,</span><br><span class="line">filename=&#x27;F:\sqlserver\sqlwj\cmis\f3.ldf&#x27;,</span><br><span class="line">size=1mb,</span><br><span class="line">maxsize=unlimited,</span><br><span class="line">filegrowth=2%</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建学生信息表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table 学生信息</span><br><span class="line">(</span><br><span class="line">学号 char(10) not null,</span><br><span class="line">姓名 varchar(15) not null,</span><br><span class="line">性别 varchar(5) not null,</span><br><span class="line">院系号 varchar(5) not null,</span><br><span class="line">密码 varchar(15) not null</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建教师信息表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--创建教师信息表</span><br><span class="line">create table 教师信息</span><br><span class="line">(</span><br><span class="line">教师编号 char(10) not null,</span><br><span class="line">教师姓名 varchar(15) not null,</span><br><span class="line">性别 varchar(5) not null,</span><br><span class="line">院系号 varchar(5) not null,</span><br><span class="line">职称 varchar(15) not null,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建院系信息表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--创建院系信息表</span><br><span class="line">create table 院系信息</span><br><span class="line">(</span><br><span class="line">院系号 varchar(5) not null,</span><br><span class="line">院系名称 varchar(15) not null</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建教室信息表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--创建教室信息表</span><br><span class="line">create table 教室信息</span><br><span class="line">(</span><br><span class="line">教室编号 varchar(5) not null,</span><br><span class="line">教学楼编号 varchar(5) not null,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建教学楼信息表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--创建教学楼信息表</span><br><span class="line">create table 教学楼信息</span><br><span class="line">(</span><br><span class="line">教学楼名称 varchar(10) not null,</span><br><span class="line">教学楼编号 varchar(5) not null</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建课程信息表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--创建课程信息表</span><br><span class="line">create table 课程信息</span><br><span class="line">(</span><br><span class="line">课程名称 varchar(30) not null,</span><br><span class="line">课程编号 varchar(7) not null,</span><br><span class="line">教师编号 char(10) not null,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建教室使用信息表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--创建教室使用信息表</span><br><span class="line">create table 教室使用信息</span><br><span class="line">(</span><br><span class="line">教室编号 varchar(5) not null,</span><br><span class="line">时间 varchar(10) not null,</span><br><span class="line">状态 varchar(10) not null,</span><br><span class="line">课程编号 varchar(7) not null </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建课程时间表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--创建课程时间表</span><br><span class="line">create table 课程时间</span><br><span class="line">(</span><br><span class="line">课程编号 varchar(7) not null,</span><br><span class="line">上课时间 varchar(10) not null,</span><br><span class="line">上课教室 varchar(5) not null</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>设置主键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--将教师信息表中教师编号设置为主键约束，身份证号设为唯一约束</span><br><span class="line">alter table 教师信息 </span><br><span class="line">add constraint PK_教师编号 primary key (教师编号)</span><br><span class="line">--将学生信息表中学号设置为主键约束，身份证号设为唯一约束</span><br><span class="line">alter table 学生信息 </span><br><span class="line">add constraint PK_学号 primary key (学号)</span><br><span class="line">--将教室信息中教室编号设置为主键</span><br><span class="line">alter table 教室信息</span><br><span class="line">add constraint PK_教室编号 primary key(教室编号)</span><br><span class="line">--将教学楼信息中教学楼编号设置为主键</span><br><span class="line">alter table 教学楼信息</span><br><span class="line">add constraint PK_教学楼编号 primary key(教学楼编号)</span><br><span class="line">--将院系信息中院系号号设置为主键</span><br><span class="line">alter table 院系信息</span><br><span class="line">add constraint PK_院系号 primary key(院系号)</span><br><span class="line">--将课程信息中课程编号设置为主键</span><br><span class="line">alter table 课程信息</span><br><span class="line">add constraint PK_课程编号 primary key(课程编号)</span><br></pre></td></tr></table></figure>
<p>设置外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--将教师信息中的院系号与院系信息中的院系号添加外键</span><br><span class="line">alter table 教师信息</span><br><span class="line">add constraint FK_教师院系号 foreign key(院系号)references 院系信息(院系号)</span><br><span class="line"></span><br><span class="line">--将教学楼信息中的教学楼编号与教室信息中的教学楼编号添加外键</span><br><span class="line">alter table 教室信息</span><br><span class="line">add constraint FK_教学楼编号 foreign key(教学楼编号)references 教学楼信息(教学楼编号)</span><br><span class="line"></span><br><span class="line">--将学生信息中的院系号与院系信息中的院系号添加外键</span><br><span class="line">alter table 学生信息</span><br><span class="line">add constraint FK_学生院系号 foreign key(院系号)references 院系信息(院系号)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--将教室使用信息表中教室编号与教室信息表中的教室编号添加外键</span><br><span class="line">alter table 教室使用信息</span><br><span class="line">add constraint FK_教室编号教室使用信息 foreign key (教室编号)references 教室信息(教室编号)</span><br><span class="line"></span><br><span class="line">--将教室使用信息表中课程编号与课程信息表中的课程编号添加外键</span><br><span class="line">alter table 教室使用信息</span><br><span class="line">add constraint FK_课程编号教室使用信息 foreign key (课程编号)references 课程信息(课程编号)</span><br><span class="line"></span><br><span class="line">--对课程信息表中教师编号添加外键约束</span><br><span class="line">alter table 课程信息</span><br><span class="line">add constraint FK_教师编号课程信息 foreign key(教师编号)references 教师信息(教师编号)</span><br><span class="line"></span><br><span class="line">--对课程时间表中上课教室添加外键约束</span><br><span class="line">alter table 课程时间</span><br><span class="line">add constraint FK_上课教室课程时间 foreign key(上课教室)references 教室信息(教室编号)</span><br><span class="line"></span><br><span class="line">--对课程时间表中课程编号添加外键约束</span><br><span class="line">alter table 课程时间</span><br><span class="line">add constraint FK_课程编号课程时间 foreign key(课程编号)references 课程信息(课程编号)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置检查约束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">--对教师信息中的性别添加约束</span><br><span class="line">　　alter table 教师信息</span><br><span class="line">　　add constraint CK_性别教师 check (性别=&#x27;男&#x27; or 性别=&#x27;女&#x27;)</span><br><span class="line"></span><br><span class="line">--对学生信息中的性别添加约束</span><br><span class="line">　　alter table 学生信息</span><br><span class="line">　　add constraint CK_性别学生 check (性别=&#x27;男&#x27; or 性别=&#x27;女&#x27;)</span><br><span class="line"></span><br><span class="line">--对教室使用信息的时间进行约束</span><br><span class="line">  alter table 教室使用信息</span><br><span class="line">  add constraint CK_时间 check (时间=&#x27;周一一二&#x27; or 时间=&#x27;周一三四&#x27; or 时间=&#x27;周一五六&#x27; or 时间=&#x27;周一七八&#x27; or </span><br><span class="line">  时间=&#x27;周二一二&#x27; or 时间=&#x27;周二三四&#x27; or 时间=&#x27;周二五六&#x27; or 时间=&#x27;周二七八&#x27; or </span><br><span class="line">  时间=&#x27;周三一二&#x27; or 时间=&#x27;周三三四&#x27; or 时间=&#x27;周三五六&#x27; or 时间=&#x27;周三七八&#x27; or </span><br><span class="line">  时间=&#x27;周四一二&#x27; or 时间=&#x27;周四三四&#x27; or 时间=&#x27;周四五六&#x27; or 时间=&#x27;周四七八&#x27; or </span><br><span class="line">  时间=&#x27;周五一二&#x27; or 时间=&#x27;周五三四&#x27; or 时间=&#x27;周五五六&#x27; or 时间=&#x27;周五七八&#x27; or </span><br><span class="line">  时间=&#x27;周六一二&#x27; or 时间=&#x27;周六三四&#x27; or 时间=&#x27;周六五六&#x27; or 时间=&#x27;周六七八&#x27; or </span><br><span class="line">  时间=&#x27;周日一二&#x27; or 时间=&#x27;周日三四&#x27; or 时间=&#x27;周日五六&#x27; or 时间=&#x27;周日七八&#x27; </span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">--对课程时间中上课时间约束</span><br><span class="line">alter table 课程时间</span><br><span class="line">  add constraint CK_课程时间 check (上课时间=&#x27;周一一二&#x27; or 上课时间=&#x27;周一三四&#x27; or 上课时间=&#x27;周一五六&#x27; or 上课时间=&#x27;周一七八&#x27; or </span><br><span class="line">  上课时间=&#x27;周二一二&#x27; or 上课时间=&#x27;周二三四&#x27; or 上课时间=&#x27;周二五六&#x27; or 上课时间=&#x27;周二七八&#x27; or </span><br><span class="line">  上课时间=&#x27;周三一二&#x27; or 上课时间=&#x27;周三三四&#x27; or 上课时间=&#x27;周三五六&#x27; or 上课时间=&#x27;周三七八&#x27; or </span><br><span class="line">  上课时间=&#x27;周四一二&#x27; or 上课时间=&#x27;周四三四&#x27; or 上课时间=&#x27;周四五六&#x27; or 上课时间=&#x27;周四七八&#x27; or </span><br><span class="line">  上课时间=&#x27;周五一二&#x27; or 上课时间=&#x27;周五三四&#x27; or 上课时间=&#x27;周五五六&#x27; or 上课时间=&#x27;周五七八&#x27; or </span><br><span class="line">  上课时间=&#x27;周六一二&#x27; or 上课时间=&#x27;周六三四&#x27; or 上课时间=&#x27;周六五六&#x27; or 上课时间=&#x27;周六七八&#x27; or </span><br><span class="line">  上课时间=&#x27;周日一二&#x27; or 上课时间=&#x27;周日三四&#x27; or 上课时间=&#x27;周日五六&#x27; or 上课时间=&#x27;周日七八&#x27; </span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<h3 id="插入信息"><a href="#插入信息" class="headerlink" title="插入信息"></a>插入信息</h3><p>插入教学楼基本信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert into 教学楼信息</span><br><span class="line">values(&#x27;正心&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教学楼信息</span><br><span class="line">values(&#x27;诚意&#x27;,&#x27;CY&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教学楼信息</span><br><span class="line">values(&#x27;格物&#x27;,&#x27;GW&#x27;)</span><br></pre></td></tr></table></figure>
<p>插入教室基本信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX101&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX102&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX103&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX104&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX201&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX202&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX203&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX204&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX301&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX302&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX303&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX304&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX401&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX402&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX403&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX404&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX501&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX502&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX503&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX504&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX601&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX602&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX603&#x27;,&#x27;ZX&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;ZX604&#x27;,&#x27;ZX&#x27;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;CY101&#x27;,&#x27;CY&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;CY102&#x27;,&#x27;CY&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;CY103&#x27;,&#x27;CY&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;CY104&#x27;,&#x27;CY&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;CY201&#x27;,&#x27;CY&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;CY202&#x27;,&#x27;CY&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;CY203&#x27;,&#x27;CY&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;CY204&#x27;,&#x27;CY&#x27;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;GW101&#x27;,&#x27;GW&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;GW102&#x27;,&#x27;GW&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;GW103&#x27;,&#x27;GW&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;GW104&#x27;,&#x27;GW&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;GW201&#x27;,&#x27;GW&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;GW202&#x27;,&#x27;GW&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;GW203&#x27;,&#x27;GW&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;GW204&#x27;,&#x27;GW&#x27;)</span><br></pre></td></tr></table></figure>
<p>插入院系信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">insert into 院系信息</span><br><span class="line">values(&#x27;001&#x27;,&#x27;计算机&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 院系信息</span><br><span class="line">values(&#x27;002&#x27;,&#x27;航天&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 院系信息</span><br><span class="line">values(&#x27;003&#x27;,&#x27;机电工程&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 院系信息</span><br><span class="line">values(&#x27;004&#x27;,&#x27;材料科学&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 院系信息</span><br><span class="line">values(&#x27;005&#x27;,&#x27;数学&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 院系信息</span><br><span class="line">values(&#x27;006&#x27;,&#x27;经济与管理&#x27;)</span><br></pre></td></tr></table></figure>
<p>插入教师信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">insert into 教师信息</span><br><span class="line">values(&#x27;0000000001&#x27;,&#x27;姜老师&#x27;,&#x27;男&#x27;,&#x27;006&#x27;,&#x27;教授&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教师信息</span><br><span class="line">values(&#x27;0000000002&#x27;,&#x27;邹老师&#x27;,&#x27;男&#x27;,&#x27;001&#x27;,&#x27;教授&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教师信息</span><br><span class="line">values(&#x27;0000000003&#x27;,&#x27;陈老师&#x27;,&#x27;女&#x27;,&#x27;001&#x27;,&#x27;教授&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教师信息</span><br><span class="line">values(&#x27;0000000004&#x27;,&#x27;金老师&#x27;,&#x27;男&#x27;,&#x27;006&#x27;,&#x27;教授&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教师信息</span><br><span class="line">values(&#x27;0000000005&#x27;,&#x27;左老师&#x27;,&#x27;男&#x27;,&#x27;001&#x27;,&#x27;教授&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教师信息</span><br><span class="line">values(&#x27;0000000006&#x27;,&#x27;刘老师&#x27;,&#x27;男&#x27;,&#x27;001&#x27;,&#x27;教授&#x27;)</span><br></pre></td></tr></table></figure>
<p>插入课程信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">insert into 课程信息</span><br><span class="line">values(&#x27;国际结算&#x27;,&#x27;EM32907&#x27;,&#x27;0000000001&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 课程信息</span><br><span class="line">values(&#x27;数据库系统&#x27;,&#x27;CS33503&#x27;,&#x27;0000000002&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 课程信息</span><br><span class="line">values(&#x27;编译系统&#x27;,&#x27;CS33502&#x27;,&#x27;0000000003&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 课程信息</span><br><span class="line">values(&#x27;国际企业管理&#x27;,&#x27;EM32408&#x27;,&#x27;0000000004&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 课程信息</span><br><span class="line">values(&#x27;模式识别与深度学习&#x27;,&#x27;CS33262&#x27;,&#x27;0000000005&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 课程信息</span><br><span class="line">values(&#x27;操作系统设计与实现&#x27;,&#x27;CS32202&#x27;,&#x27;0000000006&#x27;)</span><br></pre></td></tr></table></figure>
<p>插入课程时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">insert into 教室使用信息</span><br><span class="line"> values(&#x27;ZX301&#x27;,&#x27;周一三四&#x27;,&#x27;有课&#x27;,&#x27;CS32202&#x27;)</span><br><span class="line"> insert into 教室使用信息</span><br><span class="line"> values(&#x27;ZX301&#x27;,&#x27;周三三四&#x27;,&#x27;有课&#x27;,&#x27;CS32202&#x27;)</span><br><span class="line">  insert into 课程时间</span><br><span class="line"> values(&#x27;CS32202&#x27;,&#x27;周一三四&#x27;,&#x27;ZX301&#x27;)</span><br><span class="line">  insert into 课程时间</span><br><span class="line"> values(&#x27;CS32202&#x27;,&#x27;周三三四&#x27;,&#x27;ZX301&#x27;)</span><br><span class="line"> </span><br><span class="line"> insert into 教室使用信息</span><br><span class="line"> values(&#x27;ZX201&#x27;,&#x27;周一七八&#x27;,&#x27;有课&#x27;,&#x27;CS33262&#x27;)</span><br><span class="line"> insert into 教室使用信息</span><br><span class="line"> values(&#x27;ZX201&#x27;,&#x27;周三五六&#x27;,&#x27;有课&#x27;,&#x27;CS33262&#x27;)</span><br><span class="line"> insert into 课程时间</span><br><span class="line"> values(&#x27;CS33262&#x27;,&#x27;周一七八&#x27;,&#x27;ZX201&#x27;)</span><br><span class="line">  insert into 课程时间</span><br><span class="line"> values(&#x27;CS33262&#x27;,&#x27;周三五六&#x27;,&#x27;ZX201&#x27;)</span><br><span class="line"> </span><br><span class="line"> insert into 教室使用信息</span><br><span class="line"> values(&#x27;ZX202&#x27;,&#x27;周二三四&#x27;,&#x27;有课&#x27;,&#x27;CS33502&#x27;)</span><br><span class="line"> insert into 教室使用信息</span><br><span class="line"> values(&#x27;ZX202&#x27;,&#x27;周四一二&#x27;,&#x27;有课&#x27;,&#x27;CS33502&#x27;)</span><br><span class="line"> insert into 课程时间</span><br><span class="line"> values(&#x27;CS33502&#x27;,&#x27;周二三四&#x27;,&#x27;ZX202&#x27;)</span><br><span class="line">  insert into 课程时间</span><br><span class="line"> values(&#x27;CS33502&#x27;,&#x27;周四一二&#x27;,&#x27;ZX202&#x27;)</span><br><span class="line"> </span><br><span class="line"> insert into 教室使用信息</span><br><span class="line"> values(&#x27;ZX102&#x27;,&#x27;周一五六&#x27;,&#x27;有课&#x27;,&#x27;CS33503&#x27;)</span><br><span class="line"> insert into 教室使用信息</span><br><span class="line"> values(&#x27;ZX102&#x27;,&#x27;周四五六&#x27;,&#x27;有课&#x27;,&#x27;CS33503&#x27;)</span><br><span class="line"> insert into 课程时间</span><br><span class="line"> values(&#x27;CS33503&#x27;,&#x27;周一五六&#x27;,&#x27;ZX102&#x27;)</span><br><span class="line">  insert into 课程时间</span><br><span class="line"> values(&#x27;CS33503&#x27;,&#x27;周四五六&#x27;,&#x27;ZX102&#x27;)</span><br><span class="line"> </span><br><span class="line"> insert into 教室使用信息</span><br><span class="line"> values(&#x27;ZX402&#x27;,&#x27;周五一二&#x27;,&#x27;有课&#x27;,&#x27;EM32408&#x27;)</span><br><span class="line"> insert into 教室使用信息</span><br><span class="line"> values(&#x27;ZX402&#x27;,&#x27;周五三四&#x27;,&#x27;有课&#x27;,&#x27;EM32408&#x27;)</span><br><span class="line"> insert into 课程时间</span><br><span class="line"> values(&#x27;EM32408&#x27;,&#x27;周五一二&#x27;,&#x27;ZX402&#x27;)</span><br><span class="line">  insert into 课程时间</span><br><span class="line"> values(&#x27;EM32408&#x27;,&#x27;周五三四&#x27;,&#x27;ZX402&#x27;)</span><br><span class="line"> </span><br><span class="line"> insert into 教室使用信息</span><br><span class="line"> values(&#x27;ZX601&#x27;,&#x27;周四三四&#x27;,&#x27;有课&#x27;,&#x27;EM32907&#x27;)</span><br><span class="line"></span><br><span class="line"> insert into 课程时间</span><br><span class="line"> values(&#x27;EM32907&#x27;,&#x27;周四三四&#x27;,&#x27;ZX601&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="编写存储"><a href="#编写存储" class="headerlink" title="编写存储"></a>编写存储</h3><p>插入课程信息存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">create procedure information_entry</span><br><span class="line"> @coursename varchar(15),--输入参数，课程名称</span><br><span class="line"> @coursenumber varchar(7),--输入参数，课程编号</span><br><span class="line"> @coursetime varchar(10),--输入参数，课程时间</span><br><span class="line"> @teachername varchar(15),--输入参数，教师名称</span><br><span class="line"> @teachernumber char(10),--输入参数，教师编号</span><br><span class="line"> @buildingnumber varchar(5),--输入参数，教学楼编号</span><br><span class="line"> @roomnumber varchar(5)--输入参数教室编号</span><br><span class="line">AS</span><br><span class="line"> insert into 课程信息</span><br><span class="line"> values(@coursename,@coursenumber,@teachernumber)</span><br><span class="line"> insert into 课程时间</span><br><span class="line"> values(@coursenumber,@coursetime,@roomnumber)</span><br><span class="line"> insert into 教室使用信息</span><br><span class="line"> values(@roomnumber,@coursetime,&#x27;有课&#x27;,@coursenumber)</span><br><span class="line">go</span><br></pre></td></tr></table></figure>
<p>查询指定教室使用情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">create procedure classroom_query</span><br><span class="line"> @room varchar(5),</span><br><span class="line"> @time varchar(10),</span><br><span class="line"> @state varchar(10)=&#x27;空闲&#x27; output</span><br><span class="line"> AS</span><br><span class="line"></span><br><span class="line"> select @state=状态</span><br><span class="line"> from 教室使用信息</span><br><span class="line"> where 教室编号=@room and 时间=@time</span><br><span class="line"> if @state IS NULL</span><br><span class="line">   set  @state=&#x27;空闲&#x27;</span><br><span class="line">   else if @state=&#x27;有课&#x27;</span><br><span class="line">   begin</span><br><span class="line">    select @state=课程编号</span><br><span class="line"> from 教室使用信息</span><br><span class="line"> where 教室编号=@room and 时间=@time</span><br><span class="line"></span><br><span class="line">   end</span><br><span class="line"> go</span><br></pre></td></tr></table></figure>
<p>少一个查询指定课程</p>
<p>借用存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">declare @state varchar(10)</span><br><span class="line">go</span><br><span class="line">create procedure borrow</span><br><span class="line"> @building varchar(5),</span><br><span class="line"> @room varchar(5),</span><br><span class="line"> @time varchar(10),</span><br><span class="line"> @reason varchar(10),</span><br><span class="line"> @state varchar(10) output</span><br><span class="line">AS</span><br><span class="line">declare @state1 varchar(10)</span><br><span class="line"> select @state1=状态</span><br><span class="line"> from 教室使用信息</span><br><span class="line"> where 教室编号=@room and 时间=@time</span><br><span class="line"> if @state1 IS NULL</span><br><span class="line"> begin</span><br><span class="line">   set  @state1=&#x27;空闲&#x27;</span><br><span class="line">   </span><br><span class="line">   print &#x27;此时教室空闲，可以借用&#x27;</span><br><span class="line">   insert into 教室使用信息</span><br><span class="line">   values(@room,@time,@reason,&#x27;其他&#x27;)</span><br><span class="line">  end</span><br><span class="line">else</span><br><span class="line">  print &#x27;此教室被占用，正在&#x27;+@state1</span><br><span class="line">  set @state=@state1</span><br><span class="line">  print @state</span><br><span class="line">  go</span><br></pre></td></tr></table></figure>
<p>一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *from 教室使用信息</span><br><span class="line">declare @state varchar(10)</span><br><span class="line">exec borrow &#x27;001&#x27;,&#x27;1102&#x27;,&#x27;周一三四&#x27;,&#x27;其他&#x27;,@state output</span><br><span class="line">print @state</span><br></pre></td></tr></table></figure>
<p>判断密码是否正确</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create procedure password_query</span><br><span class="line"> @user char(10),</span><br><span class="line"> @password varchar(15),</span><br><span class="line"> @state varchar(10)=&#x27;false&#x27; output</span><br><span class="line">AS</span><br><span class="line">declare @password1 varchar(15)</span><br><span class="line"> select @password1=密码  from 学生信息</span><br><span class="line"> where 学号=@user</span><br><span class="line"> if @password1 IS NOT NULL and @password1=@password</span><br><span class="line"> set @state=&#x27;true&#x27;</span><br><span class="line"> else</span><br><span class="line"> set @state=&#x27;false&#x27;</span><br><span class="line">go</span><br></pre></td></tr></table></figure>
<p>删除课程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create procedure delete_course</span><br><span class="line"> @number varchar(7)</span><br><span class="line"> AS</span><br><span class="line">delete from 课程信息 where 课程编号=@number</span><br><span class="line">delete from 教室使用信息 where 课程编号=@number</span><br><span class="line">delete from 课程时间 where 课程编号=@number</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>删除教师</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create procedure delete_teacher</span><br><span class="line"> @number char(10)</span><br><span class="line"> AS</span><br><span class="line"> delete from 课程时间 where 课程编号 in(</span><br><span class="line">select 课程编号 from 课程信息 where 教师编号=@number)</span><br><span class="line">delete from 教室使用信息 where 课程编号 in(</span><br><span class="line">select 课程编号 from 课程信息 where 教师编号=@number)</span><br><span class="line">delete from 课程信息 where 教师编号=@number</span><br><span class="line">delete from 教师信息 where 教师编号=@number</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建存储往学生信息插入大量数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">--创建循环插入10000条记录的存储过程</span><br><span class="line">CREATE  PROCEDURE CREATE_student </span><br><span class="line">AS</span><br><span class="line">declare @cnt INT=0;</span><br><span class="line">while @cnt&lt;10000</span><br><span class="line">begin</span><br><span class="line">declare @name varchar(15)</span><br><span class="line">set @name=(SELECT   LEFT(LOWER(NEWID()),8))</span><br><span class="line">declare @password varchar(15)</span><br><span class="line">set @password=(SELECT   LEFT(LOWER(NEWID()),9))</span><br><span class="line">declare @sex INT</span><br><span class="line">set @sex=(SELECT 1 + RAND() * 2)</span><br><span class="line">declare @sno char(10)</span><br><span class="line">set @sno=replace(str(@cnt,10),&#x27; &#x27;,&#x27;0&#x27;)</span><br><span class="line">declare @y INT</span><br><span class="line">set @y=(SELECT 1 + RAND() * 6)</span><br><span class="line">    INSERT INTO 学生信息</span><br><span class="line">    VALUES</span><br><span class="line">    (</span><br><span class="line">     @sno,</span><br><span class="line">    @name</span><br><span class="line">    ,CASE @sex  --随机选取3个枚举值</span><br><span class="line">          when 1 then &#x27;男&#x27;</span><br><span class="line">          when 2 then &#x27;女&#x27;                  </span><br><span class="line">     END</span><br><span class="line">	 ,CASE @y  --随机选取6个枚举值</span><br><span class="line">          when 1 then &#x27;001&#x27;</span><br><span class="line">          when 2 then &#x27;002&#x27; </span><br><span class="line">		  when 3 then &#x27;003&#x27;</span><br><span class="line">          when 4 then &#x27;004&#x27;</span><br><span class="line">		  when 5 then &#x27;005&#x27;</span><br><span class="line">          when 6 then &#x27;006&#x27;</span><br><span class="line">     END</span><br><span class="line">	  ,@password</span><br><span class="line">	  </span><br><span class="line">   </span><br><span class="line">    );</span><br><span class="line">	set @cnt=@cnt+1;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>创建视图，查询计算机学院邹老师所有课程名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--创建视图，查询计算机学院邹老师所有课程名称</span><br><span class="line">go</span><br><span class="line">create VIEW view_邹</span><br><span class="line">as </span><br><span class="line">select 课程名称 </span><br><span class="line">from 课程信息</span><br><span class="line">where 教师编号=&#x27;0000000002&#x27;</span><br><span class="line">go</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/19/DBMS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/19/DBMS/" class="post-title-link" itemprop="url">DBMS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-19 15:19:14" itemprop="dateCreated datePublished" datetime="2022-04-19T15:19:14+08:00">2022-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-20 22:52:22" itemprop="dateModified" datetime="2022-05-20T22:52:22+08:00">2022-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h1><h2 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一.绪论"></a>一.绪论</h2><h3 id="基于文件系统的数据管理方法"><a href="#基于文件系统的数据管理方法" class="headerlink" title="基于文件系统的数据管理方法"></a>基于文件系统的数据管理方法</h3><p><strong>特点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据存储于文件中</span><br><span class="line">数据由应用程序经过文件系统进行管理</span><br></pre></td></tr></table></figure>
<p><strong>缺点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">每当文件格式发生变化，就要修改应用程序</span><br><span class="line">文件中存在冗余数据</span><br><span class="line">文件修改可能造成数据不一致</span><br><span class="line">文件修改可能破坏数据正确性</span><br><span class="line">没有索引，只能扫描文件，数据访问效率低</span><br><span class="line">只能对整个文件进行访问控制，数据安全性差</span><br><span class="line">没有并发控制，多个应用程序同时读写文件可能产生冲突</span><br></pre></td></tr></table></figure>
<h3 id="基于数据库管理系统的数据管理方法"><a href="#基于数据库管理系统的数据管理方法" class="headerlink" title="基于数据库管理系统的数据管理方法"></a>基于数据库管理系统的数据管理方法</h3><p>特点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据存储在数据库中</span><br><span class="line">数据由应用程序经过数据库管理系统进行管理</span><br></pre></td></tr></table></figure>
<h3 id="基于二者的对比"><a href="#基于二者的对比" class="headerlink" title="基于二者的对比"></a>基于二者的对比</h3><p>（1）FS:每当文件格式发生变化，就要修改应用程序</p>
<p>​          DBMS：只要数据模式不发生重大变化，应用程序基本无需修改</p>
<p>（2）FS:文件中存在冗余数</p>
<p>​          DBMS：冗余数据较少</p>
<p>（3）FS:文件修改可能造成数据不一致</p>
<p>​          DBMS：在数据库规范情况下基本不会造成</p>
<p>（4）FS:文件修改可能会破坏数据正确性</p>
<p>​          DBMS：会对数据更新进行完整行进检查</p>
<p>（5）FS:没有索引，访问效率低</p>
<p>​          DBMS：提供索引</p>
<p>（6）FS:只能对整个文件进行访问控制，数据安全性差</p>
<p>​          DBMS：可规定用户对于数据库哪一部分进行操作</p>
<p>（7）FS:文4没有并发控制</p>
<p>​          DBMS：提供并发控制机制</p>
<h3 id="数据库功能"><a href="#数据库功能" class="headerlink" title="数据库功能"></a>数据库功能</h3><p><img src="/2022/04/19/DBMS/image-20220419155148171.png" alt="image-20220419155148171"></p>
<p><strong>数据库</strong>：有组织的、共享的、持久存储的数据集合。</p>
<h3 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h3><p>由数据库、数据库管理系统、应用程序和数据库用户在一起构成的系统。</p>
<h3 id="数据库的三层模式结构"><a href="#数据库的三层模式结构" class="headerlink" title="数据库的三层模式结构"></a>数据库的三层模式结构</h3><p>数据库模式通常分三个层次定义，从低到高分别是:</p>
<p>内模式/存储模式</p>
<p>概念模式</p>
<p>外模式/视图</p>
<h4 id="内模式-存储模式"><a href="#内模式-存储模式" class="headerlink" title="内模式/存储模式"></a>内模式/存储模式</h4><p>描述数据库的物理存储结构和存取方式</p>
<p>数据库只有一个内模式</p>
<p>定义内模式时通常使用物理数据模型提供的概念</p>
<p><img src="/2022/04/19/DBMS/image-20220419161358869.png" alt="image-20220419161358869"></p>
<h4 id="概念模式"><a href="#概念模式" class="headerlink" title="概念模式"></a>概念模式</h4><p>为全体数据库用户描述整个数据库的结构和约束</p>
<p>数据库只有一个概念模式</p>
<p>定义概念模式时使用实现数据模型提供的概念</p>
<p><img src="/2022/04/19/DBMS/image-20220419161406993.png" alt="image-20220419161406993"></p>
<h4 id="外模式-视图"><a href="#外模式-视图" class="headerlink" title="外模式/视图"></a>外模式/视图</h4><p>从不同类别用户的视角描述数据库结构</p>
<p>可以有多个外模式</p>
<p>定义外模式时也可以使用实现数据模型提供的概念</p>
<h4 id="模式映射"><a href="#模式映射" class="headerlink" title="模式映射"></a>模式映射</h4><p>在三层模式结构中，不同层次模式之间的映射用于完成应用程序与数据库之间的数据转换和请求转换。</p>
<p><img src="/2022/04/19/DBMS/image-20220419161701579.png" alt="image-20220419161701579"></p>
<p><strong>分类</strong></p>
<p>外模式-概念模式映射</p>
<p>概念模式-内模式映射</p>
<h4 id="数据独立性"><a href="#数据独立性" class="headerlink" title="数据独立性"></a>数据独立性</h4><p>逻辑数据独立性</p>
<p>物理数据独立性</p>
<p><img src="/2022/04/19/DBMS/image-20220419161856014.png" alt="image-20220419161856014"></p>
<h3 id="数据库语言分类"><a href="#数据库语言分类" class="headerlink" title="数据库语言分类"></a>数据库语言分类</h3><p>数据定义语言</p>
<p>数据操作语言</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>由数据库上的一系列操作完成的复杂任务，这些操作要么全执行，要么全不执行</p>
<p><strong>性质</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原子性</span><br><span class="line">一致性</span><br><span class="line">隔离性</span><br><span class="line">持久性</span><br></pre></td></tr></table></figure>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>为了充分利用，允许多个事务并发执行。</p>
<p>多个事务并发可能会破坏数据一致性。</p>
<h2 id="二-关系数据库"><a href="#二-关系数据库" class="headerlink" title="二.关系数据库"></a>二.关系数据库</h2><h3 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h3><p>三要素：关系数据结构、关系操作、关系完整性约束。</p>
<h4 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h4><p>关系中属性的个数即为关系的<strong>度</strong>。</p>
<p>只有符合客观实际的关系才是正确的关系。</p>
<p><strong>键</strong>：关系的某些属性集合具有区分不同元组的作用。</p>
<p><strong>超键</strong>：可以唯一标识每个元组的属性。</p>
<p><strong>候选键</strong>：任意真子集都不是超键的超键。即极小的超键。</p>
<p><strong>主键</strong>：每个关系都有至少一个候选键，人为指定其中一个作为主键。</p>
<p><strong>外键</strong>：设F为关系R的属性子集。若F与关系S的主键K相对，则称F为R的外键。</p>
<h4 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h4><p>查询语言的类型：关系代数、关系演算、结构化查询语言SQL。</p>
<h4 id="关系完整性约束"><a href="#关系完整性约束" class="headerlink" title="关系完整性约束"></a>关系完整性约束</h4><p>完整性约束的类型：实体完整性、参照完整性、用户定义完整性。</p>
<p>实体完整性约束规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主键值唯一且非空。</span><br></pre></td></tr></table></figure>
<p>参照完整性约束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于外键的约束，外键值为空或不为空则必须在S存在。</span><br></pre></td></tr></table></figure>
<p>用户定义完整性约束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据需求定义。</span><br></pre></td></tr></table></figure>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p><img src="/2022/04/19/DBMS/image-20220429102419874.png" alt="image-20220429102419874" style="zoom:50%;"></p>
<h4 id="选择操作"><a href="#选择操作" class="headerlink" title="选择操作"></a>选择操作</h4><p><img src="/2022/04/19/DBMS/image-20220429102724224.png" alt="image-20220429102724224" style="zoom:50%;"></p>
<h4 id="投影操作"><a href="#投影操作" class="headerlink" title="投影操作"></a>投影操作</h4><p><img src="/2022/04/19/DBMS/image-20220429102802024.png" alt="image-20220429102802024" style="zoom:50%;"></p>
<h4 id="并操作"><a href="#并操作" class="headerlink" title="并操作"></a>并操作</h4><p><img src="/2022/04/19/DBMS/image-20220429102936467.png" alt="image-20220429102936467" style="zoom:50%;"></p>
<h4 id="差操作"><a href="#差操作" class="headerlink" title="差操作"></a>差操作</h4><p><img src="/2022/04/19/DBMS/image-20220429103101865.png" alt="image-20220429103101865" style="zoom:50%;"></p>
<h4 id="笛卡尔积操作"><a href="#笛卡尔积操作" class="headerlink" title="笛卡尔积操作"></a>笛卡尔积操作</h4><p><img src="/2022/04/19/DBMS/image-20220429103204733.png" alt="image-20220429103204733"></p>
<p>笛卡尔积作用仅仅是将R和S无条件连接起来。</p>
<h4 id="重命名操作"><a href="#重命名操作" class="headerlink" title="重命名操作"></a>重命名操作</h4><p><img src="/2022/04/19/DBMS/image-20220429103735239.png" alt="image-20220429103735239" style="zoom:50%;"></p>
<h4 id="派生关系代数操作"><a href="#派生关系代数操作" class="headerlink" title="派生关系代数操作"></a>派生关系代数操作</h4><p><img src="/2022/04/19/DBMS/image-20220429103929302.png" alt="image-20220429103929302" style="zoom:50%;"></p>
<h4 id="交操作"><a href="#交操作" class="headerlink" title="交操作"></a>交操作</h4><p><img src="/2022/04/19/DBMS/image-20220429103955343.png" alt="image-20220429103955343" style="zoom: 50%;"></p>
<h4 id="theta-连接"><a href="#theta-连接" class="headerlink" title="$\theta$连接"></a>$\theta$连接</h4><p><img src="/2022/04/19/DBMS/image-20220429104206279.png" alt="image-20220429104206279" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220429104313090.png" alt="image-20220429104313090" style="zoom:50%;"></p>
<p><strong>等值连接</strong>：连接条件仅涉及相等比较的连接称作等值连接。</p>
<h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><p><img src="/2022/04/19/DBMS/image-20220429104433735.png" alt="image-20220429104433735" style="zoom:50%;"></p>
<p>自然连接与$\theta$连接的区别</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>自然连接</th>
<th>$\theta$连接</th>
</tr>
</thead>
<tbody>
<tr>
<td>连接条件</td>
<td>隐含给出</td>
<td>明确给出</td>
</tr>
<tr>
<td>结果属性</td>
<td>去掉重复的同名属性</td>
<td>保留重名的同名属性</td>
</tr>
</tbody>
</table>
</div>
<h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p><img src="/2022/04/19/DBMS/image-20220429152859130.png" alt="image-20220429152859130" style="zoom:50%;"></p>
<h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p><img src="/2022/04/19/DBMS/image-20220429152930580.png" alt="image-20220429152930580" style="zoom:50%;"></p>
<h4 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h4><p><img src="/2022/04/19/DBMS/image-20220429153001556.png" alt="image-20220429153001556" style="zoom:50%;"></p>
<h4 id="除"><a href="#除" class="headerlink" title="除"></a>除</h4><p><img src="/2022/04/19/DBMS/image-20220429153136222.png" alt="image-20220429153136222" style="zoom:50%;"></p>
<h4 id="扩展关系代数操作"><a href="#扩展关系代数操作" class="headerlink" title="扩展关系代数操作"></a>扩展关系代数操作</h4><p><img src="/2022/04/19/DBMS/image-20220429153530381.png" alt="image-20220429153530381" style="zoom:50%;"></p>
<h4 id="分组操作"><a href="#分组操作" class="headerlink" title="分组操作"></a>分组操作</h4><p><img src="/2022/04/19/DBMS/image-20220429153851312.png" alt="image-20220429153851312" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220429154021150.png" alt="image-20220429154021150" style="zoom:50%;"></p>
<p>eg：<img src="/2022/04/19/DBMS/image-20220429154350259.png" alt="image-20220429154350259" style="zoom:50%;"></p>
<h4 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h4><p><img src="/2022/04/19/DBMS/image-20220429154424910.png" alt="image-20220429154424910" style="zoom:50%;"></p>
<h3 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h3><p><img src="/2022/04/19/DBMS/image-20220429154749803.png" alt="image-20220429154749803" style="zoom:50%;"></p>
<p>eg：<img src="/2022/04/19/DBMS/image-20220429154903454.png" alt="image-20220429154903454" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220429155326624.png" alt="image-20220429155326624" style="zoom:50%;"></p>
<p>eg：<img src="/2022/04/19/DBMS/image-20220429155635735.png" alt="image-20220429155635735" style="zoom:50%;"></p>
<h2 id="三、结构化查询语言"><a href="#三、结构化查询语言" class="headerlink" title="三、结构化查询语言"></a>三、结构化查询语言</h2><h3 id="SQL数据定义"><a href="#SQL数据定义" class="headerlink" title="SQL数据定义"></a>SQL数据定义</h3><p><strong>声明用户定义完整性约束</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">规定属性值非空</span><br><span class="line">规定属性值不重复</span><br><span class="line">定义属性缺省值</span><br><span class="line">规定属性值必须满足表达式给出的条件</span><br></pre></td></tr></table></figure>
<p><strong>定义视图</strong></p>
<p>从用户视角所看到的数据</p>
<h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><p>修改：update 关系名 set </p>
<p><strong>数据完整性检查</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目的：数据修改可能导致数据库违反完整性约束，需要对数据完整性进行检查</span><br><span class="line">功能：实体完整性检查</span><br><span class="line">参照完整性检查</span><br><span class="line">用户定义完整性检查</span><br></pre></td></tr></table></figure>
<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><p>选择查询条件</p>
<p><img src="/2022/04/19/DBMS/image-20220430151413245.png" alt="image-20220430151413245" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220430151423792.png" alt="image-20220430151423792" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220430151432387.png" alt="image-20220430151432387" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220430151614464.png" alt="image-20220430151614464" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220430152007869.png" alt="image-20220430152007869" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220430152148390.png" alt="image-20220430152148390" style="zoom:50%;"></p>
<p><strong>注意</strong>：空值判断，应用 is null,不可以用 =或者！=</p>
<p>集合操作</p>
<p><img src="/2022/04/19/DBMS/image-20220430152507160.png" alt="image-20220430152507160" style="zoom:50%;"></p>
<p>查询结果排序</p>
<p><img src="/2022/04/19/DBMS/image-20220430152758643.png" alt="image-20220430152758643" style="zoom:50%;"></p>
<p>限制查询结果数量</p>
<p><img src="/2022/04/19/DBMS/image-20220430153226417.png" alt="image-20220430153226417" style="zoom:50%;"></p>
<p>聚集查询</p>
<p><img src="/2022/04/19/DBMS/image-20220430153259151.png" alt="image-20220430153259151" style="zoom:50%;"></p>
<p><strong>注</strong>：聚集函数不能出现在where子句中</p>
<p>分组查询</p>
<p><img src="/2022/04/19/DBMS/image-20220430154427314.png" alt="image-20220430154427314" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220430154532489.png" alt="image-20220430154532489" style="zoom:50%;"></p>
<p><strong>注意事项</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220430154629326.png" alt="image-20220430154629326" style="zoom:50%;"></p>
<h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>内连接</p>
<p><img src="/2022/04/19/DBMS/image-20220430154937567.png" alt="image-20220430154937567" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220430155011604.png" alt="image-20220430155011604" style="zoom:50%;"></p>
<p>自然连接</p>
<p><img src="/2022/04/19/DBMS/image-20220430155059752.png" alt="image-20220430155059752" style="zoom:50%;"></p>
<p>自连接</p>
<p><img src="/2022/04/19/DBMS/image-20220430155231450.png" alt="image-20220430155231450" style="zoom:50%;"></p>
<p>外连接</p>
<p><img src="/2022/04/19/DBMS/image-20220430155522668.png" alt="image-20220430155522668" style="zoom:50%;"></p>
<h4 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h4><p><img src="/2022/04/19/DBMS/image-20220430155907373.png" alt="image-20220430155907373" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220430162018068.png" alt="image-20220430162018068" style="zoom:50%;"></p>
<p>使用exists关键字进行查询的时候，首先，我们先查询的不是子查询的内容，而是查我们的主查询的表，然后，根据表的每一条记录，依次去判断where后面的条件是否成立。</p>
<p>in在查询的时候，首先查询子查询的表，然后将内表和外表做一个笛卡尔积，然后按照条件进行筛选。所以相对内表比较小的时候，in的速度较快。</p>
<p>嵌套查询的写法</p>
<p><img src="/2022/04/19/DBMS/image-20220430162413322.png" alt="image-20220430162413322" style="zoom:50%;"></p>
<p>派生</p>
<p><img src="/2022/04/19/DBMS/image-20220430162522047.png" alt="image-20220430162522047" style="zoom:50%;"></p>
<h2 id="四、概念数据库设计"><a href="#四、概念数据库设计" class="headerlink" title="四、概念数据库设计"></a>四、概念数据库设计</h2><h3 id="数据库设计的过程"><a href="#数据库设计的过程" class="headerlink" title="数据库设计的过程"></a>数据库设计的过程</h3><p><img src="/2022/04/19/DBMS/image-20220503171629777.png" alt="image-20220503171629777" style="zoom:50%;"></p>
<h3 id="实体-联系模型"><a href="#实体-联系模型" class="headerlink" title="实体-联系模型"></a>实体-联系模型</h3><p><strong>实体-联系模型</strong>：简称ER模型，用于将现实世界抽象为实体及实体间的联系。</p>
<p>ER模型概念：</p>
<p><img src="/2022/04/19/DBMS/image-20220503194731246.png" alt="image-20220503194731246" style="zoom:50%;"></p>
<h4 id="与实体相关的概念"><a href="#与实体相关的概念" class="headerlink" title="与实体相关的概念"></a>与实体相关的概念</h4><p><strong>实体</strong>：数据库中表示的现实世界中的具体对象或事物。</p>
<p><strong>属性</strong>：用于刻画实体的特性。</p>
<p><strong>属性的类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">简单属性</span><br><span class="line">复合属性</span><br><span class="line">多值属性</span><br><span class="line">派生属性</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/19/DBMS/image-20220503195624675.png" alt="image-20220503195624675"></p>
<h5 id="实体型的ER图表示"><a href="#实体型的ER图表示" class="headerlink" title="实体型的ER图表示"></a>实体型的ER图表示</h5><p><img src="/2022/04/19/DBMS/image-20220503200250388.png" alt="image-20220503200250388" style="zoom:50%;"></p>
<p><strong>弱实体型</strong>：没有键属性的实体型。</p>
<p><strong>标识实体型、属主实体型</strong>：由于弱实体型没有键属性，需要依赖于其他实体型进行区分。</p>
<p><strong>标识联系型</strong>：弱实体型与其标识实体型通过标识联系型关联。</p>
<p><strong>部分键</strong>：用于区分和同一标识实体相关联的弱实体的属性集合。</p>
<p><img src="/2022/04/19/DBMS/image-20220503201117189.png" alt="image-20220503201117189" style="zoom:50%;"></p>
<h4 id="与联系相关的概念"><a href="#与联系相关的概念" class="headerlink" title="与联系相关的概念"></a>与联系相关的概念</h4><p><strong>联系</strong>：一个联系表示多个实体之间有意义的关联关系。</p>
<p><strong>联系型</strong>：同一类联系共同具有的类型。</p>
<p><strong>联系型的度</strong>：参与到一个联系型中的实体型的个数。</p>
<p><strong>联系集</strong>：数据库中当前存储的联系型的实例的集合。</p>
<p><img src="/2022/04/19/DBMS/image-20220503202245562.png" alt="image-20220503202245562" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220503202303200.png" alt="image-20220503202303200" style="zoom:50%;"></p>
<h5 id="联系型的约束"><a href="#联系型的约束" class="headerlink" title="联系型的约束"></a>联系型的约束</h5><p><img src="/2022/04/19/DBMS/image-20220503202559606.png" alt="image-20220503202559606" style="zoom:50%;"></p>
<p><strong>存在依赖约束/参与度约束</strong>：刻画实体型参与到联系型中的最小基数。</p>
<h5 id="联系型的属性"><a href="#联系型的属性" class="headerlink" title="联系型的属性"></a>联系型的属性</h5><p><img src="/2022/04/19/DBMS/image-20220503204803972.png" alt="image-20220503204803972" style="zoom:50%;"></p>
<p>多元联系：3个以上实体参与的联系</p>
<h3 id="增强ER模型"><a href="#增强ER模型" class="headerlink" title="增强ER模型"></a>增强ER模型</h3><p><img src="/2022/04/19/DBMS/image-20220503205006243.png" alt="image-20220503205006243" style="zoom:50%;"></p>
<h5 id="子类-超类"><a href="#子类-超类" class="headerlink" title="子类/超类"></a>子类/超类</h5><p><img src="/2022/04/19/DBMS/image-20220503205634485.png" alt="image-20220503205634485" style="zoom:50%;"></p>
<p><strong>不相交子类</strong>：若超类的每个实体属于最多一个子类，则子类是不相交的。</p>
<p><strong>重叠子类</strong>：若超类的每个实体可以属于多个子类，则子类是重叠的。</p>
<p><strong>全部特化</strong>：超类的每个实体必须属于至少一个子类。</p>
<p><strong>部分特化</strong>；超类的某些实体可以不属于任何子类。</p>
<h2 id="五、逻辑数据库设计"><a href="#五、逻辑数据库设计" class="headerlink" title="五、逻辑数据库设计"></a>五、逻辑数据库设计</h2><h3 id="ER模型转换为关系数据库模式"><a href="#ER模型转换为关系数据库模式" class="headerlink" title="ER模型转换为关系数据库模式"></a>ER模型转换为关系数据库模式</h3><p><strong>实体型的转换</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220503211916414.png" alt="image-20220503211916414" style="zoom:50%;"></p>
<p><strong>复合属性的转换</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220503211959174.png" alt="image-20220503211959174" style="zoom:50%;"></p>
<p><strong>多值属性的转换</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220503212559635.png" alt="image-20220503212559635" style="zoom:50%;"></p>
<p><strong>弱实体型的转换</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220503213011437.png" alt="image-20220503213011437" style="zoom:50%;"></p>
<p><strong>M:N二元联系型的转换</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220503213209789.png" alt="image-20220503213209789" style="zoom:50%;"></p>
<p><strong>N:1二元联系型的转换</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220505150449415.png" alt="image-20220505150449415" style="zoom:50%;"></p>
<p><strong>1:1二元联系型的转换</strong></p>
<p>与N:1相同</p>
<p><strong>二元自联系型的转换</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220505150832315.png" alt="image-20220505150832315" style="zoom: 50%;"></p>
<p><strong>标识联系型的转换</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220505151309647.png" alt="image-20220505151309647" style="zoom:50%;"></p>
<p><strong>设计不合理的关系可能产生的异常问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据更新问题</span><br><span class="line">数据冗余问题</span><br></pre></td></tr></table></figure>
<p><strong>知识要点图</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220505152648076.png" alt="image-20220505152648076" style="zoom:50%;"></p>
<h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>定义</p>
<p><img src="/2022/04/19/DBMS/image-20220505153034089.png" alt="image-20220505153034089" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220505153146687.png" alt="image-20220505153146687" style="zoom:50%;"></p>
<p>类型</p>
<p><img src="/2022/04/19/DBMS/image-20220505153456821.png" alt="image-20220505153456821" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220505154107287.png" alt="image-20220505154107287" style="zoom:50%;"></p>
<h4 id="函数依赖的公理系统"><a href="#函数依赖的公理系统" class="headerlink" title="函数依赖的公理系统"></a>函数依赖的公理系统</h4><p><strong>逻辑蕴含</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220505154619657.png" alt="image-20220505154619657" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220505154814471.png" alt="image-20220505154814471" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220505155016364.png" alt="image-20220505155016364" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220505155029011.png" alt="image-20220505155029011" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220505155051886.png" alt="image-20220505155051886" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220505155443317.png" alt="image-20220505155443317" style="zoom:50%;"></p>
<h4 id="等价函数依赖集"><a href="#等价函数依赖集" class="headerlink" title="等价函数依赖集"></a>等价函数依赖集</h4><p><strong>相关概念</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220505161038489.png" alt="image-20220505161038489" style="zoom:50%;"></p>
<p><strong>最小覆盖</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220505161611936.png" alt="image-20220505161611936" style="zoom:50%;"></p>
<h3 id="关系模式的范式"><a href="#关系模式的范式" class="headerlink" title="关系模式的范式"></a>关系模式的范式</h3><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>若关系模式R的每个属性都是不可分的，则称R为第一范式关系模式。</p>
<p>存在问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据插入异常</span><br><span class="line">数据删除异常</span><br><span class="line">数据修改繁琐</span><br><span class="line">数据冗余</span><br></pre></td></tr></table></figure>
<p>原因</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">非主属性部分函数依赖于候选键</span><br></pre></td></tr></table></figure>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p><img src="/2022/04/19/DBMS/image-20220505162809352.png" alt="image-20220505162809352" style="zoom:50%;"></p>
<p>存在问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据插入异常</span><br><span class="line">数据删除异常</span><br><span class="line">数据修改繁琐</span><br><span class="line">数据冗余</span><br></pre></td></tr></table></figure>
<p>原因</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">非主属性传递函数依赖于候选键</span><br></pre></td></tr></table></figure>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p><img src="/2022/04/19/DBMS/image-20220505163512256.png" alt="image-20220505163512256" style="zoom:50%;"></p>
<p>存在问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据插入异常</span><br><span class="line">数据删除异常</span><br><span class="line">数据修改繁琐</span><br><span class="line">数据冗余</span><br></pre></td></tr></table></figure>
<p>原因</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主属性部分依赖于候选键</span><br></pre></td></tr></table></figure>
<h4 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h4><p><img src="/2022/04/19/DBMS/image-20220505164427068.png" alt="image-20220505164427068" style="zoom:50%;"></p>
<p>消除主属性间的传递依赖。</p>
<h3 id="关系模式分解"><a href="#关系模式分解" class="headerlink" title="关系模式分解"></a>关系模式分解</h3><p><img src="/2022/04/19/DBMS/image-20220505221923466.png" alt="image-20220505221923466" style="zoom:50%;"></p>
<p>分解准则1：无损连接性</p>
<p><img src="/2022/04/19/DBMS/image-20220505223653143.png" alt="image-20220505223653143" style="zoom:50%;"></p>
<p>分解准则2：函数依赖保持性</p>
<p><img src="/2022/04/19/DBMS/image-20220505224121199.png" alt="image-20220505224121199" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220505224450639.png" alt="image-20220505224450639" style="zoom:50%;"></p>
<p>无损连接性判定</p>
<p><img src="/2022/04/19/DBMS/image-20220505224650480.png" alt="image-20220505224650480" style="zoom:50%;"></p>
<p>函数依赖保持性判定</p>
<p><img src="/2022/04/19/DBMS/image-20220505225103477.png" alt="image-20220505225103477" style="zoom:50%;"></p>
<h4 id="关系模式分解方法"><a href="#关系模式分解方法" class="headerlink" title="关系模式分解方法"></a>关系模式分解方法</h4><p><img src="/2022/04/19/DBMS/image-20220505225520028.png" alt="image-20220505225520028" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220505225621412.png" alt="image-20220505225621412" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220505230144599.png" alt="image-20220505230144599" style="zoom:50%;"></p>
<h2 id="六、物理数据库设计"><a href="#六、物理数据库设计" class="headerlink" title="六、物理数据库设计"></a>六、物理数据库设计</h2><h3 id="物理数据库设计概述"><a href="#物理数据库设计概述" class="headerlink" title="物理数据库设计概述"></a>物理数据库设计概述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在逻辑数据库设计的基础上，为数据库中的关系选择合适的存储结构和存取方法，并进行数据库调优，使数据库上的事务能够高效执行。</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/19/DBMS/image-20220517092422735.png" alt="image-20220517092422735" style="zoom: 50%;"></p>
<h3 id="工作负载分析"><a href="#工作负载分析" class="headerlink" title="工作负载分析"></a>工作负载分析</h3><p><strong>工作负载</strong>是一组混合在一起的查询和更新。</p>
<p><strong>选择度</strong>：满足条件的结果元组在全部候选元组中所占的比例。</p>
<h3 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h3><p><strong>索引设计的基本过程</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220517093148475.png" alt="image-20220517093148475" style="zoom: 50%;"></p>
<h4 id="索引设计的准则"><a href="#索引设计的准则" class="headerlink" title="索引设计的准则"></a><strong>索引设计的准则</strong></h4><p>1.是否建索引</p>
<p><img src="/2022/04/19/DBMS/image-20220517093239212.png" alt="image-20220517093239212" style="zoom: 50%;"></p>
<p>2.索引键的确定</p>
<p><img src="/2022/04/19/DBMS/image-20220517093413507.png" alt="image-20220517093413507" style="zoom:50%;"></p>
<p>3.复合索引的设计</p>
<p><img src="/2022/04/19/DBMS/image-20220517093654977.png" alt="image-20220517093654977" style="zoom:50%;"></p>
<p><strong>B+树支持的查询</strong></p>
<p>全值匹配：和所有索引属性进行匹配</p>
<p>匹配最左前缀：和前面几个索引属性进行匹配</p>
<p>匹配属性前缀：只匹配前缀属性的前缀部分</p>
<p>范围匹配：在给定范围内对前缀进行匹配</p>
<p>精确匹配某一属性并范围匹配另一属性</p>
<p>B+树还支持索引属性排序</p>
<p><strong>B+树的限制</strong></p>
<p>必须从B+树的最左属性开始匹配</p>
<p>条件中不能包含表达式</p>
<p>不能跳过B+树的属性</p>
<p>如果索引中有关某个属性的范围查询，则其右边所有属性都无法使用索引查找</p>
<p><strong>覆盖索引</strong></p>
<p>如果一个索引包含一个查询需要用到的所有属性，则称该索引为覆盖索引</p>
<p><img src="/2022/04/19/DBMS/image-20220517094732264.png" alt="image-20220517094732264" style="zoom:50%;"></p>
<p><strong>单个复合索引 vs 多个单属性索引</strong></p>
<p>方案一：建立一个符合索引</p>
<p>方案二：建立多个单属性索引</p>
<p>多个单属性索引的缺点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">没有在单个复合索引上做查询效率高</span><br><span class="line">索引合并涉及排序，要消耗大量计算和存储资源</span><br><span class="line">在查询优化时，索引合并的代价并不被计入，被低估了查询代价</span><br></pre></td></tr></table></figure>
<p>4.是否使用聚簇索引</p>
<p><img src="/2022/04/19/DBMS/image-20220517105950271.png" alt="image-20220517105950271" style="zoom:50%;"></p>
<ul>
<li>聚簇索引：将<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cdcs?from=10680">数据存储</a>与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li>
</ul>
<p>不同存取路径区别</p>
<p><img src="/2022/04/19/DBMS/image-20220517110305889.png" alt="image-20220517110305889" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517110324506.png" alt="image-20220517110324506" style="zoom:50%;"></p>
<p>5.用哈希表还是B+树</p>
<p><img src="/2022/04/19/DBMS/image-20220517110351806.png" alt="image-20220517110351806" style="zoom:50%;"></p>
<p>哈希表的限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不支持部分索引属性匹配</span><br><span class="line">只支持等值比较查询，不支持范围查询</span><br><span class="line">无法用于排序</span><br><span class="line">存在冲突</span><br></pre></td></tr></table></figure>
<p>6.权衡索引代价维护</p>
<p><img src="/2022/04/19/DBMS/image-20220517110455031.png" alt="image-20220517110455031"></p>
<p>7.不唯准则</p>
<p><img src="/2022/04/19/DBMS/image-20220517110521088.png" alt="image-20220517110521088"></p>
<h4 id="索引调优"><a href="#索引调优" class="headerlink" title="索引调优"></a>索引调优</h4><p>MYSQL索引设计技巧1：前缀索引</p>
<p><img src="/2022/04/19/DBMS/image-20220517110623727.png" alt="image-20220517110623727" style="zoom:50%;"></p>
<p>索引选择性：<img src="/2022/04/19/DBMS/image-20220517110657824.png" alt="image-20220517110657824" style="zoom:50%;"></p>
<p>MYSQL索引设计技巧2：聚簇索引</p>
<p><img src="/2022/04/19/DBMS/image-20220517110758667.png" alt="image-20220517110758667" style="zoom:50%;"></p>
<p>MYSQL索引设计技巧3：伪哈希索引</p>
<p><img src="/2022/04/19/DBMS/image-20220517110906396.png" alt="image-20220517110906396" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517110921919.png" alt="image-20220517110921919" style="zoom:50%;"></p>
<h3 id="内模式设计"><a href="#内模式设计" class="headerlink" title="内模式设计"></a>内模式设计</h3><p>关系是否采用聚簇索引？</p>
<p>若使用聚簇索引，应按哪些属性聚簇索引？</p>
<p>同聚簇索引设计准则。</p>
<h3 id="查询改写"><a href="#查询改写" class="headerlink" title="查询改写"></a>查询改写</h3><p>恒真/假的选择条件</p>
<p>含表达式的选择条件</p>
<p><img src="/2022/04/19/DBMS/image-20220517111330363.png" alt="image-20220517111330363" style="zoom:50%;"></p>
<p>无用的去重操作</p>
<p>无用的分组操作：分组操作昂贵</p>
<p>无用的投影操作</p>
<p>无用的连接操作</p>
<p>临时关系：占用额外存储空间，且其上没有索引</p>
<p>嵌套查询；查询器优化嵌套查询能力弱</p>
<p>类型转换</p>
<h3 id="概念模式调优"><a href="#概念模式调优" class="headerlink" title="概念模式调优"></a>概念模式调优</h3><p><img src="/2022/04/19/DBMS/image-20220517111617834.png" alt="image-20220517111617834" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517111626325.png" alt="image-20220517111626325" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517111717761.png" alt="image-20220517111717761" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517111725636.png" alt="image-20220517111725636" style="zoom:50%;"></p>
<p>数据类型选择</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.尽量使用可以正确存储的最小数据类型</span><br><span class="line">2.选择简单的数据类型</span><br><span class="line">3.最好将属性声明为not null</span><br></pre></td></tr></table></figure>
<p>标识符的选择</p>
<p><img src="/2022/04/19/DBMS/image-20220517111924723.png" alt="image-20220517111924723" style="zoom:50%;"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">整型：最好的选择，占用空间少，速度快</span><br><span class="line">ENUM和SET：糟糕的选择，比较时转换为字符串，速度慢，MYSQL内部用整型来存储这两个类型的值，占用空间少</span><br><span class="line">字符串型：糟糕的选择，空间大，速度慢</span><br></pre></td></tr></table></figure>
<h2 id="七、存储管理"><a href="#七、存储管理" class="headerlink" title="七、存储管理"></a>七、存储管理</h2><p>按CPU访问存储介质的方式，可将存储器分为三类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主存储器</span><br><span class="line">二级存储器</span><br><span class="line">三级存储器</span><br></pre></td></tr></table></figure>
<p>主存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">包括：寄存器、高速缓存、内存</span><br><span class="line">主存特点：按字节寻址、可使用load/store指令直接访问</span><br></pre></td></tr></table></figure>
<p>二级存储器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">包括：磁盘/机械硬盘、闪存/固态硬盘</span><br><span class="line">特点：按块寻址、联机使用 CPU无法直接访问，需用read、write将数据先复制到主存</span><br></pre></td></tr></table></figure>
<p>三级存储器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">包括：磁带、光盘、网络存储</span><br><span class="line">脱机使用、按块存储、需先将数据复制到二级存储</span><br></pre></td></tr></table></figure>
<p>存储层次间的数据传输</p>
<p><img src="/2022/04/19/DBMS/image-20220517140913250.png" alt="image-20220517140913250" style="zoom: 50%;"></p>
<p><strong>数据局部性</strong>：同一单元的数据经常被同时访问到</p>
<p>虚拟内存不是存储层级中的一层。</p>
<p>按存储介质的易失性/持久性，可分为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">易失性存储器：计算机重启后，易失性存储器的数据会丢失</span><br><span class="line">菲易失性存储器</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/19/DBMS/image-20220517141520177.png" alt="image-20220517141520177" style="zoom:50%;"></p>
<p>持久性内存又称<strong>非易失性内存</strong>：按字节寻址、非易失</p>
<p>磁盘</p>
<p><img src="/2022/04/19/DBMS/image-20220517150119891.png" alt="image-20220517150119891" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517150149305.png" alt="image-20220517150149305" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517150221095.png" alt="image-20220517150221095" style="zoom:50%;"></p>
<h3 id="数据库的文件存储"><a href="#数据库的文件存储" class="headerlink" title="数据库的文件存储"></a>数据库的文件存储</h3><p>将一个数据库存储为一个或多个文件；每个文件包含多个页。</p>
<p>数据库文件的页可以存储元组、元数据、索引、日志记录等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大多数DBMS在一个页中只存储一种类型对象。</span><br></pre></td></tr></table></figure>
<p>每个页拥有唯一编号，称作页号。</p>
<p>DBMS的存储管理器负责管理数据库文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">记录页中元组的读/写</span><br><span class="line">记录页中的空闲空间</span><br></pre></td></tr></table></figure>
<p>文件存储的分类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">面向行的存储</span><br><span class="line">面向列的存储</span><br></pre></td></tr></table></figure>
<h4 id="各种表示"><a href="#各种表示" class="headerlink" title="各种表示"></a>各种表示</h4><p>数<img src="/2022/04/19/DBMS/image-20220517150756822.png" alt="image-20220517150756822" style="zoom:50%;"></p>
<p>字符串<img src="/2022/04/19/DBMS/image-20220517150806178.png" alt="image-20220517150806178" style="zoom:50%;"></p>
<p>元组<img src="/2022/04/19/DBMS/image-20220517150906343.png" alt="image-20220517150906343" style="zoom:50%;"></p>
<p>元组头<img src="/2022/04/19/DBMS/image-20220517150929367.png" alt="image-20220517150929367" style="zoom:50%;"></p>
<p>元组数据<img src="/2022/04/19/DBMS/image-20220517150952603.png" alt="image-20220517150952603" style="zoom:50%;"></p>
<p>变长元组的布局<img src="/2022/04/19/DBMS/image-20220517151016064.png" alt="image-20220517151016064" style="zoom:50%;"></p>
<p>页布局<img src="/2022/04/19/DBMS/image-20220517151037574.png" alt="image-20220517151037574" style="zoom:50%;"></p>
<p>页头<img src="/2022/04/19/DBMS/image-20220517151052727.png" alt="image-20220517151052727" style="zoom:50%;"></p>
<p>页数据<img src="/2022/04/19/DBMS/image-20220517151136047.png" alt="image-20220517151136047" style="zoom:50%;"></p>
<p><strong>面向元组的组织方法</strong></p>
<p>分槽页是最常见的面向元组的数据组织方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">槽数据</span><br><span class="line">元组序列</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/19/DBMS/image-20220517151256195.png" alt="image-20220517151256195" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517151329418.png" alt="image-20220517151329418" style="zoom:50%;"></p>
<p>槽的元数据存储在页头中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">槽的数量：用于确定下一个空闲槽的编号</span><br><span class="line">最后一个槽的起始位置的偏移量：用于确定新元组的插入位置</span><br></pre></td></tr></table></figure>
<p><strong>记录号</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220517151514495.png" alt="image-20220517151514495" style="zoom:50%;"></p>
<p><strong>溢出页</strong><img src="/2022/04/19/DBMS/image-20220517151912914.png" alt="image-20220517151912914" style="zoom:50%;"></p>
<p>页碎片化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">随着元组删除或版本过期，其中会产生碎片：浪费磁盘空间、增加磁盘I/O</span><br></pre></td></tr></table></figure>
<p>日志结构页布局</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件中只存储数据更新操作的日志记录，而不存储元组</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">新的日志记录只能写到文件末尾</span><br><span class="line">插入操作的日志记录包含整个插入的元组</span><br><span class="line">删除操作的日志记录包含被删除的元组的主键</span><br><span class="line">修改操作的日志记录包含被修改的元组的主键，被修改的属性及修改后的属性值</span><br></pre></td></tr></table></figure>
<p>读元组<img src="/2022/04/19/DBMS/image-20220517153113658.png" alt="image-20220517153113658" style="zoom:50%;"></p>
<p>日志记录索引<img src="/2022/04/19/DBMS/image-20220517153153633.png" alt="image-20220517153153633" style="zoom:50%;"></p>
<p>日志记录合并<img src="/2022/04/19/DBMS/image-20220517153318250.png" alt="image-20220517153318250" style="zoom:50%;"></p>
<h4 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h4><p>法一：堆文件组织</p>
<p>法二：顺序/有序文件组织</p>
<p>法三：哈希文件组织</p>
<p><strong>堆文件组织</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220517154020888.png" alt="image-20220517154020888" style="zoom:50%;"></p>
<p><strong>基于链表的页组织方式</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220517154058030.png" alt="image-20220517154058030" style="zoom:50%;"></p>
<p><strong>基于页目录的堆文件页组织方式</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220517154149229.png" alt="image-20220517154149229" style="zoom:50%;"></p>
<p><strong>顺序/有序文件组织</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220517155245093.png" alt="image-20220517155245093" style="zoom:50%;"></p>
<p><strong>哈希文件组织</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220517155305809.png" alt="image-20220517155305809" style="zoom:50%;"></p>
<h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><p><img src="/2022/04/19/DBMS/image-20220517155330366.png" alt="image-20220517155330366" style="zoom:50%;"></p>
<p>缓冲池的页称作页框</p>
<p>页表<img src="/2022/04/19/DBMS/image-20220517155451024.png" alt="image-20220517155451024" style="zoom:50%;"></p>
<p>DBMS用两个变量记录缓冲池中每个页框的状态</p>
<p><img src="/2022/04/19/DBMS/image-20220517155552825.png" alt="image-20220517155552825" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517155602529.png" alt="image-20220517155602529" style="zoom:50%;"></p>
<p>缓冲区功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求页；修改页；释放页</span><br></pre></td></tr></table></figure>
<p><strong>请求页</strong></p>
<p>1.<img src="/2022/04/19/DBMS/image-20220517155820278.png" alt="image-20220517155820278" style="zoom:50%;"></p>
<p>2.<img src="/2022/04/19/DBMS/image-20220517155834306.png" alt="image-20220517155834306" style="zoom:50%;"></p>
<p>3.<img src="/2022/04/19/DBMS/image-20220517155852966.png" alt="image-20220517155852966" style="zoom:50%;"></p>
<p>实际在情况3下，DBMS会终止提出该请求的事务，为了避免资源浪费</p>
<p><strong>页替换策略</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220517160334148.png" alt="image-20220517160334148" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517160404076.png" alt="image-20220517160404076" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517160413288.png" alt="image-20220517160413288" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517160425855.png" alt="image-20220517160425855" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517160437840.png" alt="image-20220517160437840" style="zoom:50%;"></p>
<p>缓冲池与虚拟内存的相同点</p>
<p><img src="/2022/04/19/DBMS/image-20220517160507768.png" alt="image-20220517160507768" style="zoom:50%;"></p>
<p>缓冲池与虚拟内存的不同点</p>
<p>1.<img src="/2022/04/19/DBMS/image-20220517160644326.png" alt="image-20220517160644326" style="zoom:50%;"></p>
<p>2.<img src="/2022/04/19/DBMS/image-20220517160704040.png" alt="image-20220517160704040" style="zoom:50%;"></p>
<p><strong>面向行的存储</strong><img src="/2022/04/19/DBMS/image-20220517160738464.png" alt="image-20220517160738464" style="zoom:50%;"></p>
<p><strong>面向列的存储</strong><img src="/2022/04/19/DBMS/image-20220517160804399.png" alt="image-20220517160804399" style="zoom:50%;"></p>
<p>缺点：面向列的存储适合于联机分析处理，不适合于联机事务处理。元组重构代价高，元组删除和修改代价高；解压代价</p>
<h2 id="八、索引结构"><a href="#八、索引结构" class="headerlink" title="八、索引结构"></a>八、索引结构</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>有序索引：通过按索引键有序排列索引项来实现索引</p>
<p>哈希索引：通过按索引键哈希值分桶来实现索引</p>
<p>有序索引<img src="/2022/04/19/DBMS/image-20220517164143525.png" alt="image-20220517164143525" style="zoom:50%;"></p>
<p>哈希索引<img src="/2022/04/19/DBMS/image-20220517164528124.png" alt="image-20220517164528124" style="zoom:50%;"></p>
<h4 id="有序索引"><a href="#有序索引" class="headerlink" title="有序索引"></a>有序索引</h4><h5 id="一"><a href="#一" class="headerlink" title="一"></a>一</h5><p>根据数据文件中的元组是否按索引键值排序，分为聚簇索引与非聚簇索引。</p>
<p><strong>聚簇索引</strong></p>
<p>文件中的元组按索引键排序的，则索引为聚簇索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">聚簇索引的索引键通常为关系主键；</span><br><span class="line">一个关系通常只有一个聚簇索引</span><br></pre></td></tr></table></figure>
<p><strong>非聚簇索引</strong></p>
<p>文件中的元组不按索引键排序的，则索引为非聚簇索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个关系上可以有多个非聚簇索引</span><br></pre></td></tr></table></figure>
<p><strong>索引组织表</strong></p>
<p>索引组织表=聚簇索引文件+数据文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在索引组织表中，聚簇索引的索引项中存储元组本身，而不是地址</span><br></pre></td></tr></table></figure>
<h5 id="二"><a href="#二" class="headerlink" title="二"></a>二</h5><p>根据关系中每个元组在索引中是否都有一个对应索引项，可将有序索引分为两类：稠密索引、稀疏索引</p>
<p>稠密索引<img src="/2022/04/19/DBMS/image-20220517165842013.png" alt="image-20220517165842013" style="zoom:50%;"></p>
<p>稀疏索引<img src="/2022/04/19/DBMS/image-20220517165923898.png" alt="image-20220517165923898" style="zoom:50%;"></p>
<h5 id="三"><a href="#三" class="headerlink" title="三"></a>三</h5><p>根据索引键是否为关系的主键，可将有序索引分为两类：主索引，二级索引</p>
<p>主索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引键为主键；一个关系只有一个</span><br></pre></td></tr></table></figure>
<p>二级索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">索引键不是主键：</span><br><span class="line">通常为非聚簇索引，一个关系可以有多个</span><br></pre></td></tr></table></figure>
<h4 id="其他索引及创建方法"><a href="#其他索引及创建方法" class="headerlink" title="其他索引及创建方法"></a>其他索引及创建方法</h4><p>创建主索引：<img src="/2022/04/19/DBMS/image-20220517170535689.png" alt="image-20220517170535689" style="zoom:50%;"></p>
<p>创建二级索引：<img src="/2022/04/19/DBMS/image-20220517170606370.png" alt="image-20220517170606370" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517170620535.png" alt="image-20220517170620535" style="zoom:50%;"></p>
<p>唯一索引：索引键值不能重复<img src="/2022/04/19/DBMS/image-20220517170648750.png" alt="image-20220517170648750" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517170708910.png" alt="image-20220517170708910" style="zoom:50%;"></p>
<p>外键索引<img src="/2022/04/19/DBMS/image-20220517170727013.png" alt="image-20220517170727013" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517170735536.png" alt="image-20220517170735536" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517170745828.png" alt="image-20220517170745828" style="zoom:50%;"></p>
<h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><p>有序索引结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">平衡树</span><br><span class="line">跳表：多用于内存数据库系统</span><br><span class="line">字典树：多用于内存数据库系统</span><br><span class="line">日志结构合并树(LSM-tree)：多用于NoSQL数据库系统的存储引擎</span><br></pre></td></tr></table></figure>
<p>哈希索引数据结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">哈希表</span><br></pre></td></tr></table></figure>
<h5 id="哈希索引数据结构"><a href="#哈希索引数据结构" class="headerlink" title="哈希索引数据结构"></a>哈希索引数据结构</h5><p>外存哈希表<img src="/2022/04/19/DBMS/image-20220517171037285.png" alt="image-20220517171037285" style="zoom:50%;"></p>
<p>外存哈希表分类</p>
<p><img src="/2022/04/19/DBMS/image-20220517211355399.png" alt="image-20220517211355399" style="zoom:50%;"></p>
<h6 id="可扩展哈希表"><a href="#可扩展哈希表" class="headerlink" title="可扩展哈希表"></a>可扩展哈希表</h6><p><img src="/2022/04/19/DBMS/image-20220517211456832.png" alt="image-20220517211456832" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517211651367.png" alt="image-20220517211651367" style="zoom:50%;"></p>
<p>插入</p>
<p><img src="/2022/04/19/DBMS/image-20220517212217097.png" alt="image-20220517212217097" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517212500110.png" alt="image-20220517212500110" style="zoom:50%;"></p>
<p>删除<img src="/2022/04/19/DBMS/image-20220517212517570.png" alt="image-20220517212517570" style="zoom:50%;"></p>
<h6 id="线性哈希表"><a href="#线性哈希表" class="headerlink" title="线性哈希表"></a>线性哈希表</h6><p><img src="/2022/04/19/DBMS/image-20220517214121658.png" alt="image-20220517214121658" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517214211543.png" alt="image-20220517214211543" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517214221085.png" alt="image-20220517214221085" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517214245133.png" alt="image-20220517214245133" style="zoom: 50%;"></p>
<p>二者对比</p>
<p><img src="/2022/04/19/DBMS/image-20220517214259200.png" alt="image-20220517214259200" style="zoom:50%;"></p>
<h5 id="树索引结构"><a href="#树索引结构" class="headerlink" title="树索引结构"></a>树索引结构</h5><h6 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h6><p><img src="/2022/04/19/DBMS/image-20220517214437003.png" alt="image-20220517214437003" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517214541700.png" alt="image-20220517214541700" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517214557404.png" alt="image-20220517214557404" style="zoom:50%;"></p>
<p>B+树插入、删除，看教程，此处不详细说明。</p>
<p>B+树演示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cmudb.io/btree</span><br></pre></td></tr></table></figure>
<h3 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h3><p>键压缩<img src="/2022/04/19/DBMS/image-20220517214820891.png" alt="image-20220517214820891" style="zoom:50%;"></p>
<p>前缀压缩<img src="/2022/04/19/DBMS/image-20220517214843143.png" alt="image-20220517214843143" style="zoom: 50%;"></p>
<p>后缀截断<img src="/2022/04/19/DBMS/image-20220517214926314.png" alt="image-20220517214926314" style="zoom: 50%;"></p>
<p>批量加载</p>
<p><img src="/2022/04/19/DBMS/image-20220517215000544.png" alt="image-20220517215000544" style="zoom: 50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517215023090.png" alt="image-20220517215023090" style="zoom:50%;"></p>
<h4 id="LSM-Trees"><a href="#LSM-Trees" class="headerlink" title="LSM-Trees"></a>LSM-Trees</h4><p>B+树的原地更新<img src="/2022/04/19/DBMS/image-20220517215143044.png" alt="image-20220517215143044" style="zoom:50%;"></p>
<p>日志结构合并树<img src="/2022/04/19/DBMS/image-20220517215251194.png" alt="image-20220517215251194" style="zoom:50%;"></p>
<p>LSM树的基本结构<img src="/2022/04/19/DBMS/image-20220517215332847.png" alt="image-20220517215332847" style="zoom:50%;"></p>
<p>LSM的查找<img src="/2022/04/19/DBMS/image-20220517215352335.png" alt="image-20220517215352335" style="zoom:50%;"></p>
<p>缺点：当不可变文件非常大时，在文件上查找效率很慢</p>
<p>LSM的更新<img src="/2022/04/19/DBMS/image-20220517215447877.png" alt="image-20220517215447877" style="zoom:50%;"></p>
<p>分层LSM</p>
<p><img src="/2022/04/19/DBMS/image-20220517215513155.png" alt="image-20220517215513155" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517215526939.png" alt="image-20220517215526939" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517215545511.png" alt="image-20220517215545511" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517215827832.png" alt="image-20220517215827832" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517215845457.png" alt="image-20220517215845457" style="zoom:50%;"></p>
<p><strong>位图索引</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220517220627495.png" alt="image-20220517220627495" style="zoom:50%;"></p>
<p><strong>空间索引</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220517220638946.png" alt="image-20220517220638946" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517220649102.png" alt="image-20220517220649102" style="zoom:50%;"></p>
<h2 id="九-查询执行"><a href="#九-查询执行" class="headerlink" title="九.查询执行"></a>九.查询执行</h2><p>查询处理的基本过程</p>
<p><img src="/2022/04/19/DBMS/image-20220427155415469.png" alt="image-20220427155415469" style="zoom:50%;"></p>
<p><strong>原语操作</strong>：带有如何执行注释的关系代数操作。</p>
<p><strong>查询执行计划</strong>：用于执行一个查询的原语操作序列</p>
<p><img src="/2022/04/19/DBMS/image-20220427162137086.png" alt="image-20220427162137086" style="zoom:50%;"></p>
<h3 id="外排"><a href="#外排" class="headerlink" title="外排"></a>外排</h3><p>按照<strong>排序键</strong>对元组进行排序是DBMS非常重要的操作。</p>
<p> 外排序<img src="/2022/04/19/DBMS/image-20220517222109387.png" alt="image-20220517222109387" style="zoom:50%;"></p>
<h4 id="两趟多路外存归并排序"><a href="#两趟多路外存归并排序" class="headerlink" title="两趟多路外存归并排序"></a>两趟多路外存归并排序</h4><p>第一阶段：创建归并段</p>
<p>第二阶段：归并</p>
<p>记法<img src="/2022/04/19/DBMS/image-20220517222433566.png" alt="image-20220517222433566" style="zoom:50%;"></p>
<p>创建归并段<img src="/2022/04/19/DBMS/image-20220517222516708.png" alt="image-20220517222516708" style="zoom:50%;"></p>
<p>演示看PPT</p>
<p>算法分析<img src="/2022/04/19/DBMS/image-20220517222852523.png" alt="image-20220517222852523" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517222904328.png" alt="image-20220517222904328" style="zoom:50%;"></p>
<h4 id="多趟多路外存归并排序"><a href="#多趟多路外存归并排序" class="headerlink" title="多趟多路外存归并排序"></a>多趟多路外存归并排序</h4><p><img src="/2022/04/19/DBMS/image-20220517230415632.png" alt="image-20220517230415632" style="zoom:50%;"></p>
<p>优化</p>
<p><img src="/2022/04/19/DBMS/image-20220517231952042.png" alt="image-20220517231952042" style="zoom:50%;"></p>
<p>双缓冲<img src="/2022/04/19/DBMS/image-20220517232002315.png" alt="image-20220517232002315" style="zoom:50%;"></p>
<h3 id="关系代数操作的执行"><a href="#关系代数操作的执行" class="headerlink" title="关系代数操作的执行"></a>关系代数操作的执行</h3><h4 id="选择操作的执行"><a href="#选择操作的执行" class="headerlink" title="选择操作的执行"></a>选择操作的执行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.基于扫描的选择算法</span><br><span class="line">2.基于哈希的选择算法</span><br><span class="line">3.基于索引的选择算法</span><br></pre></td></tr></table></figure>
<p>记法<img src="/2022/04/19/DBMS/image-20220517232147225.png" alt="image-20220517232147225" style="zoom:50%;"></p>
<h5 id="基于扫描的选择算法"><a href="#基于扫描的选择算法" class="headerlink" title="基于扫描的选择算法"></a>基于扫描的选择算法</h5><p><img src="/2022/04/19/DBMS/image-20220517232244556.png" alt="image-20220517232244556" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517232257592.png" alt="image-20220517232257592" style="zoom:50%;"></p>
<h5 id="基于哈希的选择算法"><a href="#基于哈希的选择算法" class="headerlink" title="基于哈希的选择算法"></a>基于哈希的选择算法</h5><p>前提<img src="/2022/04/19/DBMS/image-20220517232530302.png" alt="image-20220517232530302" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517232543905.png" alt="image-20220517232543905" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517232551718.png" alt="image-20220517232551718" style="zoom:50%;"></p>
<h5 id="基于索引的选择算法"><a href="#基于索引的选择算法" class="headerlink" title="基于索引的选择算法"></a>基于索引的选择算法</h5><p>前提<img src="/2022/04/19/DBMS/image-20220517232646680.png" alt="image-20220517232646680" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517232703167.png" alt="image-20220517232703167" style="zoom:50%;"></p>
<h4 id="投影操作-1"><a href="#投影操作-1" class="headerlink" title="投影操作"></a>投影操作</h4><p><img src="/2022/04/19/DBMS/image-20220517233036625.png" alt="image-20220517233036625" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220517233052558.png" alt="image-20220517233052558" style="zoom:50%;"></p>
<h4 id="去重操作"><a href="#去重操作" class="headerlink" title="去重操作"></a>去重操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.一趟去重算法</span><br><span class="line">2.基于排序的去重算法</span><br><span class="line">3.基于哈希的去重算法</span><br></pre></td></tr></table></figure>
<h5 id="一趟去重算法"><a href="#一趟去重算法" class="headerlink" title="一趟去重算法"></a>一趟去重算法</h5><p><img src="/2022/04/19/DBMS/image-20220518000726368.png" alt="image-20220518000726368" style="zoom:50%;"></p>
<p>可在内存中用哈希表记录见过的元组，哈希键为整个元组。</p>
<p><img src="/2022/04/19/DBMS/image-20220518000816527.png" alt="image-20220518000816527" style="zoom:50%;"></p>
<h5 id="基于排序的去重算法"><a href="#基于排序的去重算法" class="headerlink" title="基于排序的去重算法"></a>基于排序的去重算法</h5><p><img src="/2022/04/19/DBMS/image-20220518000924102.png" alt="image-20220518000924102" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518000947953.png" alt="image-20220518000947953" style="zoom:50%;"></p>
<h5 id="基于哈希的去重算法"><a href="#基于哈希的去重算法" class="headerlink" title="基于哈希的去重算法"></a>基于哈希的去重算法</h5><p><img src="/2022/04/19/DBMS/image-20220518001143515.png" alt="image-20220518001143515" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518001212003.png" alt="image-20220518001212003" style="zoom:50%;"></p>
<h4 id="聚集操作的执行"><a href="#聚集操作的执行" class="headerlink" title="聚集操作的执行"></a>聚集操作的执行</h4><p>与去重一样</p>
<p><img src="/2022/04/19/DBMS/image-20220518001258445.png" alt="image-20220518001258445" style="zoom:50%;"></p>
<h4 id="集合差操作的执行"><a href="#集合差操作的执行" class="headerlink" title="集合差操作的执行"></a>集合差操作的执行</h4><p><img src="/2022/04/19/DBMS/image-20220518001319436.png" alt="image-20220518001319436" style="zoom:50%;"></p>
<h5 id="一趟集合差算法"><a href="#一趟集合差算法" class="headerlink" title="一趟集合差算法"></a>一趟集合差算法</h5><p><img src="/2022/04/19/DBMS/image-20220518001713665.png" alt="image-20220518001713665" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518001802445.png" alt="image-20220518001802445" style="zoom:50%;"></p>
<h5 id="基于哈希的集合差算法"><a href="#基于哈希的集合差算法" class="headerlink" title="基于哈希的集合差算法"></a>基于哈希的集合差算法</h5><p><img src="/2022/04/19/DBMS/image-20220518001829640.png" alt="image-20220518001829640" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518001850144.png" alt="image-20220518001850144" style="zoom:50%;"></p>
<h5 id="基于排序的集合差算法"><a href="#基于排序的集合差算法" class="headerlink" title="基于排序的集合差算法"></a>基于排序的集合差算法</h5><p><img src="/2022/04/19/DBMS/image-20220518001912214.png" alt="image-20220518001912214" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518001939501.png" alt="image-20220518001939501" style="zoom:50%;"></p>
<h4 id="连接操作的执行"><a href="#连接操作的执行" class="headerlink" title="连接操作的执行"></a>连接操作的执行</h4><p><img src="/2022/04/19/DBMS/image-20220518002200543.png" alt="image-20220518002200543" style="zoom:50%;"></p>
<h5 id="一趟连接算法"><a href="#一趟连接算法" class="headerlink" title="一趟连接算法"></a>一趟连接算法</h5><p><img src="/2022/04/19/DBMS/image-20220518002350004.png" alt="image-20220518002350004" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518002448925.png" alt="image-20220518002448925" style="zoom:50%;"></p>
<h5 id="基于元组的嵌套循环连接"><a href="#基于元组的嵌套循环连接" class="headerlink" title="基于元组的嵌套循环连接"></a>基于元组的嵌套循环连接</h5><p><img src="/2022/04/19/DBMS/image-20220518002515100.png" alt="image-20220518002515100" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518002602850.png" alt="image-20220518002602850" style="zoom:50%;"></p>
<p><strong>基于块的嵌套循环连接</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220518002627601.png" alt="image-20220518002627601" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518002659923.png" alt="image-20220518002659923" style="zoom:50%;"></p>
<h5 id="排序归并连接"><a href="#排序归并连接" class="headerlink" title="排序归并连接"></a>排序归并连接</h5><p><img src="/2022/04/19/DBMS/image-20220518002717370.png" alt="image-20220518002717370" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518002834171.png" alt="image-20220518002834171" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518002855040.png" alt="image-20220518002855040" style="zoom:50%;"></p>
<h5 id="经典哈希连接"><a href="#经典哈希连接" class="headerlink" title="经典哈希连接"></a>经典哈希连接</h5><p><img src="/2022/04/19/DBMS/image-20220518002921364.png" alt="image-20220518002921364" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518002938211.png" alt="image-20220518002938211" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518002946745.png" alt="image-20220518002946745" style="zoom:50%;"></p>
<h5 id="索引连接"><a href="#索引连接" class="headerlink" title="索引连接"></a>索引连接</h5><p><img src="/2022/04/19/DBMS/image-20220518002958713.png" alt="image-20220518002958713" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518003033410.png" alt="image-20220518003033410" style="zoom:50%;"></p>
<h3 id="查询计划的执行方法"><a href="#查询计划的执行方法" class="headerlink" title="查询计划的执行方法"></a>查询计划的执行方法</h3><p><img src="/2022/04/19/DBMS/image-20220518003117091.png" alt="image-20220518003117091" style="zoom:50%;"></p>
<h4 id="物化执行"><a href="#物化执行" class="headerlink" title="物化执行"></a>物化执行</h4><p><img src="/2022/04/19/DBMS/image-20220518003143221.png" alt="image-20220518003143221" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518003152780.png" alt="image-20220518003152780" style="zoom:50%;"></p>
<h4 id="流水线执行"><a href="#流水线执行" class="headerlink" title="流水线执行"></a>流水线执行</h4><p><img src="/2022/04/19/DBMS/image-20220518003224150.png" alt="image-20220518003224150" style="zoom:50%;"></p>
<p>迭代器模型</p>
<p><img src="/2022/04/19/DBMS/image-20220518003921085.png" alt="image-20220518003921085" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518003946545.png" alt="image-20220518003946545" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518004014141.png" alt="image-20220518004014141" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220518004026684.png" alt="image-20220518004026684" style="zoom:50%;"></p>
<h2 id="十、查询优化"><a href="#十、查询优化" class="headerlink" title="十、查询优化"></a>十、查询优化</h2><h3 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h3><p><strong>查询优化</strong>：将一个关系代数表达式转换成一个可以快速执行的查询执行计划的过程。</p>
<p>查询优化的两个阶段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">逻辑查询优化；</span><br><span class="line">物理查询优化；</span><br></pre></td></tr></table></figure>
<p>逻辑查询计划：关系代数表达式</p>
<p>物理查询计划：带有“如何执行”注释的关系代数表达式</p>
<h3 id="逻辑查询计划"><a href="#逻辑查询计划" class="headerlink" title="逻辑查询计划"></a>逻辑查询计划</h3><p>代价<img src="/2022/04/19/DBMS/image-20220519183907961.png" alt="image-20220519183907961" style="zoom:50%;"></p>
<p>基于代价的查询优化</p>
<p><img src="/2022/04/19/DBMS/image-20220519184002601.png" alt="image-20220519184002601" style="zoom:50%;"></p>
<h4 id="查询计划枚举"><a href="#查询计划枚举" class="headerlink" title="查询计划枚举"></a>查询计划枚举</h4><p><img src="/2022/04/19/DBMS/image-20220519184108647.png" alt="image-20220519184108647" style="zoom:50%;"></p>
<h5 id="等价关系代数表达式"><a href="#等价关系代数表达式" class="headerlink" title="等价关系代数表达式"></a>等价关系代数表达式</h5><p>若两个关系代数式在任意数据库实例上的结果都相同，则这两个关系代数表达式等价。</p>
<p><strong>关系代数表达式的等价变换规则</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220519184243787.png" alt="image-20220519184243787" style="zoom:50%;"></p>
<p>$\theta$连接满足交换律，但不满足结合律。</p>
<p><img src="/2022/04/19/DBMS/image-20220519185127015.png" alt="image-20220519185127015" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519185213924.png" alt="image-20220519185213924" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519185228111.png" alt="image-20220519185228111" style="zoom:50%;"></p>
<h5 id="选择下推"><a href="#选择下推" class="headerlink" title="选择下推"></a>选择下推</h5><p><img src="/2022/04/19/DBMS/image-20220519185536712.png" alt="image-20220519185536712" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519185545426.png" alt="image-20220519185545426" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519185557599.png" alt="image-20220519185557599" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519185715855.png" alt="image-20220519185715855" style="zoom:50%;"></p>
<h5 id="有关投影的等价变换规则"><a href="#有关投影的等价变换规则" class="headerlink" title="有关投影的等价变换规则"></a>有关投影的等价变换规则</h5><p><img src="/2022/04/19/DBMS/image-20220519185920703.png" alt="image-20220519185920703" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519185930743.png" alt="image-20220519185930743" style="zoom:50%;"></p>
<h5 id="投影下推"><a href="#投影下推" class="headerlink" title="投影下推"></a>投影下推</h5><p><img src="/2022/04/19/DBMS/image-20220519190034491.png" alt="image-20220519190034491" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519190144113.png" alt="image-20220519190144113" style="zoom:50%;"></p>
<h4 id="逻辑查询计划的代价模型"><a href="#逻辑查询计划的代价模型" class="headerlink" title="逻辑查询计划的代价模型"></a>逻辑查询计划的代价模型</h4><p><img src="/2022/04/19/DBMS/image-20220519190427400.png" alt="image-20220519190427400" style="zoom:50%;"></p>
<p>逻辑查询计划的代价模型 VS 物理查询计划的代价模型</p>
<p><img src="/2022/04/19/DBMS/image-20220519190615185.png" alt="image-20220519190615185" style="zoom:50%;"></p>
<p><strong>基数估计</strong></p>
<p>基数估计：估计查询结果的元组数</p>
<p>要求：准确；易计算；逻辑一致</p>
<p>逻辑一致性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单调性：一个操作的输入越大，操作结果的基数估计值越大</span><br><span class="line">顺序无关性：最终结果与操作的执行顺序无关</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/19/DBMS/image-20220519191017939.png" alt="image-20220519191017939" style="zoom:50%;"></p>
<p>笛卡尔积操作的基数估计</p>
<script type="math/tex; mode=display">
T(R\chi S)=T(R)T(S)</script><p>投影操作数的基数估计</p>
<p><img src="/2022/04/19/DBMS/image-20220519191306473.png" alt="image-20220519191306473" style="zoom:50%;"></p>
<p>选择操作的基数估计</p>
<p><img src="/2022/04/19/DBMS/image-20220519191449704.png" alt="image-20220519191449704" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519191601407.png" alt="image-20220519191601407" style="zoom:50%;"></p>
<p>二路自然连接的基数估计</p>
<p><img src="/2022/04/19/DBMS/image-20220519192052101.png" alt="image-20220519192052101" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519192200710.png" alt="image-20220519192200710" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519192215171.png" alt="image-20220519192215171" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519192235596.png" alt="image-20220519192235596" style="zoom:50%;"></p>
<p>集合操作的基数估计</p>
<p><img src="/2022/04/19/DBMS/image-20220519192916500.png" alt="image-20220519192916500" style="zoom:50%;"></p>
<p>去重操作的基数估计</p>
<p><img src="/2022/04/19/DBMS/image-20220519193626982.png" alt="image-20220519193626982" style="zoom:50%;"></p>
<h4 id="属性值分布的精确近似"><a href="#属性值分布的精确近似" class="headerlink" title="属性值分布的精确近似"></a>属性值分布的精确近似</h4><p>实际数据经常不满足均匀分布假设，导致基数估计的误差较大</p>
<p>直方图</p>
<p><img src="/2022/04/19/DBMS/image-20220519194206594.png" alt="image-20220519194206594" style="zoom:50%;"></p>
<p><strong>等宽直方图</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220519194229968.png" alt="image-20220519194229968" style="zoom:50%;"></p>
<p><strong>等高直方图</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220519194607250.png" alt="image-20220519194607250" style="zoom:50%;"></p>
<p><strong>压缩直方图</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220519194634006.png" alt="image-20220519194634006" style="zoom:50%;"></p>
<h4 id="连接顺序优化"><a href="#连接顺序优化" class="headerlink" title="连接顺序优化"></a>连接顺序优化</h4><p><strong>连接关系的角色</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220519194857979.png" alt="image-20220519194857979" style="zoom:50%;"></p>
<p><strong>连接树</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220519195058941.png" alt="image-20220519195058941" style="zoom:50%;"></p>
<p>左深连接树</p>
<p><img src="/2022/04/19/DBMS/image-20220519195259430.png" alt="image-20220519195259430" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519195313193.png" alt="image-20220519195313193" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519195321923.png" alt="image-20220519195321923" style="zoom:50%;"></p>
<h3 id="物理查询优化"><a href="#物理查询优化" class="headerlink" title="物理查询优化"></a>物理查询优化</h3><p><img src="/2022/04/19/DBMS/image-20220519202315805.png" alt="image-20220519202315805" style="zoom:50%;"></p>
<h4 id="确定选择操作的物理执行算法"><a href="#确定选择操作的物理执行算法" class="headerlink" title="确定选择操作的物理执行算法"></a>确定选择操作的物理执行算法</h4><p><img src="/2022/04/19/DBMS/image-20220519202349918.png" alt="image-20220519202349918" style="zoom:50%;"></p>
<p><strong>索引扫描+过滤</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220519205009643.png" alt="image-20220519205009643" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519205127235.png" alt="image-20220519205127235" style="zoom:50%;"></p>
<p><strong>多索引扫描+求交集</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220519205217297.png" alt="image-20220519205217297" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519205439888.png" alt="image-20220519205439888" style="zoom:50%;"></p>
<p><strong>仅用索引</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220519205531523.png" alt="image-20220519205531523" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519205539303.png" alt="image-20220519205539303" style="zoom:50%;"></p>
<p><strong>顺序扫描</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220519205556825.png" alt="image-20220519205556825" style="zoom:50%;"></p>
<h4 id="确定连接操作的物理执行算法"><a href="#确定连接操作的物理执行算法" class="headerlink" title="确定连接操作的物理执行算法"></a>确定连接操作的物理执行算法</h4><p><img src="/2022/04/19/DBMS/image-20220519205743686.png" alt="image-20220519205743686" style="zoom:50%;"></p>
<p>一趟连接：适用于左关系可以全部读入缓冲池的可用页面。</p>
<p>索引连接：适用于左关系较小，右关系在连接属性上建有索引</p>
<p>排序归并连接：<img src="/2022/04/19/DBMS/image-20220519210506654.png" alt="image-20220519210506654" style="zoom:50%;"></p>
<p>哈希连接：<img src="/2022/04/19/DBMS/image-20220519210520826.png" alt="image-20220519210520826" style="zoom:50%;"></p>
<p>嵌套循环连接：<img src="/2022/04/19/DBMS/image-20220519210536440.png" alt="image-20220519210536440" style="zoom:50%;"></p>
<h3 id="查询计划的执行模型"><a href="#查询计划的执行模型" class="headerlink" title="查询计划的执行模型"></a>查询计划的执行模型</h3><h2 id="十一、并发控制"><a href="#十一、并发控制" class="headerlink" title="十一、并发控制"></a>十一、并发控制</h2><h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><p><img src="/2022/04/19/DBMS/image-20220519212340392.png" alt="image-20220519212340392" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519212507673.png" alt="image-20220519212507673" style="zoom:50%;"></p>
<p><strong>事务的ACID性质</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220519212554791.png" alt="image-20220519212554791" style="zoom:50%;"></p>
<p>持久性<img src="/2022/04/19/DBMS/image-20220519212707574.png" alt="image-20220519212707574" style="zoom:50%;"></p>
<p>一致性<img src="/2022/04/19/DBMS/image-20220519212814773.png" alt="image-20220519212814773" style="zoom:50%;"></p>
<p>隔离性<img src="/2022/04/19/DBMS/image-20220519213222386.png" alt="image-20220519213222386" style="zoom:50%;"></p>
<h3 id="并发控制-1"><a href="#并发控制-1" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p><strong>调度</strong>：调度是一个或多个事务的重要操作的序列。</p>
<p><strong>串行调度</strong>：如果一个调度中不同事务的操作没有交叉，则该调度是串行调度</p>
<p>调度的正确性：单独执行每个事务都会将数据库从一种一致状态变为另一种一致状态</p>
<p>串行调度的正确性：任意串行调度都能保持数据库的一致性；不同的串行调度可能导致数据库处于不同的状态，但都是一致状态</p>
<p><strong>异常</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220519215904279.png" alt="image-20220519215904279" style="zoom:50%;"></p>
<p>脏写<img src="/2022/04/19/DBMS/image-20220519220347168.png" alt="image-20220519220347168" style="zoom:50%;"></p>
<p>脏读<img src="/2022/04/19/DBMS/image-20220519220448009.png" alt="image-20220519220448009" style="zoom:50%;"></p>
<p>不可重复读<img src="/2022/04/19/DBMS/image-20220519220547543.png" alt="image-20220519220547543" style="zoom:50%;"></p>
<p>等价调度</p>
<p><img src="/2022/04/19/DBMS/image-20220519220707492.png" alt="image-20220519220707492" style="zoom:50%;"></p>
<p>可串行化调度</p>
<p><img src="/2022/04/19/DBMS/image-20220519221456198.png" alt="image-20220519221456198" style="zoom:50%;"></p>
<p>可串行化调度的优点</p>
<p><img src="/2022/04/19/DBMS/image-20220519221529843.png" alt="image-20220519221529843" style="zoom:50%;"></p>
<p>可串行化调度的缺点</p>
<p><img src="/2022/04/19/DBMS/image-20220519221843259.png" alt="image-20220519221843259" style="zoom:50%;"></p>
<h4 id="并发控制隔离级别"><a href="#并发控制隔离级别" class="headerlink" title="并发控制隔离级别"></a>并发控制隔离级别</h4><p><img src="/2022/04/19/DBMS/image-20220519222317093.png" alt="image-20220519222317093" style="zoom:50%;"></p>
<p>在不同隔离级别下，一个事务修改过的对象的值对其他并发事务的可见程度不同</p>
<p><strong>读未提交</strong></p>
<p>未提交事务所做的修改对其他事务可见。</p>
<p>此级别下的异常</p>
<p><img src="/2022/04/19/DBMS/image-20220519222909526.png" alt="image-20220519222909526" style="zoom:50%;"></p>
<p><strong>读提交</strong></p>
<p>只有已提交的事务所做的修改才对其他事物可见。</p>
<p>此级别下的异常</p>
<p><img src="/2022/04/19/DBMS/image-20220519223035088.png" alt="image-20220519223035088" style="zoom:50%;"></p>
<p><strong>可重复读</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220519223105963.png" alt="image-20220519223105963" style="zoom:50%;"></p>
<p>此级别下的异常</p>
<p><img src="/2022/04/19/DBMS/image-20220519223154576.png" alt="image-20220519223154576" style="zoom:50%;"></p>
<p><strong>可串行化</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220519223217827.png" alt="image-20220519223217827" style="zoom:50%;"></p>
<h4 id="并发控制可串行化"><a href="#并发控制可串行化" class="headerlink" title="并发控制可串行化"></a>并发控制可串行化</h4><p>冲突可串行化</p>
<p><img src="/2022/04/19/DBMS/image-20220519224200957.png" alt="image-20220519224200957" style="zoom:50%;"></p>
<p>冲突</p>
<p><img src="/2022/04/19/DBMS/image-20220519224214607.png" alt="image-20220519224214607" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519224702770.png" alt="image-20220519224702770" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519224714126.png" alt="image-20220519224714126" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519224722572.png" alt="image-20220519224722572" style="zoom:50%;"></p>
<p>冲突等价</p>
<p><img src="/2022/04/19/DBMS/image-20220519224820353.png" alt="image-20220519224820353" style="zoom:50%;"></p>
<p>冲突可串行化调度</p>
<p><img src="/2022/04/19/DBMS/image-20220519230707353.png" alt="image-20220519230707353" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519231007196.png" alt="image-20220519231007196" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220519231147648.png" alt="image-20220519231147648" style="zoom:50%;"></p>
<p>冲突可串行化测试</p>
<p><img src="/2022/04/19/DBMS/image-20220520091113545.png" alt="image-20220520091113545" style="zoom:50%;"></p>
<p>视图可串行化比冲突可串行化松</p>
<h4 id="并发控制协议"><a href="#并发控制协议" class="headerlink" title="并发控制协议"></a>并发控制协议</h4><p><img src="/2022/04/19/DBMS/image-20220520091257930.png" alt="image-20220520091257930" style="zoom:50%;"></p>
<p>并发控制协议分类</p>
<p><img src="/2022/04/19/DBMS/image-20220520091349724.png" alt="image-20220520091349724" style="zoom:50%;"></p>
<p><strong>基于锁的并发控制</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220520091554618.png" alt="image-20220520091554618" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520091633199.png" alt="image-20220520091633199" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520092008232.png" alt="image-20220520092008232" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520092526558.png" alt="image-20220520092526558" style="zoom:50%;"></p>
<p><strong>两阶段锁协议</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220520093042993.png" alt="image-20220520093042993" style="zoom:50%;"></p>
<p>基于2PL的调度是冲突可串行化调度</p>
<p>2PL的优缺点<img src="/2022/04/19/DBMS/image-20220520093240929.png" alt="image-20220520093240929" style="zoom:50%;"></p>
<p>级联终止<img src="/2022/04/19/DBMS/image-20220520093334450.png" alt="image-20220520093334450" style="zoom:50%;"></p>
<p>强两阶段锁SS2PL</p>
<p><img src="/2022/04/19/DBMS/image-20220520093452468.png" alt="image-20220520093452468" style="zoom:50%;"></p>
<p>严格调度</p>
<p><img src="/2022/04/19/DBMS/image-20220520093543437.png" alt="image-20220520093543437" style="zoom:50%;"></p>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p><strong>死锁</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220520094343334.png" alt="image-20220520094343334" style="zoom:50%;"></p>
<p>死锁处理<img src="/2022/04/19/DBMS/image-20220520094527771.png" alt="image-20220520094527771" style="zoom:50%;"></p>
<p>死锁检测</p>
<p><img src="/2022/04/19/DBMS/image-20220520094601102.png" alt="image-20220520094601102" style="zoom:50%;"></p>
<p>等待图</p>
<p><img src="/2022/04/19/DBMS/image-20220520094658374.png" alt="image-20220520094658374" style="zoom:50%;"></p>
<p>死锁解除</p>
<p><img src="/2022/04/19/DBMS/image-20220520094725361.png" alt="image-20220520094725361" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520094805814.png" alt="image-20220520094805814" style="zoom:50%;"></p>
<p>死锁预防</p>
<p><img src="/2022/04/19/DBMS/image-20220520094926324.png" alt="image-20220520094926324" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520095012899.png" alt="image-20220520095012899" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520095107351.png" alt="image-20220520095107351" style="zoom:50%;"></p>
<p>锁的效率问题</p>
<p><img src="/2022/04/19/DBMS/image-20220520095206317.png" alt="image-20220520095206317" style="zoom:50%;"></p>
<p>锁的粒度</p>
<p><img src="/2022/04/19/DBMS/image-20220520095531284.png" alt="image-20220520095531284" style="zoom: 50%;"></p>
<p>意向锁</p>
<p><img src="/2022/04/19/DBMS/image-20220520095555600.png" alt="image-20220520095555600" style="zoom:50%;"></p>
<p>相容矩阵</p>
<p><img src="/2022/04/19/DBMS/image-20220520095701510.png" alt="image-20220520095701510" style="zoom:50%;"></p>
<p>多粒度锁协议</p>
<p><img src="/2022/04/19/DBMS/image-20220520100018302.png" alt="image-20220520100018302" style="zoom:50%;"></p>
<p>锁升级</p>
<p><img src="/2022/04/19/DBMS/image-20220520100856436.png" alt="image-20220520100856436" style="zoom:50%;"></p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>动态数据库</p>
<p><img src="/2022/04/19/DBMS/image-20220520101217338.png" alt="image-20220520101217338" style="zoom:50%;"></p>
<p>幻读<img src="/2022/04/19/DBMS/image-20220520101317415.png" alt="image-20220520101317415" style="zoom:50%;"></p>
<p>谓词锁</p>
<p><img src="/2022/04/19/DBMS/image-20220520101448152.png" alt="image-20220520101448152" style="zoom:50%;"></p>
<p>next- key锁</p>
<p><img src="/2022/04/19/DBMS/image-20220520101509887.png" alt="image-20220520101509887" style="zoom:50%;"></p>
<h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p><img src="/2022/04/19/DBMS/image-20220520101553945.png" alt="image-20220520101553945" style="zoom:50%;"></p>
<p><strong>Basic TO</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220520101644060.png" alt="image-20220520101644060" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520101739969.png" alt="image-20220520101739969" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520101903477.png" alt="image-20220520101903477" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520102008025.png" alt="image-20220520102008025" style="zoom:50%;"></p>
<p>Thomas写规则</p>
<p><img src="/2022/04/19/DBMS/image-20220520102358567.png" alt="image-20220520102358567" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520102654252.png" alt="image-20220520102654252" style="zoom:50%;"></p>
<p>不可恢复调度</p>
<p><img src="/2022/04/19/DBMS/image-20220520102743606.png" alt="image-20220520102743606" style="zoom:50%;"></p>
<p>Basic不足</p>
<p><img src="/2022/04/19/DBMS/image-20220520102950657.png" alt="image-20220520102950657" style="zoom:50%;"></p>
<p><strong>OCC</strong>(不重要)</p>
<p><img src="/2022/04/19/DBMS/image-20220520103139742.png" alt="image-20220520103139742" style="zoom:50%;"></p>
<p><strong>MVCC</strong>多版本并发控制</p>
<p><img src="/2022/04/19/DBMS/image-20220520103408606.png" alt="image-20220520103408606" style="zoom:50%;"></p>
<p>只有写和写冲突。</p>
<h2 id="十二、故障恢复"><a href="#十二、故障恢复" class="headerlink" title="十二、故障恢复"></a>十二、故障恢复</h2><h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><p><img src="/2022/04/19/DBMS/image-20220520120415337.png" alt="image-20220520120415337" style="zoom:50%;"></p>
<p>故障类型<img src="/2022/04/19/DBMS/image-20220520120612468.png" alt="image-20220520120612468" style="zoom:50%;"></p>
<p>事务故障</p>
<p><img src="/2022/04/19/DBMS/image-20220520120624784.png" alt="image-20220520120624784" style="zoom:50%;"></p>
<p>系统故障</p>
<p><img src="/2022/04/19/DBMS/image-20220520120733427.png" alt="image-20220520120733427" style="zoom:50%;"></p>
<p>存储介质故障</p>
<p><img src="/2022/04/19/DBMS/image-20220520120848519.png" alt="image-20220520120848519" style="zoom:50%;"></p>
<h3 id="缓冲池策略"><a href="#缓冲池策略" class="headerlink" title="缓冲池策略"></a>缓冲池策略</h3><p><img src="/2022/04/19/DBMS/image-20220520121202370.png" alt="image-20220520121202370" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520122101774.png" alt="image-20220520122101774" style="zoom:50%;"></p>
<p>steal/no-steal 策略</p>
<p><img src="/2022/04/19/DBMS/image-20220520122333980.png" alt="image-20220520122333980" style="zoom:50%;"></p>
<p>force/no-force 策略</p>
<p><img src="/2022/04/19/DBMS/image-20220520122359902.png" alt="image-20220520122359902" style="zoom:50%;"></p>
<p>no-force是不强制在提交前写回磁盘</p>
<p>no-steal是不允许在事务提交前写回磁盘</p>
<p>缓冲池策略</p>
<p><img src="/2022/04/19/DBMS/image-20220520122444003.png" alt="image-20220520122444003" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520122920391.png" alt="image-20220520122920391" style="zoom:50%;"></p>
<h3 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h3><p>预写式日志(write-ahead log)WAL</p>
<p><img src="/2022/04/19/DBMS/image-20220520123122163.png" alt="image-20220520123122163" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520123227057.png" alt="image-20220520123227057" style="zoom:50%;"></p>
<p>只有当日志写到磁盘上，才能代表事务提交。</p>
<p>基于WAL的故障恢复</p>
<p><img src="/2022/04/19/DBMS/image-20220520123548000.png" alt="image-20220520123548000" style="zoom:50%;"></p>
<p>事务的分类</p>
<p><img src="/2022/04/19/DBMS/image-20220520123612422.png" alt="image-20220520123612422" style="zoom:50%;"></p>
<p>故障恢复时的行为</p>
<p><img src="/2022/04/19/DBMS/image-20220520123644356.png" alt="image-20220520123644356" style="zoom:50%;"></p>
<p>WAL协议分类</p>
<p><img src="/2022/04/19/DBMS/image-20220520123737682.png" alt="image-20220520123737682" style="zoom:50%;"></p>
<h4 id="Undo-Logging"><a href="#Undo-Logging" class="headerlink" title="Undo Logging"></a>Undo Logging</h4><p><img src="/2022/04/19/DBMS/image-20220520124852811.png" alt="image-20220520124852811" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520123924132.png" alt="image-20220520123924132" style="zoom:50%;"></p>
<p>故障恢复<img src="/2022/04/19/DBMS/image-20220520124322486.png" alt="image-20220520124322486" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520124333092.png" alt="image-20220520124333092" style="zoom:50%;"></p>
<h4 id="Redo-Logging"><a href="#Redo-Logging" class="headerlink" title="Redo Logging"></a>Redo Logging</h4><p><img src="/2022/04/19/DBMS/image-20220520124907272.png" alt="image-20220520124907272" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520124925559.png" alt="image-20220520124925559" style="zoom:50%;"></p>
<p>故障恢复<img src="/2022/04/19/DBMS/image-20220520125117852.png" alt="image-20220520125117852" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520125328930.png" alt="image-20220520125328930" style="zoom:50%;"></p>
<h4 id="Redo-Undo-Logging"><a href="#Redo-Undo-Logging" class="headerlink" title="Redo+Undo Logging"></a>Redo+Undo Logging</h4><p><img src="/2022/04/19/DBMS/image-20220520125503308.png" alt="image-20220520125503308" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520125645629.png" alt="image-20220520125645629" style="zoom:50%;"></p>
<p>故障恢复<img src="/2022/04/19/DBMS/image-20220520125840485.png" alt="image-20220520125840485" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520125856446.png" alt="image-20220520125856446" style="zoom:50%;"></p>
<p>策略比较<img src="/2022/04/19/DBMS/image-20220520130139202.png" alt="image-20220520130139202" style="zoom:50%;"></p>
<h4 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h4><p><img src="/2022/04/19/DBMS/image-20220520130353055.png" alt="image-20220520130353055" style="zoom:50%;"></p>
<h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><p>WAL的问题<img src="/2022/04/19/DBMS/image-20220520130526774.png" alt="image-20220520130526774" style="zoom:50%;"></p>
<p><strong>检查点</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220520130820555.png" alt="image-20220520130820555" style="zoom:50%;"></p>
<p><strong>模糊检查点</strong></p>
<p><img src="/2022/04/19/DBMS/image-20220520130844271.png" alt="image-20220520130844271" style="zoom:50%;"></p>
<p>涉及检查点的故障恢复</p>
<p><img src="/2022/04/19/DBMS/image-20220520131212794.png" alt="image-20220520131212794" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520131244758.png" alt="image-20220520131244758" style="zoom:50%;"></p>
<p><img src="/2022/04/19/DBMS/image-20220520131254766.png" alt="image-20220520131254766" style="zoom:50%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/18/%E7%A2%B3%E6%8E%92%E6%94%BE%E9%87%8F%E7%BB%9F%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/%E7%A2%B3%E6%8E%92%E6%94%BE%E9%87%8F%E7%BB%9F%E8%AE%A1/" class="post-title-link" itemprop="url">碳排放量统计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-18 19:34:28 / Modified: 21:10:56" itemprop="dateCreated datePublished" datetime="2022-04-18T19:34:28+08:00">2022-04-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="碳排放量数据统计"><a href="#碳排放量数据统计" class="headerlink" title="碳排放量数据统计"></a>碳排放量数据统计</h1><p>14-19年可通过CEAD获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.ceads.net.cn/news/20211256.html</span><br></pre></td></tr></table></figure>
<p>1990-2015年的数据，可以通过MEIC获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://meicmodel.org/?page_id=560</span><br></pre></td></tr></table></figure>
<p>注：MEIC可以获取碳排放量统计图片</p>
<p>对于之后的数据获取方法：</p>
<p>法一：</p>
<p>通过</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.wheata.cn/">WheatA小麦芽 - 农业气象大数据</a></p>
<p>例如想知道杭州城区历年的二氧化碳排放量有多少，如图所示。</p>
<p><img src="/2022/04/18/%E7%A2%B3%E6%8E%92%E6%94%BE%E9%87%8F%E7%BB%9F%E8%AE%A1/image-20220418201114279.png" alt="image-20220418201114279"></p>
<p>图1显示的是一个全球大气污染排放数据调用界面，我们把坐标定位到杭州城区东站附近（坐标：120.15°E，30.35°N），获取该地2020年逐月的CO2排放量数据，如图所示。</p>
<p><img src="/2022/04/18/%E7%A2%B3%E6%8E%92%E6%94%BE%E9%87%8F%E7%BB%9F%E8%AE%A1/image-20220418201138181.png" alt="image-20220418201138181"></p>
<p>图2显示了<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=杭州市&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A2098680812}">杭州市</a>中心地段2020年逐月的CO2排放量，可以看到2020年1月该地区CO2总排放量为3.9kg/m2，按杭州城区面积560平方公里算，可推测出2020年1月城区二氧化碳总排放量约为200万吨。</p>
<p>法二：</p>
<p>根据各省市统计年鉴计算。</p>
<p>如果用IPCC的算法的话，一般情况下用的都是能源平衡表，也就是用终端消费量来算各种能源的二氧化碳排放量。</p>
<p>挂一个可能有用的网站，碳排放交易网。</p>
<p>法三：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/samLi0620/article/details/123499971</span><br></pre></td></tr></table></figure>
<p>1997-2020年（其中2018-2020年为插值法估计）</p>
<p>(29.9元)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/14/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/14/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">任务管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-14 18:39:21" itemprop="dateCreated datePublished" datetime="2022-04-14T18:39:21+08:00">2022-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-15 16:46:32" itemprop="dateModified" datetime="2022-04-15T16:46:32+08:00">2022-04-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h1><h2 id="任务管理概述"><a href="#任务管理概述" class="headerlink" title="任务管理概述"></a>任务管理概述</h2><p>一个任务是一个处理器可以调度、执行和暂停的工作单位。它可以用来执行一个程序，一个任务或进程，一个操作系统服务工具，一个中断或异常处理程序，或一个内核或执行实用程序。</p>
<p>IA-32结构提供了一种机制，用于保存任务的状态，调度任务的执行，以及从一个任务切换到另一个任务。当在保护模式下运行时，所有的处理器执行都是在任务内进行的，即使是简单的系统也必须至少定义一个任务。更复杂的系统可以使用处理器的任务管理设施来支持多任务的应用。</p>
<p>一个过程调用包括将数据（以<strong>参数</strong>和<strong>返回值</strong>的形式）与控制从代码的一部分传递到另一部分。除此之外，在进入时为过程的局部变量分配空间，在退出的时候释放这些空间。数据传递、局部变量的分配和释放通过操纵程序栈来实现。</p>
<p>操作系统实现宏观上并行任务的效果，其本质是微观上在多个任务之间切换。因此，当操作系统由任务A切换到任务B时，需要暂停任务A的执行，并将处理器执行任务A时各个寄存器的值保存到内存的某个位置上，这个过程叫做保存现场；之后将处理器上一次执行任务B时各个寄存器的值由内存中的某个位置回复到处理的寄存器当中，这个过程叫做恢复现场。当操作系统在调度时由任务A切换到任务B时，对任务A保存现场，对任务B恢复现场，这个整体的过程称之为：上下文切换。</p>
<p>在每一个任务在执行之前，操作系统都需要为其分配一个专属的内存区域供其使用，这个内存区域通常被称为此任务的栈（stack）。Cortex-M有两个堆栈寄存器，主栈指针（MSP）与进程栈指针（PSP）。主程序操作系统和各个中断函数使用的是MSP指针，而各个被调度的任务（进程）使用的是PSP指针。本质上它是处理器的一个寄存器，PSP寄存器的值就是内存中任务的栈地址。</p>
<h3 id="任务的结构"><a href="#任务的结构" class="headerlink" title="任务的结构"></a>任务的结构</h3><p>一个任务由两部分组成：一个任务执行空间和一个任务状态段（TSS）。任务执行空间由一个代码段、一个堆栈段和一个或多个数据段组成（见图7-1）。如果操作系统或执行程序使用处理器的特权级别保护机制，任务执行空间也会为每个特权提供一个单独的堆栈。<br>TSS指定了组成任务执行空间的段，并为任务状态信息提供了一个存储位置信息。在多任务系统中，TSS还提供了一种连接任务的机制。<br>一个任务由其TSS的段选择器来识别。当一个任务被加载到处理器中执行时，它的段选择器、基地址、限制和段描述符属性被加载到任务的寄存器。如果任务实现了分页，任务所使用的页面目录的基地址被加载到控制寄存器CR3。</p>
<p><img src="/2022/04/14/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/image-20220414193049801.png" alt="image-20220414193049801"></p>
<h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><p>以下项目定义了当前执行的任务的状态：</p>
<ul>
<li>任务的当前执行空间，由段寄存器（CS、DS、SS、ES、GS、FS和GS）中的段选择器定义。</li>
<li>通用寄存器的状态。</li>
<li>EFLAGS寄存器的状态。</li>
<li>EIP寄存器的状态。</li>
<li>控制寄存器CR3的状态。</li>
<li>任务寄存器的状态。</li>
<li>LDTR寄存器的状态。</li>
<li>I/O地图的基址和I/O地图（包含在TSS中）。</li>
<li>特权0、1和2堆栈的堆栈指针（包含在TSS中）。</li>
<li>与先前执行的任务的链接（包含在TSS中）。<br>在调度任务之前，所有这些项目都包含在任务的TSS中，除了任务寄存器的状态。另外，LDTR寄存器的全部内容不包含在TSS中，只有LDT的段选择器。</li>
</ul>
<h3 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h3><p>软件或处理器可以通过以下方式之一调度一个任务的执行。</p>
<ul>
<li>用CALL指令明确调用一个任务。</li>
<li>用JMP指令显式跳转到一个任务。</li>
<li>隐式调用（由处理器）到一个中断处理任务。</li>
<li>对一个异常处理任务的隐式调用。</li>
<li>当EFLAGS寄存器中的NT标志被设置时，返回（用IRET指令启动）。</li>
</ul>
<p>所有这些调度任务的方法都是用一个段选择器来识别要调度的任务，这个段选择器指向任务门或任务的TSS。当用CALL或JMP指令调度任务时，指令中的选择器可以直接选择TSS或持有TSS的选择器的任务门。当调度一个任务来处理一个中断或异常时，中断或异常的IDT条目必须包含一个任务门，它持有中断或异常处理程序TSS的选择器。<br>当一个任务被调度执行时，在当前运行的任务和被调度的任务之间会发生一个任务切换。在任务切换期间，当前执行的任务的执行环境（称为任务的状态或上下文）被保存在其TSS中，任务的执行被暂停。被派遣任务的上下文被加载到处理器中，该任务的执行从新加载的EIP寄存器所指向的指令开始。如果任务在系统上次初始化后没有运行过，EIP将指向任务代码的第一条指令；否则，它将指向任务最后执行的指令之后的下一条指令。<br>如果当前执行的任务（调用任务）调用了被派发的任务（被调用任务），则段选择器被存储在被调用任务的TSS中，以提供与调用任务的链接。<br>对于所有IA-32处理器，任务不是递归的。一个任务不能调用或跳转到自身。中断和异常可以通过任务切换到一个处理任务来处理。在这里，处理器执行一个任务来处理中断或异常，从中断处理任务或异常处理任务返回后，自动切换回被中断的任务。这种机制也可以处理在中断任务中发生的中断。<br>作为任务切换的一部分，处理器也可以切换到另一个LDT，允许每个任务对基于LDT的段有不同的逻辑到物理地址的映射。在任务切换时，页面目录基础寄存器（CR3）也被重新加载，允许每个任务有它自己的一套页表。这些保护设施有助于隔离任务并防止它们相互干扰。<br>如果不使用保护机制，处理器不提供任务之间的保护。这一点即使在操作系统也是如此，该系统使用多个特权级别进行保护。一个运行在特权级别3的任务，使用与其他任务相同的LDT和页表。</p>
<h2 id="任务的数据结构"><a href="#任务的数据结构" class="headerlink" title="任务的数据结构"></a>任务的数据结构</h2><p>处理器定义了五个数据结构来处理与任务有关的活动。</p>
<ul>
<li>任务状态段（TSS）。</li>
<li>任务门描述符。</li>
<li>TSS描述符。</li>
<li>任务寄存器。</li>
<li>EFLAGS寄存器中的NT标志。</li>
</ul>
<p>当在保护模式下运行时，必须为至少一个任务创建一个TSS和TSS描述符，并且TSS的段选择器必须被加载到任务寄存器中（使用LTR指令）。</p>
<h3 id="任务状态段-Task-State-Segment-TSS"><a href="#任务状态段-Task-State-Segment-TSS" class="headerlink" title="任务状态段 Task-State Segment (TSS)"></a>任务状态段 Task-State Segment (TSS)</h3><p>恢复一个任务所需的处理器状态信息被保存在一个叫做任务状态段（TSS）的系统段中。图7-2显示了为32位CPU设计的任务的TSS的格式。TSS的字段被分为两个主要类别：动态字段和静态字段。<br><img src="/2022/04/14/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/image-20220414195850785.png" alt="image-20220414195850785"></p>
<p>在任务切换期间，当一个任务被暂停时，处理器会更新动态字段。以下是动态字段。</p>
<ul>
<li>通用寄存器字段 - EAX, ECX, EDX, EBX, ESP, EBP, ESI, 和 EDI 寄存器在任务切换前的状态。</li>
<li>分段选择器字段—在任务切换前存储在ES、CS、SS、DS、FS和GS寄存器中的分段选择器。</li>
<li>EFLAGS寄存器字段 - 任务切换前EFAGS寄存器的状态。</li>
<li>EIP（指令指针）字段 - 任务切换前EIP寄存器的状态。</li>
<li>前一个任务链接字段—包含前一个任务的TSS的段选择器（在由调用、中断或异常启动的任务切换中更新）。这个字段（有时被称为后端链接字段）允许通过使用IRET指令将任务切换到前一个任务。处理器读取静态字段，但通常不改变它们。这些字段是在一个任务被创建时设置的。<br>以下是静态字段。</li>
<li>LDT段选择器字段 - 包含任务的LDT的段选择器。</li>
<li>CR3控制寄存器字段 - 包含任务要使用的页面目录的基本物理地址。控制寄存器CR3也被称为页面目录基础寄存器（PDBR）。</li>
<li>权限级别-0、-1和-2的堆栈指针字段—这些堆栈指针包括一个逻辑地址，由堆栈段的段选择器（SS0、SS1和SS2）和堆栈的偏移量（ESP0, ESP1和ESP2）组成。注意，这些字段的值对于一个特定的任务来说是静态的；而SS和ESP的值会在任务中发生堆栈切换时改变。</li>
<li>T（调试陷阱）标志（字节100，位0）—当设置时，T标志会使处理器在任务切换到这个任务时引发一个调试异常。</li>
<li>I/O地图基址字段 - 包含从TSS的基点到I/O权限位的图和中断重定向位图的16位偏移。当存在时，这些地图以更高的地址存储在TSS中。</li>
<li>避免在处理器在任务切换时读取的TSS部分（前104字节）放置页面边界。如果边界出现在这个区域，处理器可能无法正确执行地址转换。在任务切换过程中，处理器在每个TSS的前104个字节中进行读写（使用连续的物理地址，从任务的物理地址开始）。所以，在TSS访问开始后，如果104字节中的一部分 不是物理上连续的，处理器将访问不正确的信息，而不会产生页面错误异常。</li>
<li>与前一个任务的TSS、当前任务的TSS相对应的页面，以及每个任务的描述符表项都应该被标记为读/写。</li>
</ul>
<p>如果包含这些结构的页面在任务切换开始前就已经存在于内存中，那么任务切换的速度会更快。</p>
<h3 id="TSS-描述符"><a href="#TSS-描述符" class="headerlink" title="TSS 描述符"></a>TSS 描述符</h3><p>TSS，像所有其他段一样，是由段描述符定义的。图7-3显示了TSS的格式 。TSS描述符只能放在GDT中，它们不能放在LDT或IDT中。<br>试图使用设置了TI标志（表示当前的LDT）的段选择器访问一个TSS，会导致在CALLs和JMPs期间会产生一个一般保护异常（#GP）；在IRETs期间会产生一个无效的TSS异常（#TS）。如果试图将一个TSS的段选择器加载到一个段寄存器中，也会产生一般保护异常。<br>类型字段中的繁忙标志（B）表示任务是否繁忙。一个繁忙的任务目前正在运行或暂停。类型字段的值为1001B表示一个不活动的任务；值为1011B表示一个繁忙的任务。<br>处理器使用繁忙标志来检测调用一个执行被中断的任务的尝试。为了确保只有一个繁忙标志与一个任务相关联，每个TSS应该只有一个TSS描述符指向它。</p>
<p><img src="/2022/04/14/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/image-20220414201925534.png" alt="image-20220414201925534"></p>
<p>基数、极限和DPL字段以及粒度和当前标志的功能与它们在数据段描述符中的使用类似。当32位TSS描述符中的G标志为0时，极限字段必须是32位TSS描述符中的极限。TSS描述符中G标志为0时，极限字段的值必须等于或大于67H，比TSS的最小尺寸少一个字节。<br>试图切换到一个TSS描述符的极限值小于67H的任务，会产生一个无效的TSS异常（#TS）。如果包括一个I/O权限位图或操作系统存储了额外的数据，则需要一个更大的限制。处理器不检查任务开关上是否有大于67H的限制；但是，当访问I/O权限位图或中断重定向位图时，它将进行检查。<br>任何可以访问TSS描述符的程序或过程（即其CPL在数字上等于或小于的DPL）可以通过调用或跳转来调度任务。<br>在大多数系统中，TSS描述符的DPL被设置为小于3的值，因此只有特权软件才能进行任务切换。然而，在多任务应用程序中，一些TSS描述符的DPLs可能被设置为3，以便允许在应用程序（或用户）权限级别进行任务切换。</p>
<h3 id="任务寄存器"><a href="#任务寄存器" class="headerlink" title="任务寄存器"></a>任务寄存器</h3><p>任务寄存器持有16位段选择器和整个段描述符（32位基本地址（在IA-32e模式下为64位 ），16位段限制和描述符属性），用于当前任务的TSS。<br>这个信息是从当前任务的GDT中的TSS描述符中复制过来的。图7-5显示了处理器访问TSS的路径 （使用任务寄存器中的信息）。任务寄存器有一个可见的部分（可以被软件读取和改变）和一个不可见的部分（由处理器维护，不能访问）。可见部分的段选择器指向GDT中的一个TSS描述符。处理器使用任务寄存器的不可见部分来缓存段描述符 。在寄存器中缓存这些值使得任务的执行更加有效。LTR（加载任务<br>寄存器）和STR（存储任务寄存器）指令加载和读取任务寄存器的可见部分。<br>LTR指令将段选择器（源操作数）加载到任务寄存器中，指向GDT中的TSS描述符。然后它用TSS描述符的信息加载任务寄存器的不可见部分。LTR是一个 特权指令，只有当CPL为0时才能执行。之后，当任务切换发生时，任务寄存器的内容会被隐含地改变。<br>STR(存储任务寄存器)指令将任务寄存器的可见部分存储在一个通用寄存器或内存中。这条指令可以被运行在任何权限级别的代码执行，以识别当前的运行的任务。然而，它通常只被操作系统软件使用。在处理器上电或复位时，段选择器和基地址被设置为默认值0；极限值<br>被设置为FFFH。</p>
<p><img src="/2022/04/14/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/image-20220414203302131.png" alt="image-20220414203302131"></p>
<h3 id="任务门描述符"><a href="#任务门描述符" class="headerlink" title="任务门描述符"></a>任务门描述符</h3><p>任务门描述符提供了对一个任务的间接的、受保护的引用（见图7-6）。它可以被放置在GDT、LDT或IDT中。任务门描述符中的TSS段选择器字段指向GDT中的一个TSS描述符。该段选择器中的RPL不被使用。任务门描述符的DPL在任务切换期间控制对TSS描述符的访问。当一个程序或过程通过任务门调用或跳转到一个任务时，指向任务门的门选择器的CPL和RPL域必须小于或等于任务门描述符的DPL。请注意，当任务门被使用时 ，目标TSS描述符的DPL不被使用。</p>
<p><img src="/2022/04/14/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/image-20220414204423254.png" alt="image-20220414204423254"></p>
<p>一个任务可以通过一个任务门描述符或一个TSS描述符来访问。这两种结构都满足以下需求。</p>
<ul>
<li>一个任务只需要一个繁忙标志 - 因为一个任务的繁忙标志是存储在TSS描述符中，每个任务应该只有一个TSS描述符。然而，可能有几个任务门会引用同一个TSS描述符。</li>
<li>需要提供对任务的选择性访问—任务门满足这一需求，因为它们可以驻留在一个LDT中，并且可以有一个与TSS描述符的DPL不同的DPL。一个程序或过程如果没有足够的权限访问GDT中任务的TSS描述符（通常DPL为0）的程序或过程可以通过一个具有更高DPL的任务门来访问该任务。任务门给了操作系统更大的限制对特定任务的访问的自由度。</li>
<li>需要一个独立的任务来处理中断或异常 - 任务门也可以驻留在IDT中。在IDT中，它允许中断和异常由处理任务来处理。当一个中断或异常向量指向一个任务门时，处理器会切换到指定的任务。图7-7说明了LDT中的任务门、GDT中的任务门和IDT中的任务门如何都能指向同一个任务。</li>
</ul>
<p><img src="/2022/04/14/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/image-20220414210542784.png" alt="image-20220414210542784"></p>
<h2 id="任务切换"><a href="#任务切换" class="headerlink" title="任务切换"></a>任务切换</h2><p>处理器在四种情况中的一种将执行转移到另一个任务。</p>
<ul>
<li>当前程序、任务或过程执行JMP或CALL指令到GDT中的TSS描述符。</li>
<li>当前程序、任务或过程执行JMP或CALL指令到GDT或当前LDT中的任务门描述符。</li>
<li>中断或异常向量指向IDT中的一个任务门描述符。</li>
<li>当EFLAGS寄存器中的NT标志被设置时，当前任务执行一个IRET。JMP、CALL和IRET指令，以及中断和异常，都是重定向程序的机制。对TSS描述符或任务门的引用（当调用或跳转到一个任务时）或NT标志的状态（当执行IRET时）都是重定向的机制。NT标志的状态（执行IRET指令时）决定是否发生任务切换。当切换到一个新的任务时，处理器会执行以下操作：</li>
</ul>
<ol>
<li>获得新任务的TSS段选择器，作为JMP或CALL指令的操作数，从任务门或前一个任务链接字段（对于用IRET指令启动的任务切换）获得新任务的TSS段选择器。</li>
<li>检查当前（旧）任务是否被允许切换到新任务。数据访问权限规则适用于JMP和CALL指令。当前（旧）任务的CPL和新任务的段选择器的RPL必须小于或等于被引用的TSS描述符或任务门的DPL。例外的情况，中断（由INT n指令产生的中断除外）和IRET指令被允许切换任务，而不考虑TSS描述符的DPL。对于INT n指令产生的中断，要检查DPL。</li>
<li>检查新任务的TSS描述符是否被标记为存在，并且有一个有效的限制（大于或等于67H）。</li>
<li>检查新任务是否可用（调用、跳转、异常或中断）或繁忙（IRET返回）。</li>
<li>检查当前（旧）TSS、新TSS和任务切换中使用的所有段描述符是否被分页到系统内存中。</li>
<li>如果任务切换是由JMP或IRET指令启动的，处理器将清除当前（旧）任务的TSS中的忙（B）标志；如果用CALL指令、异常或中断启动：忙（B）标志保持不变。</li>
<li>如果任务切换是由IRET指令启动的，处理器将清除EFLAGS寄存器中临时保存的NT标志；如果是由CALL或JMP指令、异常或中断启动的，则NT标志在EFLAGS寄存器中保持不变。</li>
<li>在当前任务的TSS中保存当前（旧）任务的状态。处理器在任务寄存器中找到当前TSS的基地址 ，然后将下列寄存器的状态复制到当前的TSS中：所有的通用寄存器，段寄存器中的段选择器，临时保存的EFLAGS寄存器的映像，以及指令指针寄存器（EIP）。</li>
<li>如果任务切换是由CALL指令、异常或中断启动的，处理器将设置EFLAGS寄存器中的NT标志。如果是用IRET指令或JMP指令启动的，NT标志将反映新任务中加载的EFLAGS的NT状态（见表7-2）。</li>
<li>如果任务切换是由CALL指令、JMP指令、异常或中断启动的，处理器就会在新任务的TSS描述符中设置繁忙(B)标志；如果是由IRET指令启动的，繁忙(B)标志就保持不变。</li>
<li>用段选择器和新任务的TSS的描述符加载任务寄存器。</li>
<li>TSS状态被加载到处理器中。这包括LDTR寄存器，PDBR(控制寄存器CR3)，EFLAGS寄存器，EFLAGS寄存器，<br>EIP寄存器，通用寄存器，以及段选择器。在这个状态的加载过程中出现的故障可能会破坏架构状态。(如果没有启用分页，PDBR值会从新任务的TSS中读出，但它不会被加载到CR3中）。</li>
<li>与段选择器相关的描述符被加载和限定。与此相关的任何错误都发生在新任务的上下文中，并可能破坏架构状态。</li>
</ol>
<p><strong>注意事项</strong><br>如果所有的检查和保存都成功进行了，处理器就会提交给任务开关。如果在步骤1到11中发生了不可恢复的错误，处理器不会完成任务切换，并确保处理器返回到执行启动任务切换的指令之前的状态。<br>如果一个不可恢复的错误发生在步骤12，架构状态可能会被破坏，但会试图将在先前的执行环境中处理该错误。如果一个不可恢复的错误发生在提交点之后（在步骤13），处理器完成了任务切换（不执行额外的访问和段可用性检查），并在开始执行新的任务之前产生适当的异常。<br>如果异常发生在提交点之后，异常处理程序必须完成任务切换本身然后才允许处理器开始执行新的任务。</p>
<ol>
<li>开始执行新任务。(对于异常处理程序来说，新任务的第一条指令似乎没有被执行）。</li>
</ol>
<p>当一个成功的任务切换发生时，当前执行的任务的状态总是被保存。如果该任务被恢复 ，执行将从保存的EIP值所指向的指令开始，并且寄存器被恢复到 任务暂停时的值。<br>当切换任务时，新任务的权限级别不会继承被暂停的任务的权限级别。新的任务以CS寄存器的CPL字段中指定的权限级别开始执行，CS寄存器是由TSS加载的。因为任务被它们独立的地址空间和TSS所隔离，并且因为特权规则控制对TSS的访问，所以任务在执行时，需要有足够的权限。<br>表7-1显示了处理器在切换任务时检查的异常条件。它还显示了如果检测到错误，每个检查都会产生异常，以及错误代码所引用的段。<br><img src="/2022/04/14/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/image-20220414215039998.png" alt="image-20220414215039998"></p>
<p><img src="/2022/04/14/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/image-20220414215048323.png" alt="image-20220414215048323"></p>
<p><strong>注意</strong></p>
<ol>
<li><h1 id="NP是段不存在异常，-GP是一般保护异常，-TS是无效TSS异常，-SS是堆栈故障异常。"><a href="#NP是段不存在异常，-GP是一般保护异常，-TS是无效TSS异常，-SS是堆栈故障异常。" class="headerlink" title="NP是段不存在异常，#GP是一般保护异常，#TS是无效TSS异常，#SS是堆栈故障异常。"></a>NP是段不存在异常，#GP是一般保护异常，#TS是无效TSS异常，#SS是堆栈故障异常。</h1></li>
<li>错误代码包含了这一列中引用的段描述符的索引。</li>
<li>如果一个段选择器在一个兼容类型的表中（GDT或LDT），在表的段限制内占据一个地址，那么它是有效的。<br>并且指向兼容的描述符类型（例如，CS寄存器中的段选择器只有当它指向代码段描述符时才有效）。</li>
</ol>
<p>每次发生任务切换时，控制寄存器CR0中的TS（任务切换）标志被设置。在产生浮点异常时，系统软件使用TS标志来协调浮点单元与处理器其他部分的行动。</p>
<h2 id="任务链"><a href="#任务链" class="headerlink" title="任务链"></a>任务链</h2><p>TSS的前一个任务链接字段（有时称为 “反向链接”）和EFLAGS寄存器中的NT标志被用来返回到前一个任务的执行。EFLAGS.NT=1表示当前执行的任务被嵌套在另一个任务的执行中。<br>当CALL指令、中断或异常导致任务切换时：处理器将当前TSS的选择器复制到新任务的TSS的前一个任务链接字段；然后设置EFLAGS.NT=1。如果软件使用IRET指令来暂停新任务，处理器检查EFLAGS.NT=1；然后使用<br>它使用前一个任务链接字段中的值来返回到前一个任务。见图7-8。<br>当JMP指令引起任务切换时，新任务不被嵌套。前一个任务链接字段不被使用，并且EFLAGS.NT=0。当不需要嵌套时，使用JMP指令来调度一个新任务。</p>
<p><img src="/2022/04/14/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/image-20220415161736123.png" alt="image-20220415161736123"></p>
<p>表7-2显示了任务切换过程中的繁忙标志（在TSS段描述符中）、NT标志、前一个任务链接字段和TS标志(在控制寄存器CR0中)在任务切换期间。<br>NT标志可以被任何权限级别的软件所修改。一个程序有可能在设置NT标志的同时执行IRET指令。这可能会随机地调用当前任务的TSS的前一个链接字段中指定的任务。为了防止这种虚假的任务切换成功，操作系统应该把它所创建的每个TSS中的前一个任务链接字段初始化为0。</p>
<p><img src="/2022/04/14/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/image-20220415162023949.png" alt="image-20220415162023949"></p>
<h3 id="使用繁忙标志来防止递归任务的切换"><a href="#使用繁忙标志来防止递归任务的切换" class="headerlink" title="使用繁忙标志来防止递归任务的切换"></a>使用繁忙标志来防止递归任务的切换</h3><p>一个TSS只允许为一个任务保存一个上下文；因此，一旦一个任务被调用（派发），对任务的递归（或重入）调用该任务将导致该任务的当前状态丢失。TSS段中的繁忙标志 是为了防止重入式任务切换和随后的任务状态信息的丢失。处理器对繁忙标志的管理如下 ：</p>
<ol>
<li>当调度一个任务时，处理器设置新任务的繁忙标志。</li>
<li>如果在任务切换过程中，当前任务被放置在一个嵌套链中（任务切换是由一个CALL指令、一个中断或异常产生的），那么新任务的繁忙标志将被设置。</li>
<li>当切换到新的任务时（由CALL指令、中断或异常启动），处理器产生一个一般保护异常。如果新任务的繁忙标志已经被设置，处理器会产生一个一般保护的异常（#GP）。如果任务切换是由IRET指令发起的，那么异常就不会产生，因为处理器希望繁忙标志被设置。</li>
<li>当一个任务被跳转到一个新的任务（由任务代码中的JMP指令发起）或由任务代码中的IRET指令终止时，将产生一个异常。任务代码中的IRET指令终止时，处理器会清除繁忙标志，使任务回到 “不忙 “状态。</li>
</ol>
<p>处理器通过防止一个任务切换到它自己或一个嵌套的任务链中的任何任务来防止递归任务切换。由于多个调用、中断或异常，嵌套的暂停任务链可能增长到任何长度。如果一个任务在这个链中，忙碌标志会阻止它被调用。繁忙标志可以在多处理器配置中使用，因为处理器遵循一个LOCK协议（在总线上或缓存中），当它设置或清除繁忙标志时。这个锁使两个处理器不会同时调用同一个任务。</p>
<h3 id="修改任务链"><a href="#修改任务链" class="headerlink" title="修改任务链"></a>修改任务链</h3><p>在单处理器系统中，如果有必要从链接的任务链中删除一个任务，请使用以下程序来删除<br>使用以下程序来删除任务。</p>
<ol>
<li>禁用中断。</li>
<li>改变抢占式任务（暂停要删除的任务的任务）的TSS中的前一个任务链接字段。假设抢占式任务是要删除的任务链中的下一个任务（较新的任务）。改变前一个任务的链接字段，使其指向链中下一个最老的任务的TSS，或者指向链中更老的任务。</li>
<li>清除被删除的任务的TSS段描述符中的繁忙（B）标志。如果有一个以上的任务被从链上删除，必须清除每个被删除的任务的繁忙标志。</li>
<li>启用中断。</li>
</ol>
<p>在多进程系统中，必须在此过程中增加同步和序列化操作，以确保在改变前一个任务链接字段时，TSS和它的段描述符都被锁定并且繁忙标志被清除。</p>
<h2 id="任务地址空间"><a href="#任务地址空间" class="headerlink" title="任务地址空间"></a>任务地址空间</h2><p>一个任务的地址空间由该任务可以访问的段组成。这些段包括代码、数据、堆栈和在TSS中引用的系统段以及任务代码所访问的任何其他段。这些段被映射到处理器的线性地址空间，而线性地址空间又被映射到处理器的物理地址空间（直接或通过分页）。<br>TSS中的LDT段字段可以用来给每个任务提供它自己的LDT。给予一个任务它自己的LDT允许任务地址空间与其他任务隔离，将与该任务相关的所有段描述符放在该任务的LDT中。也可以让几个任务使用同一个LDT。这是一种节省内存的方式，允许特定的任务互相通信或控制，而不丢掉整个系统的保护屏障。因为所有的任务都可以访问GDT，所以也有可能创建共享段，通过该表的段描述符来访问。<br>如果分页功能被启用，TSS中的CR3寄存器（PDBR）字段允许每个任务有自己的一套页表，用于将线性地址映射到物理地址。或者，几个任务可以共享同一组页表。</p>
<h3 id="将任务映射到线性和物理地址空间"><a href="#将任务映射到线性和物理地址空间" class="headerlink" title="将任务映射到线性和物理地址空间"></a>将任务映射到线性和物理地址空间</h3><p>任务可以通过两种方式之一被映射到线性地址空间和物理地址空间。</p>
<ul>
<li>一个线性到物理地址空间的映射在所有任务之间共享。- 当分页未被启用时，这是唯一的选择。没有分页，所有线性地址都映射到相同的物理地址。当启用时，这种形式的线性到物理地址空间映射是通过为所有任务使用一个页目录来获得。如果支持需求分页，线性地址空间可能超过可用的物理空间。</li>
<li>每个任务都有自己的线性地址空间，被映射到物理地址空间。- 这种形式的映射是通过为每个任务使用不同的页面目录来完成的。因为PDBR（控制寄存器CR3）被加载到任务开关上，每个任务可能有一个不同的页面目录。</li>
</ul>
<p>不同任务的线性地址空间可能映射到完全不同的物理地址。如果不同页面目录的条目 指向不同的页表，而页表指向内存的不同页面，那么这些任务就不会共享物理地址。<br>无论采用哪种方法来映射任务的线性地址空间，所有任务的TSS必须位于物理空间的一个共享区域，这个区域是所有任务都可以访问的。这种映射是必需的，当处理器在任务切换过程中读取和更新TSSs时不会改变。线性地址空间也应该被映射到物理空间的一个共享区域；否则，GDT的目的就会落空。<br>图7-9显示了两个任务的线性地址空间是如何通过共享页表可在物理空间中重叠通过共享页表。</p>
<p><img src="/2022/04/14/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/image-20220415163751118.png" alt="image-20220415163751118"></p>
<h3 id="任务逻辑地址空间"><a href="#任务逻辑地址空间" class="headerlink" title="任务逻辑地址空间"></a>任务逻辑地址空间</h3><p>为了允许任务之间共享数据，使用以下技术为数据段创建共享的逻辑-物理地址空间映射。</p>
<ul>
<li><strong>通过GDT中的段描述符</strong> - 所有任务必须能够访问GDT中的段描述符。如果GDT中的一些段描述符指向线性地址空间中的段，这些段被映射到所有任务共有的物理地址空间的一个区域，那么所有任务都可以共享这些段的数据和代码。</li>
<li><strong>通过一个共享的LDT</strong> - 如果两个或更多的任务的TSSs中的LDT字段指向同一个LDT，那么它们可以使用同一个LDT。如果共享LDT中的一些段描述符指向被映射到物理地址空间的一个共同区域的段 ，这些段的数据和代码可以在共享LDT的任务之间共享。这种共享方法比通过GDT共享更具选择性，因为共享可以被限制在特定的任务中。系统中的其他任务可能有不同的LDT，不允许他们访问共享段。</li>
<li><strong>通过不同的LDT中的段描述符，这些描述符被映射到线性空间的公共地址上</strong> -如果这个线性地址空间的公共区域被映射到每个任务的物理地址空间的相同区域，这些段描述符允许任务共享段。这种段描述符 通常被称为别名。这种共享方法比上面列出的方法更具有选择性。因为，LDT中的其他段描述符可能指向独立的线性地址，而这些段描述符并没有被共享。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/12/%E6%97%B6%E9%97%B4%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/12/%E6%97%B6%E9%97%B4%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">时间记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-12 09:33:47" itemprop="dateCreated datePublished" datetime="2022-04-12T09:33:47+08:00">2022-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-05 23:03:31" itemprop="dateModified" datetime="2022-05-05T23:03:31+08:00">2022-05-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="4-12"><a href="#4-12" class="headerlink" title="4.12"></a>4.12</h2><p>9.30-9.39 背单词</p>
<p>9.39-9.54 看编译原理慕课</p>
<p>10.02-11.07 线代第一讲</p>
<p>11.30-11.45 线代第一讲</p>
<p>13.26-14.56 午觉 </p>
<p>15.00-15.28  15.38- 16.06 线代第一讲完成</p>
<p>16.22-17.00 背单词</p>
<p>17.16-17.35 看《Linux内核完全剖析》</p>
<p>17.45-20.00 健身</p>
<p>20.09-20.44背单词</p>
<p>21.20-21.51 看《Linux内核完全剖析》</p>
<p>21.56-22.08 看实验</p>
<p>22.11-22.20 线代第二章</p>
<h2 id="4-13"><a href="#4-13" class="headerlink" title="4.13"></a>4.13</h2><p>8.49-8.56 英语单词</p>
<p>9.05-9.45 线代第二章</p>
<p>10.-11.45上课</p>
<p>12.39 吃完饭</p>
<p>12.40-14.26 睡午觉</p>
<p>14.31 -14.53 15.00-16.58 17.10-17.17线代第二章</p>
<p>17.18-17.33 英语单词</p>
<p>17.45-20.08 锻炼</p>
<p>20.20-22.00 讨论</p>
<p>22.10-22.36 英语单词</p>
<h2 id="4-14"><a href="#4-14" class="headerlink" title="4.14"></a>4.14</h2><p>10.00-11.47 健身</p>
<p>12.40-12.54 线代第二章</p>
<p>12.55-13.45午觉</p>
<p>13.45-15.30 上课，顺便完成线代第二章</p>
<p>15.30-16.40 打电话与学长</p>
<p>16.40-17.45 看实验</p>
<p>18.30-21.00实验课</p>
<p>21.00-21.52 读书笔记四</p>
<p>22.00-22.30 背单词</p>
<h2 id="4-15"><a href="#4-15" class="headerlink" title="4.15"></a>4.15</h2><p>9.00-10.00 考试</p>
<p>10.02-10.10 单词</p>
<p>10.40-11.00英语听力</p>
<p>12.20-13.48 睡午觉</p>
<p>13.59-14.43 做核酸</p>
<p>14.43-16.05 线代第三章</p>
<p>16.15-16.53 完成读书笔记四</p>
<p>17.45-19.41 健身</p>
<p>19.50-20.26 背单词</p>
<p>20.26-20.56 打电话</p>
<p>21.00-21.16 交报告</p>
<p>21.50-22.30 听力</p>
<h2 id="4-16"><a href="#4-16" class="headerlink" title="4.16"></a>4.16</h2><p>9.10-9.20 单词</p>
<p>9.37-10.37 口语训练配音</p>
<p>10.40-11.46 线代第三章</p>
<p>12.26-13.45午觉</p>
<p>13.45-14.20核酸</p>
<p>14.20-15.26 完成线代第三章</p>
<p>15.30-17.00 看《Linux内核完全剖析》</p>
<p>17.00-17.30 单词</p>
<p>17.45-19.45 健身</p>
<h2 id="4-17"><a href="#4-17" class="headerlink" title="4.17"></a>4.17</h2><p>9.00-10.40 开会</p>
<p>10.45-11.00背单词</p>
<p>15.00-16.45 线代第四章</p>
<h2 id="4-18"><a href="#4-18" class="headerlink" title="4.18"></a>4.18</h2><p>15.45-17.19 完成线代第四章</p>
<p>17.19-17.46 单词</p>
<p>19.15-21.15 数据整理</p>
<h2 id="4-19"><a href="#4-19" class="headerlink" title="4.19"></a>4.19</h2><p>9.09-9.26 背单词</p>
<p>9.27-9.54 线代第五讲，注：需要重新看视频</p>
<p>10.00-12.17 复习完编译原理第一章</p>
<p>14.00-15.10 开会</p>
<p>15.15-16.24 复习数据库ch0</p>
<p>16.45-16.49 17.00-17.36 翻译英语Text5</p>
<p>17.45-19.30 健身</p>
<p>19.30-22.07 开会</p>
<p>22.07-22.23 单词</p>
<h2 id="4-20"><a href="#4-20" class="headerlink" title="4.20"></a>4.20</h2><p>8.50-9.00 背单词</p>
<p>9.08-10.00 数据库报告</p>
<p>10.00-11.45 上课</p>
<p>14.57-15.07 查询资料</p>
<p>15.07-17.30 编译原理实验</p>
<p>17.45-19.30 健身</p>
<p>20.00-21.00 开会</p>
<p>21.30-22.32 单词</p>
<h2 id="4-21"><a href="#4-21" class="headerlink" title="4.21"></a>4.21</h2><p>13.45-16.30 编译原理实验</p>
<p>16.41-17.20 单词</p>
<p>18.36-19.00 20.31-21.30 背单词</p>
<p>21.31-22.30 翻译</p>
<h2 id="4-22"><a href="#4-22" class="headerlink" title="4.22"></a>4.22</h2><p>9.00-11.00 14.30-17.45 数据库实验</p>
<p>19.50-21.00 单词</p>
<p>21.20-23.43 实验</p>
<h2 id="4-23"><a href="#4-23" class="headerlink" title="4.23"></a>4.23</h2><p>11.00过来做比赛</p>
<p>17.45-19.30健身</p>
<p>20.00-22.00 单词</p>
<h2 id="4-24"><a href="#4-24" class="headerlink" title="4.24"></a>4.24</h2><p>15.00-17.00 数据库</p>
<p>20.47-21.31单词</p>
<h2 id="4-25"><a href="#4-25" class="headerlink" title="4.25"></a>4.25</h2><p>8.56-9.45 看《Linux内核完全剖析》</p>
<p>12.56-14.35 睡觉</p>
<p>14.36-15.40 18.20-21.11 完成数据库实验</p>
<p>21.20-22.24 写论文</p>
<h2 id="4-26"><a href="#4-26" class="headerlink" title="4.26"></a>4.26</h2><p>9.20-11.45  看《Linux内核完全剖析》</p>
<p>14.20-15.35 写论文</p>
<p>15.35-17.40 看《Linux内核完全剖析》</p>
<p>20.25-22.44 操作系统实验一</p>
<h2 id="4-27"><a href="#4-27" class="headerlink" title="4.27"></a>4.27</h2><p>8.10-8.20 单词</p>
<p>8.50-10.00 看《Linux内核完全剖析》</p>
<p>12.10-12.20 操作系统实验一</p>
<p>14.30-15.38 完成操作系统实验一</p>
<p>15.53-17.00 数据库实验四</p>
<p>20.05-23.47 实验</p>
<h2 id="4-28"><a href="#4-28" class="headerlink" title="4.28"></a>4.28</h2><p>白天看实验，看了一天</p>
<p>20.30-23.59 写比赛论文</p>
<h2 id="4-29"><a href="#4-29" class="headerlink" title="4.29"></a>4.29</h2><p>9.00-9.05 单词</p>
<p>9.05-9.50 写实验报告</p>
<p>9.51-11.00 实验</p>
<p>14.30-16.39 完成报告与数据库第二章复习</p>
<p>16.40-17.20 编译原理第二讲</p>
<p>20.00-20.56写论文</p>
<ol>
<li>57-21.30 看《Linux内核完全剖析》</li>
<li>35-22.40 单词</li>
</ol>
<h2 id="4-30"><a href="#4-30" class="headerlink" title="4.30"></a>4.30</h2><p>13.00-13.30 单词</p>
<p>13.30-13.38 14.24-16.36 数据库第三章</p>
<p>20.30-21.52 写论文</p>
<h2 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h2><p>14.46-15.03 复习编译原理第三章</p>
<p>15.03-15.48 改论文</p>
<h2 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h2><p>9.00-9.45 单词</p>
<p>9..45-9.55 改论文</p>
<p>14.30-16.30 18.30-22.20 线代第五章完成</p>
<h2 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h2><p>9.00-9.19 背单词</p>
<p>9.21-11.20 14.56—16.40 线代第六章</p>
<p>16.58-17.20数据库复习第四章</p>
<p>19.44-21.39 完成数据库第四章与部分第五章</p>
<p>22.10-22.40 英语听力</p>
<h2 id="5-4"><a href="#5-4" class="headerlink" title="5.4"></a>5.4</h2><p>9.25-9.55 单词</p>
<p>15.10-17.16 做操作系统实验二</p>
<p>20.00-21.58 完成操作系统实验二</p>
<p>22.00-23.00 复习国际结算</p>
<h2 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h2><p>8.53-9.10 单词</p>
<p>9.14-11.00 完成国际结算</p>
<p>14.47-17.20 数据库第五章</p>
<p>21.00-23.00 数据库第五章完成</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/10/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">中断和异常处理-读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-10 19:10:10" itemprop="dateCreated datePublished" datetime="2022-04-10T19:10:10+08:00">2022-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-11 09:20:50" itemprop="dateModified" datetime="2022-04-11T09:20:50+08:00">2022-04-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="中断和异常处理"><a href="#中断和异常处理" class="headerlink" title="中断和异常处理"></a>中断和异常处理</h1><h2 id="中断和异常处理概述"><a href="#中断和异常处理概述" class="headerlink" title="中断和异常处理概述"></a>中断和异常处理概述</h2><p>中断和异常是表明在系统、处理器的某个地方存在一个条件的事件，或当前执行的程序或任务中存在需要处理器注意的情况。它们通常会强制将进程从当前运行的程序或任务转移到一个特殊的软件程序或任务上，称为中断处理程序或异常处理程序。处理器为响应中断或异常而采取的行动被称为中断或异常处理。<br>中断在程序执行过程中随机发生，以响应来自硬件的信号。系统硬件使用中断来处理处理器外部的事件，如服务外围设备的请求。软件也可以通过执行INT n指令来产生中断。当处理器在执行指令时检测到一个错误条件，如除以0，就会发生异常。处理器检测各种错误条件，包括违反保护规定、页面故障和内部机器故障。<br>奔腾4、英特尔至强、P6系列和奔腾处理器的机器，当检测到内部硬件错误和总线错误时，也允许产生一个机器检查异常。<br>当处理器执行一个中断或异常处理程序时，当前运行的程序或任务被暂停。当处理程序的执行完成后，处理器恢复被中断的程序或任务的执行。除非无法从异常中恢复，或者中断导致当前运行的程序被终止，否则被中断的程序或任务的恢复不会失去程序的连续性。<br> 在实模式下，中断向量表占据内存最低的1KB，共256个表项。每个表项4子节，包含一个2子节的段地址和2子节的偏移，即中断处理程序的入口地址。但是在保护模式下，中断向量表可以在内存中自由浮动。就像GDT被GDTR指向一样，中断向量表被IDTR(Interrupt Descriptor Table Register，中断描述符表寄存器)指向。该表和GDT非常类似。首先，GDTR和IDTR在格式上完全相同，均包含一个32bit的基地址和16bit的界限。相比之下，CPU中的另外两个关键寄存器LDTR和TR则表现出了相似性，都是16bit大小，分别包含指向LDT和TSS的选择子。从表项上来看，除了指出中断处理程序的目标地址(16bit选择子和32bit偏移)外，IDT表项还为了进行特权级检测而加入的DPL域。此外，IDT表项还包含一个P比特。</p>
<h2 id="有关中断和异常了解性的内容"><a href="#有关中断和异常了解性的内容" class="headerlink" title="有关中断和异常了解性的内容"></a>有关中断和异常了解性的内容</h2><h3 id="中断和异常向量"><a href="#中断和异常向量" class="headerlink" title="中断和异常向量"></a>中断和异常向量</h3><p>为了帮助处理异常和中断，每个架构上定义的异常和每个中断条件都被分配了一个唯一的识别号，称为向量号。处理器使用分配给一个异常或中断的向量号作为中断描述符表（IDT）的索引。该表提供了一个异常或中断处理程序的入口点。矢量号的允许范围是0到255。在0到31的范围内的向量号是由英特尔64和IA-32架构为架构定义的异常和中断保留了向量号。并非所有的向量号在这个范围内，并不是所有的向量号都有一个当前定义的功能。<br>在32到255范围内的向量号被指定为用户定义的中断，不被Intel64和IA-32架构保留。这些中断通常被分配给外部I/O设备，使这些设备能够向处理器发送中断。</p>
<h3 id="中断源和异常源"><a href="#中断源和异常源" class="headerlink" title="中断源和异常源"></a>中断源和异常源</h3><h4 id="中断来源"><a href="#中断来源" class="headerlink" title="中断来源"></a>中断来源</h4><p>处理器接收来自两个来源的中断。</p>
<ul>
<li>外部（硬件产生的）中断。</li>
<li>软件产生的中断</li>
</ul>
<h5 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h5><p>外部中断是通过处理器上的引脚或通过本地APIC接收的。Pentium 4、Intel Xeon、P6系列和Pentium处理器的主要中断引脚是LINT[1:0]引脚，它与本地APIC相连。启用时，LINT[1:0]引脚可以通过APIC的本地向量表(LVT)进行编程，以便与处理器的任何异常或故障相关联。</p>
<p><img src="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220410193839865.png" alt="image-20220410193839865"></p>
<p><img src="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220410193850982.png" alt="image-20220410193850982"></p>
<h5 id="可屏蔽的硬件中断"><a href="#可屏蔽的硬件中断" class="headerlink" title="可屏蔽的硬件中断"></a>可屏蔽的硬件中断</h5><p>任何通过INTR引脚或通过本地APIC传递给处理器的外部中断被称为可屏蔽硬件中断。可以通过INTR引脚传送的可屏蔽硬件中断包括所有IA-32体系结构定义的从0到255的中断向量；那些可通过本地APIC传送的中断包括中断向量16到255。</p>
<h5 id="软件产生的中断"><a href="#软件产生的中断" class="headerlink" title="软件产生的中断"></a>软件产生的中断</h5><p>INT n指令允许通过提供一个中断向量作为操作数，从软件内部产生中断。例如，INT 35指令强制调用35号中断的中断处理程序。任何从0到255的中断向量都可以作为该指令的参数。如果使用了处理器预定义的NMI向量，那么处理器的反应将与正常产生的的NMI中断产生的反应不一样。如果在这条指令中使用了2号向量（NMI向量），就会调用NMI中断处理程序，但处理器的NMI处理硬件没有被激活。用INT n指令在软件中产生的中断不能被EFLAGS寄存器中的IF标志所屏蔽。</p>
<h4 id="异常来源"><a href="#异常来源" class="headerlink" title="异常来源"></a>异常来源</h4><p>处理器接收来自三个来源的异常。</p>
<ul>
<li>处理器检测到的程序错误异常。</li>
<li>软件产生的异常。</li>
<li>机器检查的异常。</li>
</ul>
<h5 id="程序错误异常"><a href="#程序错误异常" class="headerlink" title="程序错误异常"></a>程序错误异常</h5><p>当处理器在应用程序或操作系统或执行程序的执行过程中检测到程序错误时，会产生一个或多个异常。英特尔64和IA-32架构为每个处理器检测到的异常定义了一个向量号。</p>
<h5 id="软件产生的异常"><a href="#软件产生的异常" class="headerlink" title="软件产生的异常"></a>软件产生的异常</h5><p>INTO, INT 3, 和 BOUND 指令允许在软件中产生异常。这些指令允许异常条件的检查在指令流中执行。例如，INT 3产生一个断点异常。INT n指令可以用来模拟软件中的异常；但是有一个限制。如果INT n提供了一个架构定义的异常的向量，处理器会产生一个中断到正确的向量(来访问异常处理程序），但不会在堆栈上推送错误代码。</p>
<h5 id="机器检查异常"><a href="#机器检查异常" class="headerlink" title="机器检查异常"></a>机器检查异常</h5><p>P6系列和奔腾处理器提供内部和外部机器检查机制，用于检查内部芯片硬件和总线交易的操作。这些机制取决于执行情况。当检测到机器检查错误时，处理器发出机器检查异常信号（向量18）并返回一个错误代码。</p>
<h3 id="异常的分类：故障、陷阱和中止"><a href="#异常的分类：故障、陷阱和中止" class="headerlink" title="异常的分类：故障、陷阱和中止"></a>异常的分类：故障、陷阱和中止</h3><p>异常被归类为故障、陷阱或中止，这取决于它们的报告方式以及引起异常的指令是否能在不损失程序或任务连续性的情况下重新启动。</p>
<ul>
<li><strong>故障</strong></li>
</ul>
<p>故障是一种通常可以被纠正的异常，一旦被纠正，就可以在不损失程序或任务连续性的情况下重新启动程序。<br>当一个故障被报告时，处理器将机器状态恢复到在开始执行故障指令之前的状态。故障处理程序的返回地址（保存在CS和EIP寄存器的保存内容）指向故障指令，而不是指向故障指令之后的指令。</p>
<ul>
<li><p><strong>陷阱</strong> </p>
<p>陷阱是在执行陷阱指令后立即报告的异常。陷阱允许程序或任务的执行继续进行而不损失程序的连续性。陷阱处理程序的返回地址指向陷阱指令后要执行的指令。</p>
</li>
<li><p><strong>终止</strong> </p>
<p>终止是一种异常，它并不总是报告引起异常的指令的精确位置，并且不允许重新启动引起异常的程序或任务。中止是用来报告严重的错误，例如硬件错误和系统表中不一致的或非法的值。</p>
</li>
</ul>
<p><strong>注意</strong></p>
<p>一个通常被报告为故障的异常子集是不能重新启动的。这种异常会导致损失一些处理器的状态。例如，在执行POPAD指令时，堆栈框架执行POPAD指令时，堆栈框架越过了堆栈段的末端，导致报告了一个故障。在这种情况下，异常处理程序看到指令指针(CS:EIP)已经被恢复，就像POPAD 指令没有被执行。然而，内部处理器状态（通用寄存器）将被修改。这种情况被认为是编程错误</p>
<h3 id="程序或任务的重新执行"><a href="#程序或任务的重新执行" class="headerlink" title="程序或任务的重新执行"></a>程序或任务的重新执行</h3><p>为了允许在处理异常或中断后重新启动程序或任务，所有的异常(除了中止)都保证在指令边界上报告异常。所有的中断都被保证为在一个指令边界上进行。<br>对于故障类异常，返回指令指针（在处理器产生异常时保存）指向发生故障的指令。因此，当一个程序或任务在处理完故障后被重新启动时，发生故障的指令被重新启动（重新执行）。重启出错指令通常用于处理当对操作数的访问被阻止时产生的异常。这种类型的故障最常见的例子是页面故障异常（#PF），它发生在程序或任务引用位于不在内存中的页面上的操作数时。<br>当页面故障异常发生时，异常处理程序可以将该页面加载到内存中，并通过重启来恢复程序或任务的执行。为了确保重启对当前执行的程序或任务来说是透明的，处理器保存了必要的寄存器和堆栈指针 ，以允许重新启动到执行故障指令之前的状态。<br>对于陷阱类异常，返回指令的指针指向陷阱指令之后的指令。如果在转移执行的指令中检测到一个陷阱，返回指令指针反映了转移。例如，如果在执行JMP指令时检测到一个陷阱，返回指令的指针指向JMP指令的目的地，而不是JMP指令之后的下一个地址。所有的陷阱异常都允许程序或任务的重新启动而不会失去连续性。例如，溢出异常就是一个陷阱异常。在这里，返回指令的指针指向INTO指令之后的指令，该指令测试了EFLAGS.OF（溢出）标志。这个异常的陷阱处理程序解决了溢出的问题。从陷阱处理程序返回后，程序或任务在INTO指令之后的指令继续执行。<br>终止类异常不支持程序或任务的可靠重启。终止处理程序被设计为收集关于终止异常发生时处理器状态的诊断信息，然后尽可能优雅地关闭应用程序和系统。<br>中断程序严格地支持重新启动被中断的程序和任务而不损失连续性。返回为中断保存的返回指令指针指向要在指令边界执行的下一条指令 。如果刚刚执行的指令有一个重复的前缀，那么中断就会在当前迭代结束时进行，寄存器被设置为执行下一个迭代。</p>
<h3 id="开启和禁止中断"><a href="#开启和禁止中断" class="headerlink" title="开启和禁止中断"></a>开启和禁止中断</h3><p>处理器会抑制一些中断的产生，这取决于处理器的状态和EFLAGS寄存器中的IF和RF标志的状态。</p>
<h4 id="屏蔽可屏蔽硬件中断"><a href="#屏蔽可屏蔽硬件中断" class="headerlink" title="屏蔽可屏蔽硬件中断"></a>屏蔽可屏蔽硬件中断</h4><p>IF标志可以禁止对处理器INTR引脚上或通过本地APIC接收的可屏蔽硬件中断进行服务。当IF标志清除时，处理器会抑制传递到INTR引脚或通过本地APIC的中断产生内部中断请求；当IF标志被设置时，传递到INTR或通过本地APIC引脚的中断被作为正常的外部中断处理。<br>IF标志不影响传递到NMI引脚的非屏蔽中断（NMI）或通过本地APIC传递的交付模式NMI消息，也不影响处理器产生的异常。与EFLAGS寄存器中的其他标志一样，处理器在响应硬件复位时清除IF标志。<br>事实上，可屏蔽的硬件中断组包括保留的中断和异常向量0到32可能会引起混淆。从结构上看，当IF标志被设置时，矢量0到32的中断可以通过INTR引脚传递给处理器，而矢量16到32的中断则可以通过本地接口传递。然后，处理器将产生一个中断并调用中断或异常处理程序，该处理程序由矢量编号指向。<br>IF标志可以通过STI（设置中断使能标志）和CLI（清除中断使能标志）指令来设置或清除。这些指令只有在CPL等于或小于IOPL的情况下才能执行。如果在CPL大于IOPL的情况下执行这些指令，会产生一般保护异常（#GP）。<br>IF标志也受到以下操作的影响。</p>
<ul>
<li>PUSHF指令将所有的标志存储在堆栈上，在那里可以检查和修改它们。POPF指令可以用来将修改后的标志加载到EFLAGS寄存器中。</li>
<li>任务开关、POPF和IRET指令加载EFLAGS寄存器；因此，它们可以用来修改IF标志的设置。</li>
<li>当一个中断通过中断门处理时，IF标志会被自动清除，这就禁止了可屏蔽的硬件中断。</li>
</ul>
<h4 id="屏蔽指令断点"><a href="#屏蔽指令断点" class="headerlink" title="屏蔽指令断点"></a>屏蔽指令断点</h4><p>EFLAGS寄存器中的RF（恢复）标志控制处理器对指令断点条件的响应。当设置时，它阻止指令断点产生调试异常（#DB）；当清除时，指令断点将产生调试异常。RF标志的主要功能是防止处理器在以下情况下进入调试异常循环 。</p>
<h4 id="切换堆栈时屏蔽异常和中断"><a href="#切换堆栈时屏蔽异常和中断" class="headerlink" title="切换堆栈时屏蔽异常和中断"></a>切换堆栈时屏蔽异常和中断</h4><p>为了切换到一个不同的堆栈段，软件经常使用一对指令，例如：<br>MOV SS, AX<br>MOV ESP, StackTop<br>如果在段选择器被加载到SS寄存器之后，但在ESP寄存器被加载之前，发生了中断或异常。ESP寄存器中，这两部分进入堆栈空间的逻辑地址在中断或异常处理过程中是不一致的。为了防止这种情况的发生，处理器在MOV到SS指令或POP到SS指令之后，处理器抑制中断、调试异常和单步陷阱异常，直到到达下一条指令后的指令边界。所有其他的故障仍然可以被产生。如果LSS指令被用来修改SS寄存器的内容（推荐的方法），这个问题就不会发生。</p>
<h3 id="异常和中断的优先级"><a href="#异常和中断的优先级" class="headerlink" title="异常和中断的优先级"></a>异常和中断的优先级</h3><p>如果在一个指令边界有一个以上的异常或中断等待处理，处理器会以可预测的顺序处理它们。下表显示了异常和中断源类别之间的优先级。</p>
<p><img src="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220410202420157.png" alt="image-20220410202420157"></p>
<p><strong>注意</strong>：虽然在表中列出的这些类别的优先级在整个架构中是一致的，但是每个类别中的例外情况是与实现有关的，可能因处理器不同而不同。处理器首先处理来自具有最高优先级的类的未决异常或中断，将执行转移到处理程序的第一条 指令。较低优先级的异常被丢弃；较低优先级的中断被搁置。当中断处理程序将执行返回到程序或任务中出现异常和/或中断的位置时，被丢弃的异常会重新产生。</p>
<h2 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h2><p>中断描述符表（IDT）将每个异常或中断向量与用于服务相关异常或中断的门描述符联系起来。与GDT和LDT一样，IDT是一个由8字节描述符组成的数组。。与GDT不同，IDT的第一个条目可以包含一个描述符。为了<br>为了形成对IDT的索引，处理器将异常或中断向量按8（门描述符的字节数）的比例进行调整。因为只有256个中断或异常向量，IDT不需要包含多于256个描述符。它可以包含少于256个描述符，因为描述符只需要用于可能发生的中断和可能出现的异常向量需要描述符。IDT中所有空的描述符槽都应该将描述符的当前标志设置为0。<br>IDT的基地址应该在8字节的边界上对齐，以最大限度地提高缓存行的性能 。极限值以字节为单位，并与基地址相加，得到最后一个有效字节的地址。极限值为0时，正好是一个有效的字节。因为IDT条目总是8个字节长，所以极限值应该是始终是8的整数倍（即8N-1）。<br>IDT可以驻留在线性地址空间的任何地方。如图6-1所示，处理器使用IDTR寄存器来定位IDT 。这个寄存器持有32位的基地址和16位的IDT限制。<br>LIDT（加载IDT寄存器）和SIDT（存储IDT寄存器）指令分别加载和存储IDTR的内容。LIDT指令将IDTR寄存器中的基地址和限值加载到一个内存操作数中。这条指令只有在CPL为0时才能被执行。它通常由操作系统的初始化代码在创建IDT时使用。操作系统也可以用它来改变一个IDT到另一个IDT。<br>SIDT指令将IDTR中存储的基数和极限值复制到内存中。这条指令可以在任何权限级别下执行。如果一个向量引用的描述符超过了IDT的限制，就会产生一个一般保护异常（#GP）。<br><strong>注意</strong><br>由于中断只传递给处理器内核一次，一个不正确配置的IDT可能导致不完整的中断处理和/或中断传递的阻塞。在设置IDTR基础/限制/访问字段和门描述符中的每个字段时，需要遵循IA-32架构的规则。</p>
<p><img src="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220410202728708.png" alt="image-20220410202728708"></p>
<h2 id="IDT-描述符"><a href="#IDT-描述符" class="headerlink" title="IDT 描述符"></a>IDT 描述符</h2><p>IDT可能包含三种门描述符中的任何一种。</p>
<ul>
<li>任务门描述符</li>
<li>中断门描述符</li>
</ul>
<p>陷阱门描述符<br>图6-2显示了任务门、中断门和陷阱门描述符的格式。任务门的格式在IDT中使用的任务门的格式与在GDT或LDT中使用的任务门的格式相同。任务门包含一个异常和/或中断处理任务的TSS的段选择器。<br>中断和陷阱门与调用门非常相似。它们包含一个远指针(段选择器和偏移量)，处理器用它来把程序的执行转移到异常或中断处理程序代码中的一个处理程序。<br>这些门的不同之处在于处理器处理EFLAGS寄存器中的IF标志的方式。</p>
<p><img src="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220410205107225.png" alt="image-20220410205107225"></p>
<h2 id="中断与异常处理"><a href="#中断与异常处理" class="headerlink" title="中断与异常处理"></a>中断与异常处理</h2><p>处理器处理对异常处理程序和中断处理程序的调用的方式类似于处理对过程或任务的CALL指令来处理对过程或任务的调用。当响应一个异常或中断时，处理器使用异常或中断向量作为IDT中描述符的索引。如果该索引指向一个中断门或陷阱门，处理器调用异常或中断处理程序，其方式类似于调用门的CALL。如果 index 指向一个任务<br>门，处理器将执行一个任务切换到异常或中断处理任务，其方式类似于 CALL到一个任务门</p>
<h3 id="异常或中断处理程序"><a href="#异常或中断处理程序" class="headerlink" title="异常或中断处理程序"></a>异常或中断处理程序</h3><p>中断门或陷阱门引用了一个异常或中断处理程序，该程序在当前执行的任务的上下文中运行（见图6-3）。该门的段选择器指向一个段描述符，该段描述符位于GDT或当前LDT中的一个可执行代码段。门描述符的偏移字段指的是<br>异常或中断处理程序的开头。</p>
<p><img src="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220410205743923.png" alt="image-20220410205743923"></p>
<p>当处理器执行一个对异常或中断处理程序的调用时。</p>
<ul>
<li>如果处理程序要在一个较低的权限级别上执行，就会发生堆栈切换。<br>当堆栈切换发生时 :<br>a. 处理程序使用的堆栈的段选择器和堆栈指针是从当前执行任务的TSS中获得的。在这个新的堆栈中，处理程序推送了被中断的堆栈段选择器和堆栈指针。<br>b. 然后，处理器将EFLAGS、CS和EIP寄存器的当前状态保存在新的堆栈中（见图6-4）。<br>c. 如果一个异常导致错误代码被保存，它将被推到EIP值之后的新栈上。</li>
<li>如果处理程序要在与被中断程序相同的权限级别下执行。<br>a. 处理器将EFLAGS、CS和EIP寄存器的当前状态保存在当前堆栈中（见图6-4）。<br>b. 如果一个异常导致错误代码被保存，那么它将在EIP值之后被推到当前堆栈中。</li>
</ul>
<p><img src="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220410210127965.png" alt="image-20220410210127965"></p>
<p>要从一个异常或中断处理程序中返回，处理程序必须使用IRET（或IRETD）指令。IRET指令与RET指令类似，只是它将保存的标志恢复到EFLAGS寄存器中。只有当CPL为0时，EFLAGS寄存器的IOPL字段才被恢复。</p>
<h4 id="异常和中断处理程序的保护"><a href="#异常和中断处理程序的保护" class="headerlink" title="异常和中断处理程序的保护"></a>异常和中断处理程序的保护</h4><p>异常和中断处理程序的特权级别保护与通过调用门调用普通程序的保护相似。处理器不允许将执行转移到一个异常或中断处理程序中。试图违反这一规则会导致一般保护异常（#GP）。异常处理程序和中断处理程序的保护机制在以下方面有所不同：</p>
<ul>
<li>因为中断和异常向量没有RPL，RPL在隐式调用异常和中断处理程序的隐式调用不检查RPL。</li>
<li>只有在异常或中断产生的时候，处理器才会检查中断或陷阱门的DPL，如果有一个INT n, INT 3, 或 INTO 指令产生的异常或中断，处理器才会检查中断或陷阱门的 DPL。这里，CPL必须小于或等于门的DPL。这一限制防止了运行在权限级别3的应用程序或程序使用软件中断来访问关键的异常处理程序。中断来访问关键的异常处理程序，例如页面故障处理程序，条件是这些处理程序被放在更有权限的代码段中。对于硬件产生的中断和处理器检测到的异常，处理器忽略了中断和陷阱门的DPL。</li>
</ul>
<p>由于异常和中断通常不会在可预测的时间发生，这些特权规则有效地对异常和中断处理程序可以运行的权限级别进行了限制。以下两种技术都可以用来避免违反权限级别：</p>
<ul>
<li>异常或中断处理程序可以放在一个符合要求的代码段中。这种技术可以用于处理程序，这些处理程序只需要访问堆栈上的数据（例如，划分错误异常）。如果处理程序需要来自数据段的数据，数据段需要从权限级别3访问，这将使其不受保护。</li>
<li>处理程序可以被放置在一个特权级别为0的不符合要求的代码段中。这个处理程序将始终运行，不管被中断的程序或任务是在哪个CPL下运行。</li>
</ul>
<h4 id="异常或中断处理程序的标志用法"><a href="#异常或中断处理程序的标志用法" class="headerlink" title="异常或中断处理程序的标志用法"></a>异常或中断处理程序的标志用法</h4><p>当通过中断门或陷阱门访问异常或中断处理程序时，处理器在将EFLAGS寄存器的内容保存在堆栈中后，清除EFLAGS寄存器中的TF标志。(在调用异常和中断处理程序时，处理器也会清除EFLAGS寄存器中的VM、RF和NT标志，然后将它们保存在堆栈中。）清除TF标志可以防止指令跟踪影响中断响应。A 后续的IRET指令将TF（以及VM、RF和NT）标志恢复到堆栈中EFLAGS寄存器的保存内容中的值。<br>中断门和陷阱门的唯一区别是处理器处理IF标志的方式。当通过中断门访问一个异常或中断处理程序时，处理器会清除IF标志以防止 其他中断干扰当前的中断处理程序。随后的IRET指令将IF标志恢复到堆栈上EFLAGS寄存器的保存内容中的值。通过陷阱门访问处理程序并不影响IF标志。</p>
<h3 id="中断任务"><a href="#中断任务" class="headerlink" title="中断任务"></a>中断任务</h3><p>当异常或中断处理程序通过IDT中的任务门被访问时，会产生一个任务切换。处理异常或中断的单独任务有几个优点。</p>
<ul>
<li>被中断的程序或任务的整个上下文被自动保存。</li>
<li>一个新的TSS允许处理程序在处理异常或中断时使用一个新的权限级别0的堆栈。如果异常或中断发生时，当前权限级别0的堆栈被破坏，通过任务门访问处理程序可以通过为处理程序提供一个新的权限级别0的堆栈来防止系统崩溃。</li>
<li>处理程序可以通过给它一个单独的地址空间来进一步与其他任务隔离。这可以通过以下方式实现给它一个单独的LDT。</li>
</ul>
<p>用一个单独的任务来处理中断的缺点是，在任务切换时必须保存大量的机器状态，使得它比使用中断门要慢，从而导致中断延迟的增加。<br>IDT中的任务门引用GDT中的TSS描述符（见图6-5）。切换到处理程序任务的方式与普通任务切换相同。返回到被中断的任务的链接 被存储在处理程序任务的TSS的前一个任务链接域中。如果一个异常导致一个错误代码，这个错误代码被复制到新任务的堆栈中。<br>在操作系统中使用异常或中断处理任务时，实际上有两种机制可以用来调度任务：软件调度器（操作系统的一部分）和硬件调度器（处理器的中断机制的一部分）。软件调度器需要容纳中断任务当中断被激活时，可能会被调度。<br><strong>注意</strong><br>由于IA-32体系结构的任务不是可重入的，一个中断处理程序任务在它完成处理中断和执行IRET指令时，必须禁用中断。这个动作可以防止在中断任务的TSS仍被标记为忙时发生另一个中断，这将导致一般保护（#GP）异常。</p>
<p><img src="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220411091420768.png" alt="image-20220411091420768"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">保护模式内存管理-读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-03 10:09:18" itemprop="dateCreated datePublished" datetime="2022-04-03T10:09:18+08:00">2022-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-04 20:56:32" itemprop="dateModified" datetime="2022-04-04T20:56:32+08:00">2022-04-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="保护模式内存管理"><a href="#保护模式内存管理" class="headerlink" title="保护模式内存管理"></a>保护模式内存管理</h1><h2 id="内存管理概览"><a href="#内存管理概览" class="headerlink" title="内存管理概览"></a>内存管理概览</h2><p>IA-32架构的内存管理设施分为两部分：分段和分页。<br>分段提供了一种隔离单个代码、数据和堆栈模块的机制，以便多个程序（或任务）可以在同一个处理器上运行而不互相干扰。分页提供了一种机制来实现传统的需求分页、虚拟内存系统，其中程序执行环境的部分被映射到物理内存中。分页也可以用来提供多个任务之间的隔离。<br>在保护模式下操作时，必须使用某种形式的分段。没有模式位可以禁用分段。然而，分页的使用是可选的。这两种机制（分段和分页）可以被配置为支持简单的单程序（或单任务）系统，或使用共享内存的多处理器系统。</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220403145257014.png" alt="image-20220403145257014"></p>
<p>如图所示，分段提供了一种机制来划分处理器的可寻址内存空间（称为线性地址空间），分成更小的受保护的地址空间，称为段。分段可以可以用来保存程序的代码、数据和堆栈，或者保存系统数据结构（如TSS或LDT）。<br>如果一个处理器上有多个程序（或任务）在运行，每个程序可以被分配到它自己的段组。然后，处理器强制执行这些段之间的界限，并确保一个程序不会因为写进另一个程序的段而干扰程序的执行。分段机制还允许对段进行打字。</p>
<p>段落机制也允许段的类型化，这样可以限制对特定类型的段进行的操作。一个系统中的所有段都包含在处理器的线性地址空间中。要在一个特定的段中找到一个字节必须提供一个逻辑地址（也称为远指针）。</p>
<p>一个<strong>逻辑地址</strong>包括一个段选择器和一个偏移量。段选择器是一个段的唯一标识符。在其他方面，它提供了一个<br>在描述符表（如全局描述符表，GDT）中的偏移量，该数据结构称为段描述符。每个网段都有一个网段描述符，它指定了网段的大小，网段的访问权限和段的大小，段的访问权限和特权级别，段的类型，以及段的第一个字节在线性地址空间中的位置（称为段的基址）。逻辑地址的偏移部分被添加到段的基地址中，以定位段的第一个字节。<br>基准地址加上偏移量就形成了处理器线性地址中的一个<strong>线性地址</strong>。<br>如果不使用分页，处理器的线性地址空间将直接被映射到处理器的物理地址空间。<strong>物理地址空间</strong>被定义为处理器可以在其地址总线上产生的地址范围。由于多任务计算系统通常定义的线性地址空间远远大于在物理内存中一次性包含的经济可行性，因此需要一些 “虚拟化 “线性地址空间的方法。这种线性地址空间的虚拟化是通过处理器的分页机制处理的。<br>分页支持 “虚拟内存 “环境，用少量的物理内存（RAM和ROM）和一些磁盘存储来模拟大的线性地址空间。当使用分页时，每个段被划分为若干页（通常每页大小为4KB），这些页存储在物理内存或磁盘上。操作系统或执行器维护一个页面目录和一组页面表，以跟踪这些页面。<em>当一个程序（或任务）试图访问线性地址空间中的一个地址位置时，处理器会使用页目录和页表来将线性地址转换为物理地址</em>，然后执行所要求的操作（读或写）在内存位置上。<br>如果被访问的页面当前不在物理内存中，处理器会中断程序的执行。(通过产生一个页面故障异常)。然后，操作系统或执行程序将该页从磁盘读入物理内存，并继续执行程序。<br>当分页在操作系统或执行系统中被正确实现时，物理内存和磁盘之间的换页对于程序的正确执行是透明的。即使是为16位IA32处理器编写的程序，在虚拟8086模式下运行时也可以进行分页（透明）。</p>
<h3 id="linux下的内存管理"><a href="#linux下的内存管理" class="headerlink" title="linux下的内存管理"></a>linux下的内存管理</h3><p>Linux系统中的物理存储空间和虚拟存储空间的地址范围分别都是从0x00000000到0xFFFFFFFF，共4GB，但物理存储空间与虚拟存储空间布局完全不同。Linux运行在虚拟存储空间，并负责把系统中实际存在的远小于4GB的物理内存根据不同需求映射到整个4GB的虚拟存储空间中。Linux主要工作在保护模式下。80X86从逻辑地址到物理地址变换中经过了两个阶段。第一阶段使用分段机制把程序的逻辑地址变换成处理器可寻址内存空间（称为线性地址空间）中的地址。第二阶段的分页机制把线性地址转换成物理地址。第一阶段的分段变换机制是必须使用的，但是第二阶段的分页机制是可选择的。如果没有开启分页机制，那么分段机制产生的线性地址空间就直接映射到处理器的物理地址空间上。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>物理地址</strong>： 放在寻址总线上的地址，用于内存芯片级内存单元寻址。放在寻址总线上，如果是读，电路根据这个地址每位的值就将相应地址的物理内存中的数据放到数据总线中传输。如果是写，电路根据这个地址每位的值就将相应地址的物理内存中放入数据总线上的内容。物理内存是以字节(8位)为单位编址的，是地址变换的最终结果地址，物理地址由32位或36位无符号整数表示。</p>
<p><strong>逻辑地址</strong>：是指由程序产生的与段相关的偏移地址部分，每一个逻辑地址都由一个段和偏移量组成。在进行C语言指针编程中，可以读取指针变量本身值(&amp;操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址，不和绝对物理地址相干。只有在Intel实模式下，逻辑地址才和物理地址相等（因为实模式没有分段或分页机制,Cpu不进行自动地址转换）；逻辑也就是在Intel 保护模式下程序执行代码段限长内的偏移地址（假定代码段、数据段如果完全一样）。</p>
<p><strong>线性地址：</strong>是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址，是一个32位无符号整数，可以用来表示高达4GB的地址，也就是说，高达4294967296个内存单元，以十六进制表示，0x00000000到oxffffffff。如果启用了分页机制，那么线性地址可以再经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。Intel 80386的线性地址空间容量为4G（2的32次方即32根地址总线寻址）。</p>
<p><strong>虚拟内存</strong>：是指计算机呈现出要比实际拥有的内存大得多的内存量。因此它允许程序员编制并运行比实际系统拥有的内存大得多的程序。这使得许多大型项目也能够在具有有限内存资源的系统上实现。一个很恰当的比喻是：你不需要很长的轨道就可以让一列火车从上海开到北京。你只需要足够长的铁轨（比如说3公里）就可以完成这个任务。采取的方法是把后面的铁轨立刻铺到火车的前面，只要你的操作足够快并能满足要求，列车就能象在一条完整的轨道上运行。这也就是虚拟内存管理需要完成的任务。在现在操作系统中，都使用了MMU的存储管理技术，而MMU管理的地址是虚拟地址，虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。有时我们也把逻辑地址称为虚拟地址。因为和虚拟内存空间的概念类似，逻辑地址也是和实际物理内存容量无关的。</p>
<h4 id="逻辑地址如何转换为线性地址"><a href="#逻辑地址如何转换为线性地址" class="headerlink" title="逻辑地址如何转换为线性地址"></a>逻辑地址如何转换为线性地址</h4><p> 完整的内存管理，包含保护和地址变换两个关键部分。80386的工作模式包括实地址模式和虚地址模式（保护模式）。Linux主要工作在保护模式下。80X86从逻辑地址到物理地址变换中经过了两个阶段。第一阶段使用分段机制把程序的逻辑地址变换成处理器可寻址内存空间（称为线性地址空间）中的地址。第二阶段的分页机制把线性地址转换成物理地址。第一阶段的分段变换机制是必须使用的，但是第二阶段的分页机制是可选择的。如果没有开启分页机制，那么分段机制产生的线性地址空间就直接映射到处理器的物理地址空间上。</p>
<p>  一个逻辑地址由两部份组成，<strong>段标识符: 段内偏移量</strong>。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，表示具体的是代码段寄存器还是栈段寄存器抑或是数据段寄存器，如图1所示。索引号就是“段描述符(segment descriptor)”的索引，段描述符具体地址描述了一个段。很多个段描述符，就组了一个数组，叫“段描述符表”，这样，<strong>可以通过段标识符的前13位，直接在段描述符表中找到一个具体的段描述符</strong>，这句话很关键，说明段标识符的具体作用，每一个段描述符由8个字节组成，如图2所示，与主题最密切的就是Base字段，她表示的是包含段的首字节的线性地址，也就是一个段的开始位置的线性地址。完全引用书中的一句话，一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。那究竟什么时候该用GDT，什么时候该用LDT呢？这是由段选择符中的T1字段表示的，=0，表示用GDT，=1表示用LDT，GDT在内存中的地址和大小存放在CPU的GDTR控制寄存器中，而LDT则在IDTR寄存器中。这个过程中有几个基本的概念，一定要理清楚，如段选择符、段描述符、局部段描述符表、全局段描述符表。</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220403152513453.png" alt="image-20220403152513453"></p>
<p>上图显示了一个逻辑地址是怎样转换成相应线性地址的，给定一个完整的逻辑地址[段选择符：段内偏移地址]</p>
<p> 1、看段选择符的T1=0还是1，即<strong>先检查段选择符中的TI字段，以决定段描述符保存在哪一个描述符表中</strong>，知道当前要转换是GDT中的段（在这种情况下，分段单元从GDTR寄存器中得到GDT的线性基地址），还是LDT中的段（在这种情况下，分段单元从LDTR寄存器中得到GDT的线性基地址），再根据相应寄存器，得到其地址和大小。<br>2、<strong>由于一个段描述符是8字节长，因此她在GDT或LDT内的相对地址是由段选择符的最高13位的值乘以8得到</strong>，拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它的Offset，即偏移地址就知道了。<br>3、把Base + offset，就是要转换的线性地址了。<br>    对于软件来讲，原则上就需要把硬件转换所需的信息准备好，就可以让硬件来完成这个转换了。下图逻辑地址转换为线性地址实例，段选择符为0x7B，指向用户数据段，段起始地址为0x00000000，逻辑偏移地址为0x80495B0，最终的线性地址为Base + offset=0x80495B0。</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220403153532441.png" alt="image-20220403153532441"></p>
<h4 id="线性地址转物理地址"><a href="#线性地址转物理地址" class="headerlink" title="线性地址转物理地址"></a>线性地址转物理地址</h4><p>CPU通过地址来访问内存中的单元，地址有虚拟地址和物理地址之分，如果CPU没有MMU（Memory  Management Unit，内存管理单元），或者有MMU但没有启用，CPU核在取指令或访问内存时发出的地址将直接传到CPU芯片的外部地址引脚上，直接被内存芯片（以下称为物理内存，以便与虚拟内存区分）接收，这称为物理地址（Physical Address，以下简称PA），如下图所示。</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220403155046532.png" alt="image-20220403155046532"></p>
<p>如果CPU启用了MMU，CPU核发出的地址将被MMU截获，从CPU到MMU的地址称为虚拟地址（Virtual Address，以下简称VA），而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将虚拟地址映射成物理地址，如下图所示</p>
<p> <img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220403155108029.png" alt="image-20220403155108029"></p>
<p>虚拟内存地址和物理内存地址的分离，给进程带来便利性和安全性。虚拟地址必须和物理地址建立一一对应的关系，才可以正确的进行地址转换。</p>
<p>记录对应关系最简单的办法，就是把对应关系记录在一张表中。为了让翻译速度足够地快，这个表必须加载在内存中。不过，这种记录方式惊人地浪费。</p>
<p>因此，Linux采用了分页（paging）的方式来记录对应关系。所谓的分页，就是以更大尺寸的单位页（page）来管理内存。在Linux中，通常每页大小为4KB。</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220403155154004.png" alt="image-20220403155154004"></p>
<p>依据以下步骤进行转换：</p>
<ol>
<li>从cr3中取出进程的页目录地址（操作系统负责在调度进程的时候，把这个地址装入对应寄存器）；</li>
<li>根据线性地址前十位，在数组中，找到对应的索引项，因为引入了二级管理模式，页目录中的项，不再是页的地址，而是一个页表的地址。（又引入了一个数组），页的地址被放到页表中去了。</li>
<li>根据线性地址的中间十位，在页表（也是数组）中找到页的起始地址；</li>
<li>将页的起始地址与线性地址中最后12位相加，得到最终我们想要的；</li>
</ol>
<h2 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h2><p>由IA-32体系结构支持的分段机制可以用来实现各种各样的系统设计。这些设计的范围很广，从只极少使用分段的平面模型到保护。这些设计从扁平模型到多分段模型，这些模型采用分段来创建一个强大的操作环境，在其中多个程序和任务可以可靠地执行。</p>
<h3 id="Basic-Flat-Model-基本平坦模型"><a href="#Basic-Flat-Model-基本平坦模型" class="headerlink" title="Basic Flat Model(基本平坦模型)"></a>Basic Flat Model(基本平坦模型)</h3><p>一个系统最简单的内存模型是基本的 “平坦模型”，在这个模型中，操作系统和应用程序可以访问一个连续的、没有分割的地址空间。在最大程度上，这种基本的平坦模型对系统设计者和应用程序都隐藏了架构的分割机制。<br>程序员为了实现IA-32体系结构的基本平坦内存模型，至少要创建两个段描述符，一个用于引用代码段，一个用于引用数据段。这两个段都被映射到整个线性地址空间：也就是说，两个段描述符都有同样的基址值为0，同样的段限制为4GBytes。通过设置段限制为4GBytes，分段机制就不会因为超出限制的内存引用而产生异常，即使在一个特定的地址上没有物理内存存在。ROM（EPROM）通常位于物理地址空间的顶部。因为处理器在FFF_FFF0H开始执行。RAM（DRAM）被放在物理地址空间的底部，因为复位初始化后DS数据段的初始基址是0。</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220403161325418.png" alt="image-20220403161325418"></p>
<p>​                                                                        flat model</p>
<h3 id="Protected-Flat-Model-受保护的平坦模型"><a href="#Protected-Flat-Model-受保护的平坦模型" class="headerlink" title="Protected Flat Model(受保护的平坦模型)"></a>Protected Flat Model(受保护的平坦模型)</h3><p>受保护的平坦模型与基本平坦模型类似，只是段的限制被设置为只包括物理内存实际存在的的地址范围（见下图）。一个一般保护的异常(#GP)会在任何访问不存在的内存的尝试中产生。这个模型提供了一个最低水平的<br>这种模式提供了最低水平的硬件保护，以防止某些类型的程序错误。</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220403161745702.png" alt="image-20220403161745702"></p>
<p>​                                                                  Protected Flat Model</p>
<p>更多的复杂性可以被添加到这个受保护的平坦模型中，以提供更多的保护。例如，对于分页机制要在用户和主管的代码和数据之间提供隔离，需要定义四个段。用户的代码和数据段的权限级别为3，而主管的代码和数据段的权限级别为0。通常，这些段都是相互重叠的，并从线性地址空间的地址0开始。这种平坦的分段模型和一个简单的分页结构可以保护操作系统不受应用程序的影响。通过为每个任务或进程增加一个单独的分页结构，它还可以保护应用程序之间的相互影响。类似的设计被几个流行的多任务操作系统所采用。</p>
<h3 id="Multi-Segment-Model-多段模型"><a href="#Multi-Segment-Model-多段模型" class="headerlink" title="Multi-Segment Model(多段模型)"></a>Multi-Segment Model(多段模型)</h3><p>多段模型（如下图）使用分段机制的全部功能，对代码、数据结构、程序和任务提供硬件强制保护。在这里，每个<br>程序（或任务）都有自己的段描述符表和自己的段。这些段可以是对其分配的程序来说是完全私有的，或者在程序之间共享。对所有程序段的访问以及对运行在各个程序上的执行环境都由硬件控制。<br>访问检查不仅可以用来防止引用一个段限制之外的地址，还可以防止在段内进行不允许的操作。例如，由于代码段被指定为只读段，所以可以用硬件来防止向代码段写东西。为段创建的访问权限信息也可以用来设置保护环或保护级别。保护级别可以用来保护操作系统程序免受应用程序的未经授权的访问。</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220403163121670.png" alt="image-20220403163121670"></p>
<p>​                                                            Multi-Segment Model</p>
<h3 id="Segmentation-in-IA-32e-Mode"><a href="#Segmentation-in-IA-32e-Mode" class="headerlink" title="Segmentation in IA-32e Mode"></a>Segmentation in IA-32e Mode</h3><p>在英特尔64架构的IA-32e模式下，分段的效果取决于处理器是在兼容模式还是64位模式下运行。在兼容模式下，分段的功能就像使用传统的16位或32位保护模式的语义。在64位模式下，分段功能通常被禁用（但不是完全禁用），创建一个平坦的64位线性地址空间。处理器将CS、DS、ES、SS的段基处理为零，创建一个线性地址，等于<br>有效地址。FS和GS段是个例外。这些段寄存器（存放段基）可以作为线性地址计算中的一个额外的基础寄存器。它们有助于寻址本地数据和某些操作系统的数据结构。注意，在64位模式下，处理器在运行时不执行段限制检查。</p>
<h3 id="Paging-and-Segmentation-分页和分段"><a href="#Paging-and-Segmentation-分页和分段" class="headerlink" title="Paging and Segmentation(分页和分段)"></a>Paging and Segmentation(分页和分段)</h3><p>分页可以与上图中描述的任何一种分段模式一起使用。处理器的分页机制将线性地址空间（段被映射到其中）分为若干页。然后这些线性地址空间的页被映射到物理地址空间的页中。分页机制提供了几个页级的保护设施，可以和段保护设施一起使用，也可以代替段保护设施。例如，它允许在逐页的基础上强制执行读写保护。分页 机制还提供了两级用户-监督者保护，也可以在每页的基础上指定。</p>
<h2 id="逻辑地址和线性地址的转换"><a href="#逻辑地址和线性地址的转换" class="headerlink" title="逻辑地址和线性地址的转换"></a>逻辑地址和线性地址的转换</h2><p>注:之前的内容为自己整理，以下为参考指导书翻译</p>
<p>在保护模式下的系统架构层面，处理器使用两个阶段的地址转换来获得物理地址：逻辑地址转换和线性地址空间分页。<br>物理地址：逻辑地址转换和线性地址空间分页。即使对段的使用降到最低，处理器地址空间中的每一个字节都可以用一个逻辑地址来访问。一个逻辑地址包括一个16位的段选择器和一个32位的偏移量。段选择器确定了字节所处的段，偏移量指定了字节在段中相对于该段的基址的位置。处理器将每个逻辑地址转化为一个线性地址。线性地址是处理器线性地址空间中的一个32位地址。像物理地址空间一样，线性地址空间是一个平面的（未分割的）。232字节的地址空间，地址范围从0到FFFFFFFH。线性地址空间包含所有段和为系统定义的系统表。为了将逻辑地址转换为线性地址，处理器做了以下工作：</p>
<ol>
<li>使用段选择器中的偏移量来定位GDT或LDT中段的段描述符，并将其读入处理器。(只有当一个新的段选择器被加载到段寄存器中时才需要这个步骤。）</li>
<li>检查段描述符，以检查段的访问权限和范围，以确保段是可访问的，并且偏移量在段的限制范围内。</li>
<li>将段描述符中的段基地址加到偏移量上，形成一个线性地址。</li>
</ol>
<p>如果不使用分页，处理器将线性地址直接映射到物理地址上。如果线性地址空间被分页，第二层的地址转换被用来将线性地址转换为物理地址。<br><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220404154555152.png" alt="image-20220404154555152"></p>
<h3 id="Logical-Address-Translation-in-IA-32e-Mode-IA-32e-模式下的逻辑地址转换"><a href="#Logical-Address-Translation-in-IA-32e-Mode-IA-32e-模式下的逻辑地址转换" class="headerlink" title="Logical Address Translation in IA-32e Mode(IA-32e 模式下的逻辑地址转换)"></a>Logical Address Translation in IA-32e Mode(IA-32e 模式下的逻辑地址转换)</h3><p>在 IA-32e 模式下，Intel 64 处理器使用上述步骤将逻辑地址转换为线性地址。在64位模式下，段的偏移量和基地址是64位而不是32位。线性地址地址格式也是64位宽，并受制于典型形式的要求。每个代码段描述符都提供一个L位。这个位允许一个代码段执行64位代码或传统的32位代码的代码段。</p>
<h3 id="Segment-Selectors-段选择子"><a href="#Segment-Selectors-段选择子" class="headerlink" title="Segment Selectors(段选择子)"></a>Segment Selectors(段选择子)</h3><p>段选择器是一个段的16位标识符（见下图）。它并不直接指向段，而是指向定义该段的段描述符。一个段选择器包含以下内容 ：</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220404154957115.png" alt="image-20220404154957115"></p>
<p>​                                                         Segment Selector</p>
<p><strong>索引</strong>（第3至15位）- 在GDT或LDT中选择8192个描述符之一。处理器将索引值乘以8（段描述符中的字节数），并将结果加到GDT或LDT的基址上（分别来自GDTR或LDTR寄存器）。<br><strong>TI（表指示器）标志</strong><br>(Bit 2) - 指定要使用的描述符表：清除该标志选择GDT；设置该标志选择当前的LDT。</p>
<p><strong>要求的权限级别(RPL)</strong><br>(位0和1) - 指定选择器的权限级别。特权级别范围从0到3，其中0为最高权限级别。</p>
<p>GDT的第一个条目不被处理器使用。指向GDT这个条目的段选择器（即索引为0且TI标志设置为0的段选择器）被用作 “空段选择器”。就是说，一个索引为0且TI标志设置为0的段选择器被用作 “空段选择器”。当一个段寄存器（除了CS或SS寄存器）被载入空段选择器时，处理器不会产生一个异常。然而，当一个持有空段选择器的段寄存器被用来访问内存时，它会产生一个异常。空选择器可以用来初始化未使用的段寄存器。用一个空的段选择器加载CS或SS寄存器会导致一个通用的保护机制。段选择器加载CS或SS寄存器会产生一个通用保护异常（#GP）。段落选择器作为指针变量的一部分对应用程序是可见的，但是选择器的值通常是由链接编辑器分配或修改的，而不是应用程序。</p>
<h3 id="Segment-Registers-段寄存器"><a href="#Segment-Registers-段寄存器" class="headerlink" title="Segment Registers(段寄存器)"></a>Segment Registers(段寄存器)</h3><p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220404160315942.png" alt="image-20220404160315942"></p>
<p>为了减少地址转换的时间和编码的复杂性，处理器提供了最多容纳6个段选择器的寄存器。这些段寄存器中的每一个都支持一种特定的内存引用(代码、堆栈或数据)。对于几乎任何一种程序的执行，至少要有代码段（CS），数据段（DS）和堆栈段（SS）寄存器且必须被加载有效的段选择器。处理器还提供了三个额外的数据段寄存器（ES、FS和GS），这些寄存器可以用来为当前执行的程序（或任务）提供额外的数据段。</p>
<p>一个程序要访问一个段，该段的段选择器必须被加载到其中一个段寄存器中。因此，尽管一个系统可以定义数以千计的段，但只有6个可以立即使用。其他的段可以通过在程序执行期间将它们的段选择器加载到这些寄存器中来实现。</p>
<p>每个段寄存器都有一个 “可见 “部分和一个 “隐藏 “部分。(隐藏部分有时被称为”描述符缓存 “或 “阴影寄存器”）。当段选择器被加载到段寄存器的可见部分时，处理器也会在段寄存器的隐藏部分加载基础地址、段限制和段描述符的访问控制信息。这些信息来自段选择器所指向的段描述符。缓存在段寄存器中的信息（可见的和隐藏的）允许处理器翻译地址，而不需要花费额外的总线周期来读取基址和限制。<br>系统中，多个处理器可以访问相同的描述符表，当描述符表被修改时，软件有责任重新加载段寄存器。如果不这样做，缓存在段寄存器中的旧的段描述符就可能在其内存驻留版本被修改后被使用。<br>为加载段寄存器提供了两种类型的加载指令:</p>
<ol>
<li><p>直接加载指令，如MOV, POP, LDS, LES, LSS, LGS和LFS指令。这些指令明确地引用段寄存器。</p>
</li>
<li><p>隐含的加载指令，如CALL、JMP和RET指令的远端指针版本，SYSENTER和SYSEXIT指令，以及IRET、INTn、INTO和INT3指令。<br>这些指令改变了CS寄存器的内容（有时也会改变其他段寄存器的内容），这是其操作的附带部分。MOV指令也可以用来将段寄存器的可见部分存储在通用寄存器中。</p>
</li>
</ol>
<h3 id="Segment-Loading-Instructions-in-IA-32e-Mode-IA-32e模式下的段加载指令"><a href="#Segment-Loading-Instructions-in-IA-32e-Mode-IA-32e模式下的段加载指令" class="headerlink" title="Segment Loading Instructions in IA-32e Mode(IA-32e模式下的段加载指令)"></a>Segment Loading Instructions in IA-32e Mode(IA-32e模式下的段加载指令)</h3><p>由于ES、DS和SS段寄存器在64位模式下不被使用，它们在段描述符寄存器中的字段（base, limit, and attribute）被忽略了。某些形式的段装载指令也是无效的（例如LDS, POP ES）。引用ES、DS或SS段的地址计算被视为段基<br>为零。<br>处理器检查所有线性地址引用都是典型的形式，而不是执行极限检查。模式切换并不改变段寄存器或相关描述符寄存器的内容。在64位模式执行过程中，这些寄存器也不会改变，除非执行显式段加载。<br>为了给应用程序设置兼容模式，段加载指令（MOV to Sreg, POP Sreg）在64位模式下正常工作。从系统描述符表（GDT或LDT）中读取一个条目，并加载到段描述符的隐藏部分。描述符寄存器的基数、极限和属性字段都被加载。然而，数据和堆栈段选择器以及描述符寄存器的内容被忽略。<br>当FS和GS段重写在64位模式下使用时，它们各自的基础地址被用于线性地址计算中使用。(FS或GS).base + index + displacement。然后，FS.base和GS.base会被扩展到整个实现所支持的线性地址大小。由此产生的有效地址计算可以跨越正负地址；产生的线性地址必须是规范的。<br>在64位模式下，使用FS段和GS段覆盖的内存访问不会被检查是否有运行时限制也不受属性检查的影响。正常的段加载（MOV to Sreg和POP Sreg）到FS和GS中加载一个在段描述符寄存器的隐藏部分加载一个标准的32位基础值。标准32位以上的基址位以上的基址位被清除为0，以保证使用少于64位的实现方式的一致性。<br>FS.base和GS.base的隐藏描述符寄存器字段被物理映射到MSR，以便加载64位实现支持的所有地址位。64位实现所支持的所有地址位。CPL=0的软件（特权软件）可以使用WRMSR将所有支持的线性地址位加载到FS.base或GS.base。写入64位FS.base和GS.base寄存器中的地址必须是典型的形式。如果WRMSR指令试图向这些寄存器写入非经典地址的WRMSR指令会导致#GP故障。<br>当处于兼容模式时，FS和GS的重写操作与32位模式行为的定义无关。值加载到隐藏描述符寄存器基字段的前32位线性地址位。兼容性模式在计算有效地址时忽略上面的32位。<br>一个新的64位模式指令，SWAPGS，可以用来加载GS base。SWAPGS将IA32_KernelGSbase MSR中的内核数据结构指针与GS base寄存器交换。然后，内核可以使用GS前缀对正常的内存引用来访问内核的数据结构。试图向IA32_KernelGSbase MSR写一个非正则的值（使用WRMSR）会导致一个#GP故障。</p>
<h3 id="Segment-Descriptors-段描述子"><a href="#Segment-Descriptors-段描述子" class="headerlink" title="Segment Descriptors(段描述子)"></a>Segment Descriptors(段描述子)</h3><p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220404161935629.png" alt="image-20220404161935629"></p>
<p>段描述符是GDT或LDT中的一个数据结构，为处理器提供段的大小和位置以及访问控制和状态信息。段落描述符通常是由编译器、链接器、加载器、操作系统或执行器，但不是应用程序创建的。</p>
<p>段落描述符中的标志和字段如下:</p>
<p><strong>分段限制字段</strong><br>指定段的大小。处理器把两个段限制字段放在一起，形成一个 一个20位的值。处理器以两种方式之一解释段限制，这取决于G（粒度）标志的设置：</p>
<ul>
<li>如果粒度标志是清除的，段的大小可以从1字节到1MByte，以字节为单位递增。</li>
<li>如果颗粒度标志被设置，段的大小可以从4KB字节到4GB字节，以4KB字节为增量。</li>
</ul>
<p>处理器以两种不同的方式使用段的限制，取决于段是一个向上扩展的段或一个向下扩展的段。对于扩大的段，<br>在逻辑地址中的偏移量可以从0到段的极限范围。大于段限制的偏移量产生一般保护异常（#GP，用于SS以外的所有段）或堆栈故障异常（#SS用于SS段）。对于向下扩展的段，段限具有相反的功能。<br>偏移量可以从段限加1到FFFFFFFH或FFFFFFH，取决于B标志的设置。小于或等于段限制的偏移量产生一般保护异常或堆栈故障异常。减少一个扩展段的段限值字段的值，在段的地址空间的底部分配新的内存，而不是在顶部。<br>IA-32架构的堆栈总是向下增长，使得这种机制对于可扩展堆栈。</p>
<p><strong>基准地址字段</strong><br>定义段的第0字节在4-GByte线性地址空间中的位置。处理器将三个基础地址字段放在一起，形成一个32位的数值。段的基址应与16字节的边界对齐，尽管16字节对齐不是必须的。这种对齐方式允许程序通过在16字节边界上对齐代码和数据来最大限度地提高性能。</p>
<p><strong>类型字段</strong></p>
<p>表示段或门的类型，并指定可以对该段进行的访问类型和增长方向。这个字段的解释取决于描述符类型标志指定的是应用（代码或数据）描述符还是系统描述符。类型字段的类型字段的编码对代码、数据和系统描述符是不同的。</p>
<p><strong>S（描述符类型）标志</strong><br>指定段描述符是用于系统段（S标志为清除）还是用于代码或数据段（S标志为设置）。<br><strong>DPL（描述符权限级别）字段</strong><br>指定段的权限级别。特权级别的范围是0到3，其中0是最高的级别。<br><strong>P（段存在）标志</strong><br>指示段是否存在于内存中（设置）或不存在（清除）。如果这个标志是清除的，当指向段描述符的段选择器出现时，处理器会产生一个段不存在的异常（#NP）。内存管理软件可以使用这个标志来控制哪些段在给定的时间内被实际加载到物理内存中。它为管理虚拟内存提供了一个除分页之外的控制。当该标志被清除时，操作系统或执行程序可以自由地使用标记为 “可用 “的位置来存储自己的数据，例如关于丢失的段的位置的信息。<br><strong>D/B（默认操作大小/默认堆栈指针大小和/或上界）标志</strong><br>执行不同的功能，取决于段描述符是否是可执行的代码段、扩展的数据段、或者是其他的段，一个扩展的数据段，或者一个堆栈段。(对于32位的代码和数据段，这个标志应该总是设置为1，对于16位的代码和数据段，这个标志应该设置为0）。</p>
<ul>
<li>可执行代码段。该标志被称为D标志，它指示了有效地址和操作数的默认长度。如果该标志被设置，32位的地址和32位或8位的操作数；如果它被清除，16位的地址和16位或8位操作数。指令前缀66H可以用来选择默认以外的操作数，而指令前缀67H可以用来选择一个非默认的地址大小。</li>
<li>堆栈段（由SS寄存器指向的数据段）。该标志被称为B（大）标志。它指定了用于隐式堆栈操作的堆栈指针的大小（如push, pops, and calls）。如果该标志被设置，则使用一个32位的堆栈指针，该指针被存储在32位的ESP寄存器中；如果该标志被清除，则使用16位的堆栈指针，该指针被存储在16位的SP寄存器中。如果堆栈段被设置为一个向下扩展的数据段（在下一段中描述下一段描述），B标志也指定了堆栈段的上界。</li>
<li>扩大-缩小数据段。该标志被称为B标志，它指定了段的上限。如果该标志被设置，上界是FFFFFFFH（4GB字节）；如果该标志被清除，上限是FFFFFFFF（64KB）。</li>
</ul>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220404164628034.png" alt="image-20220404164628034"></p>
<h2 id="描述符的分类"><a href="#描述符的分类" class="headerlink" title="描述符的分类"></a>描述符的分类</h2><p>段描述符分类</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220404171152577.png" alt="image-20220404171152577"></p>
<p>段描述符是GDT和LDT中的一个数据结构项，用于向处理器提供有关一个段的位置、大小以及访问控制的状态信息。每个段描述符的长度是8个字节，含有3个主要字段：</p>
<ul>
<li>段基地址</li>
<li>段限长</li>
<li>段属性</li>
</ul>
<p>段描述符通常由编译器，链接器，加载器或者操作系统来创建，但绝不是应用程序。</p>
<p>段描述符通用格式如下所示</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220404170746133.png" alt="image-20220404170746133"></p>
<p>系统段描述符中各个位的含义如下所示</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220404170802198.png" alt="image-20220404170802198"></p>
<h3 id="存储段描述符"><a href="#存储段描述符" class="headerlink" title="存储段描述符"></a>存储段描述符</h3><h4 id="数据段描述符"><a href="#数据段描述符" class="headerlink" title="数据段描述符"></a>数据段描述符</h4><p>当S=1且TYPE字段的最高位（第2个双字的位11）为0时，表明是一个数据段描述符。</p>
<p>下图是数据段描述符的格式。</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220404171430725.png" alt="image-20220404171430725"></p>
<h4 id="代码段描述符"><a href="#代码段描述符" class="headerlink" title="代码段描述符"></a>代码段描述符</h4><p>当S=1且TYPE字段的最高位（第2个双字的位11）为1时，表明是一个代码段描述符。</p>
<p>下图是代码段描述符的格式。</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220404171452192.png" alt="image-20220404171452192"></p>
<h3 id="系统描述符类型"><a href="#系统描述符类型" class="headerlink" title="系统描述符类型"></a>系统描述符类型</h3><p>当段描述符中S标志位(描述符类型)是复位状态(0)的话，那么该描述符是一个系统描述符。处理器能够识别以下一些类型的系统段描述符:</p>
<ul>
<li>局部描述符表(LDT)的段描述符</li>
<li>任务状态段（TSS）描述符</li>
<li>调用门描述符</li>
<li>中断门描述符</li>
<li>陷阱门描述符</li>
<li>任务门描述符</li>
</ul>
<p>这些描述符类型可分为两大类: 系统段描述符和门描述符。系统段描述符指向系统段(如LDT或TSS段)，门描述符也就是一个”门”,对应调用、中断或陷阱门，其中含有代码段的选择符和段中程序入口点的指针；对于任务门，其中含有TSS的段选择符。</p>
<p>系统段描述符和门描述符类型字段的编码如下所示:</p>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220404170843601.png" alt="image-20220404170843601"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/28/x86%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E9%A2%84%E8%A7%88-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/28/x86%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E9%A2%84%E8%A7%88-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">x86系统架构预览-读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-28 15:44:58 / Modified: 20:05:31" itemprop="dateCreated datePublished" datetime="2022-03-28T15:44:58+08:00">2022-03-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="x86系统架构概述"><a href="#x86系统架构概述" class="headerlink" title="x86系统架构概述"></a>x86系统架构概述</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[TOC]</p>
<h2 id="系统级体系架构概述"><a href="#系统级体系架构概述" class="headerlink" title="系统级体系架构概述"></a>系统级体系架构概述</h2><p><img src="/2022/03/28/x86%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E9%A2%84%E8%A7%88-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220328160624845.png" alt="image-20220328160624845"></p>
<h3 id="Global-and-Local-Descriptor-Tables-全局和局部描述符表"><a href="#Global-and-Local-Descriptor-Tables-全局和局部描述符表" class="headerlink" title="Global and Local Descriptor Tables(全局和局部描述符表)"></a>Global and Local Descriptor Tables(全局和局部描述符表)</h3><p>​         当在保护模式下操作时，所有的内存访问都要经过<strong>全局描述符表（GDT）</strong>或可选的<strong>本地描述符表（LDT）</strong>，如图2-1所示。这些表包含的条目描述符称为段 。段描述符提供了段的基本地址以及访问权限、类型和使用信息。<br>​        每个段描述符都有一个相关的段选择器。一个段选择器为使用它的软件提供了 一个GDT或LDT的索引（其相关段描述符的偏移量），一个全局/本地标志（决定选择器是否指向GDT或LDT），以及访问权限信息。<br>​       要访问段中的一个字节，必须提供一个段选择器和一个偏移量。段选择器提供访问该段的段描述符（在GDT或LDT中）。从段描述符中，处理器获得该段在线性地址空间中的基本地址。然后，偏移量提供了字节相对于基址的位置。这种机制可以用来访问任何有效的代码、数据或堆栈段。只要该段可以从处理器所处的当前权限级别（CPL）访问。CPL被定义为当前执行的代码段的保护级别。<br>​       见图2-1。图中的实心箭头表示一个线性地址，虚线表示一个段选择器。而点状箭头表示物理地址。为了简单起见，许多段选择器被显示为 直接指向一个段。然而，从段选择器到其相关段的实际路径总是通过GDT或LDT。GDT的基址的线性地址包含在GDT寄存器（GDTR）中；LDT的线性地址包含在LDT寄存器（LDTR）中。</p>
<h4 id="Global-and-Local-Descriptor-Tables-in-IA-32e-Mode"><a href="#Global-and-Local-Descriptor-Tables-in-IA-32e-Mode" class="headerlink" title="Global and Local Descriptor Tables in IA-32e Mode"></a>Global and Local Descriptor Tables in IA-32e Mode</h4><p>​        GDTR 和 LDTR 寄存器在 IA-32e 子模式（64 位模式和兼容模式）中都被扩展到 64 位宽。全局和局部描述符表在64位模式下被扩展以支持64位基地址，（16字节的LDT 描述符持有一个64位的基本地址和各种属性）。在兼容模式下，描述符不被扩展 。</p>
<h3 id="System-Segments-Segment-Descriptors-and-Gates-系统段，段描述符和门"><a href="#System-Segments-Segment-Descriptors-and-Gates-系统段，段描述符和门" class="headerlink" title="System Segments, Segment Descriptors, and Gates(系统段，段描述符和门)"></a>System Segments, Segment Descriptors, and Gates(系统段，段描述符和门)</h3><p>​       除了构成程序或过程执行环境的代码、数据和堆栈段之外，架构还定义了两个系统段：<strong>任务状态段（TSS）</strong>和<strong>LDT</strong>。GDT不被视为。<br>因为它不是通过段选择器和段描述符访问的。TSSs和LDTs有为它们定义了段描述符。该体系结构还定义了一组特殊的描述符，称为门[调用门（call gates），中断门（interrupt gates），陷阱门（trap gates），和 任务门（task gates）]。这些描述符为系统程序和处理程序提供了受保护的通道，这些程序和处理程序可能在与应用程序不同的权限级别上运行。例如，一个调用门的CALL可以提供访问一个代码段中的程序，该代码段与当前代码段处于相同或更低的权限级别（更多权限）。<br>​        为了通过调用门访问一个过程，调用过程提供了调用门的选择器。然后，处理器对调用门进行访问权限检查，将CPL与调用门和调用门所指向的目标代码段的权限级别进行比较。如果对目标代码段的访问是允许的，处理器就会得到目标代码段的段选择器和该代码段的偏移。如果调用需要改变权限级别，处理器也会切换到目标权限级别的堆栈。新堆栈的段选择器是从当前运行任务的TSS中获得的。门也促进了16位和32位代码段之间的转换，反之亦然。</p>
<h4 id="Gates-in-IA-32e-Mode"><a href="#Gates-in-IA-32e-Mode" class="headerlink" title="Gates in IA-32e Mode"></a>Gates in IA-32e Mode</h4><p>在IA-32e模式下，以下描述符是16字节的描述符（扩大到允许64位基数）。LDT描述符、64位TSS、调用门、中断门和陷阱门。调用门促进了64位模式和兼容模式之间的转换。在IA32e模式下不支持任务门。在权限级别改变时，堆栈段选择器不从TSS中读取。相反，它们被设置为NULL。</p>
<h3 id="Task-State-Segments-and-Task-Gates-任务状态段任务门"><a href="#Task-State-Segments-and-Task-Gates-任务状态段任务门" class="headerlink" title="Task-State Segments and Task Gates(任务状态段任务门)"></a>Task-State Segments and Task Gates(任务状态段任务门)</h3><p>​       TSS（见图2-1）定义了一个任务的执行环境的状态。它包括通用寄存器、段寄存器、EFLAGS寄存器、EIP寄存器和段选择器的状态-指向三个堆栈段（每个权限级别有一个堆栈）。TSS还包括段选择器 ，用于与任务相关的LDT和分页结构层次的基址。<br>​       所有受保护模式下的程序执行都发生在一个任务（称为当前任务）的上下文中。<br>​      当前任务的TSS的段选择器被存储在任务寄存器中。最简单的切换方法是调用或跳转到一个新的任务。这里，新任务的TSS的段选择器是在CALL或JMP指令中给出的。在切换任务时，处理器会执行以下动作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 将当前任务的状态存储在当前TSS中。</span><br><span class="line">2. 用新任务的段选择器加载任务寄存器。</span><br><span class="line">3. 通过GDT中的段描述符访问新的TSS。</span><br><span class="line">4. 将新任务的状态从新的TSS加载到通用寄存器、段寄存器中、LDTR，控制寄存器CR3（分页结构层次的基址），EFLAGS寄存器，以及EIP寄存器。</span><br><span class="line">5. 开始执行新的任务。一个任务也可以通过一个任务门来访问。任务门类似于调用门，只是它提供了访问 (通过段选择器)访问一个TSS而不是一个代码段。</span><br></pre></td></tr></table></figure>
<h4 id="Task-State-Segments-in-IA-32e-Mode"><a href="#Task-State-Segments-in-IA-32e-Mode" class="headerlink" title="Task-State Segments in IA-32e Mode"></a>Task-State Segments in IA-32e Mode</h4><p>在IA-32e模式下不支持硬件任务开关。然而，TSSs继续存在。TSS的基本地址由其描述符指定。一个64位的TSS持有以下对64位操作很重要的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 每个特权级别的堆栈指针地址</span><br><span class="line">- 中断堆栈表的指针地址</span><br><span class="line">- IO-permission位图的偏移地址（从TSS基数开始）。</span><br><span class="line">  在IA-32e模式下，任务寄存器被扩展为容纳64位基址。</span><br></pre></td></tr></table></figure>
<h3 id="Interrupt-and-Exception-Handling-中断和异常处理"><a href="#Interrupt-and-Exception-Handling-中断和异常处理" class="headerlink" title="Interrupt and Exception Handling(中断和异常处理)"></a>Interrupt and Exception Handling(中断和异常处理)</h3><p>​          外部中断、软件中断和异常是通过中断描述符表（IDT）处理的。IDT存储了一个门描述符的集合，提供对中断和异常处理程序的访问。与 GDT一样，IDT不是一个段。IDT基础的线性地址包含在IDT寄存器（IDTR）中。IDT中的门描述符可以是中断、陷阱、或任务门描述符。要访问一个中断或异常处理程序 ，处理器首先从内部硬件、外部中断控制器或软件中接收一个中断向量（中断号）。中断控制器，或通过INT、INTO、INT 3或BOUND指令从软件接收一个中断向量（中断号）。中断向量 提供了一个进入IDT的索引。如果选择的门描述符是一个中断门或陷阱门，相关的处理程序就会被访问。处理程序的访问方式与通过调用门调用程序的方式类似。如果描述符是一个<br>任务门，处理程序将通过一个任务开关被访问。</p>
<h4 id="Interrupt-and-Exception-Handling-IA-32e-Mode"><a href="#Interrupt-and-Exception-Handling-IA-32e-Mode" class="headerlink" title="Interrupt and Exception Handling IA-32e Mode"></a>Interrupt and Exception Handling IA-32e Mode</h4><p>在IA-32e模式下，中断描述符被扩展到16个字节，以支持64位基本地址。IDTR寄存器被扩展为容纳64位基地址。不支持任务门。</p>
<h3 id="Memory-Management-内存管理"><a href="#Memory-Management-内存管理" class="headerlink" title="Memory Management(内存管理)"></a>Memory Management(内存管理)</h3><p>​        系统架构支持内存的直接物理寻址或虚拟内存（通过分页）。<br>​        当使用物理寻址时，线性地址被当作物理地址处理。当使用分页时：所有的代码、数据、堆栈和系统段（包括GDT和IDT）可以被分页，只有最近访问的 页被保存在物理内存中。物理内存中的页面（有时称为页框）的位置包含在分页结构中。这些结构位于物理内存中。<br>​        分页结构层次结构的基本物理地址包含在控制寄存器CR3中。分页结构中的条目决定了 一个分页框的物理地址、访问权限和内存管理信息。为了使用这种分页机制，一个线性地址被分解成几个部分。这些部分提供了进入分页结构和页框的单独偏移。一个系统可以有一个单一的分页结构层次，也可以有几个。例如 ，每个任务可以有自己的层次结构。</p>
<h4 id="Memory-Management-in-IA-32e-Mode"><a href="#Memory-Management-in-IA-32e-Mode" class="headerlink" title="Memory Management in IA-32e Mode"></a>Memory Management in IA-32e Mode</h4><p>在IA-32e模式下，物理内存页由一组系统数据结构管理。在兼容模式 和64位模式下，使用四级系统数据结构。这些结构包括 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 第4级页面映射（PML4）--PML4表中的一个条目包含了一个页面的基点的物理地址目录指针表、访问权限和内存管理信息。PML4的基本物理地址被存储在CR3中。</span><br><span class="line">- 一组页目录指针表 - 页目录指针表中的一个条目包含了页目录指针表基的物理地址。</span><br><span class="line">- 一组页目录 - 页目录表中的一个条目包含了一个页目录表基的物理地址、访问权限和内存管理信息。</span><br><span class="line">- 成套的页表 - 一个页表中的条目包含了一个页框的物理地址，访问权限和内存管理信息。</span><br></pre></td></tr></table></figure>
<h3 id="System-Registers-系统寄存器"><a href="#System-Registers-系统寄存器" class="headerlink" title="System Registers(系统寄存器)"></a>System Registers(系统寄存器)</h3><p>为了帮助初始化处理器和控制系统操作，系统结构在EFLAGS寄存器中提供了系统标志和几个系统寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- EFLAGS寄存器中的系统标志和IOPL字段控制任务和模式的切换，中断处理，指令跟踪和访问权限。</span><br><span class="line">- 控制寄存器（CR0、CR2、CR3和CR4）包含各种控制系统级操作的标志和数据域。这些寄存器中的其他标志被用来表示对操作系统或执行器中特定处理器能力的支持。</span><br><span class="line">- 调试寄存器允许设置断点以用于调试程序和系统软件。</span><br><span class="line">- GDTR、LDTR和IDTR寄存器包含了它们各自表的线性地址和大小（限制）。</span><br><span class="line">- 任务寄存器包含了当前任务的线性地址和TSS的大小。</span><br><span class="line">- 特定型号的寄存器。这些寄存器控制一些项目，如调试扩展。</span><br><span class="line">  这些寄存器的数量和功能在英特尔64和IA-32处理器系列的不同成员中是不同的。</span><br></pre></td></tr></table></figure>
<h4 id="System-Registers-in-IA-32e-Mode"><a href="#System-Registers-in-IA-32e-Mode" class="headerlink" title="System Registers in IA-32e Mode"></a>System Registers in IA-32e Mode</h4><p>​        在IA-32e模式下，四个系统描述符表寄存器（GDTR、IDTR、LDTR和TR）在硬件上被扩展为<br>以容纳64位的基本地址。EFLAGS成为64位的RFLAGS寄存器。CR0-CR4被扩展到64位。CR8变得可用。CR8提供了对任务优先级寄存器（TPR）的读写访问，这样操作系统就可以控制外部设备的优先级。在64位模式下，调试寄存器DR0-DR7为64位。在兼容模式下，DR0-DR3的地址匹配也是以64位粒度进行的。在支持IA-32e模式的系统上，扩展功能启用寄存器（IA32_EFER）是可用的。这个特定型号的寄存器控制IA-32e模式的激活和其他IA-32e模式的操作。此外，还有几个特定型号的寄存器管理 IA-32e 模式指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- IA32_KernelGSbase - 由 SWAPGS 指令使用。</span><br><span class="line">- IA32_LSTAR - 由 SYSCALL 指令使用。</span><br><span class="line">- IA32_SYSCALL_FLAG_MASK - 由SYSCALL指令使用。</span><br><span class="line">- IA32_STAR_CS - 由SYSCALL和SYSRET指令使用。</span><br></pre></td></tr></table></figure>
<h3 id="Other-System-Resources"><a href="#Other-System-Resources" class="headerlink" title="Other System Resources"></a>Other System Resources</h3><p>除了前几节描述的系统寄存器和数据结构，系统结构还提供了以下的额外资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 操作系统指令</span><br><span class="line">- 性能监测计数器</span><br><span class="line">- 内部缓存和缓冲区</span><br><span class="line">  等</span><br></pre></td></tr></table></figure>
<h2 id="实模式和保护模式转换"><a href="#实模式和保护模式转换" class="headerlink" title="实模式和保护模式转换"></a>实模式和保护模式转换</h2><p>二者根本区别为：进程内存受保护与否</p>
<p> 保护模式 - 这是处理器的原生操作模式。它提供了一套丰富的结构特性、灵活性、高性能和对现有软件基础的向后兼容性。</p>
<p>真实地址模式 - 这种操作模式提供了英特尔8086处理器的编程环境，并有一些扩展（如切换到受保护或系统管理模式的能力）。</p>
<h3 id="实模式工作原理"><a href="#实模式工作原理" class="headerlink" title="实模式工作原理"></a>实模式工作原理</h3><p>实模式出现于早期8088CPU时期。当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器。所以为了能够通过这些16位的寄存器去构成20位的主存地址，必须采取一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(段基址：段偏移量)</span><br></pre></td></tr></table></figure>
<p>其中第一个字段是段基址，它的值是由段寄存器提供的。</p>
<p>第二字段是段内偏移量，代表你要访问的这个内存地址距离这个段基址的偏移。它的值就是由通用寄存器来提供的，所以也是16位。</p>
<p>CPU采用把段寄存器所提供的段基址先向左移4位。这样就变成了一个20位的值，然后再与段偏移量相加，即可组合成一个二十位的地址。即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址 = 段基址&lt;&lt;4 + 段内偏移</span><br></pre></td></tr></table></figure>
<h3 id="保护模式工作原理"><a href="#保护模式工作原理" class="headerlink" title="保护模式工作原理"></a>保护模式工作原理</h3><p>随着CPU的发展，CPU的地址线的个数也从原来的20根变为现在的32根，所以可以访问的内存空间也从1MB变为现在4GB，寄存器的位数也变为32位。所以实模式下的内存地址计算方式就已经不再适合了。所以就引入了现在的保护模式，实现更大空间的，更灵活也更安全的内存访问。</p>
<p>在保护模式下，CPU的32条地址线全部有效，可寻址高达4G字节的物理地址空间; 但是我们的内存寻址方式还是得兼容老办法，即(段基址：段偏移量)的表示方式。当然此时CPU中的通用寄存器都要换成32位寄存器(除了段寄存器)来保证寄存器能访问所有的4GB空间。</p>
<p>我们的偏移值和实模式下是一样的，就是变成了32位而已，而段值仍旧是存放在原来16位的段寄存器中，但是这些段寄存器存放的却不再是段基址了，毕竟之前说过实模式下寻址方式不安全，我们在保护模式下需要加一些限制，而这些限制可不是一个寄存器能够容纳的，于是我们把这些关于内存段的限制信息放在一个叫做<strong>全局描述符表(GDT)</strong>的结构里。全局描述符表中含有一个个表项，每一个表项称为<strong>段描述符。</strong>而段寄存器在保护模式下存放的便是相当于一个数组索引的东西，通过这个索引，可以找到对应的表项。段描述符存放了段基址、段界限、内存段类型属性(比如是数据段还是代码段,注意<strong>一个段描述符只能用来定义一个内存段</strong>)等许多属性,具体信息见下图：</p>
<p><img src="/2022/03/28/x86%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E9%A2%84%E8%A7%88-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220328193206147.png" alt="image-20220328193206147"></p>
<p>其中，段界限表示段边界的扩张最值，即最大扩展多少或最小扩展多少，用20位来表示，它的单位可以是字节，也可以是4KB，这是由G位决定的(G为1时表示单位为4KB)。</p>
<p>实际段界限边界值=(描述符中的段界限+1)*（段界限的单位大小(即字节或4KB))-1，如果偏移地址超过了段界限，CPU会抛出异常。</p>
<p>全局描述符表位于内存中，需要用专门的寄存器指向它后， CPU 才知道它在哪里。这个专门的寄存器便是<strong>GDTR</strong>(一个48位的寄存器),专门用来存储 GDT 的内存地址及大小。</p>
<p>还需要介绍一个新的概念：段的选择子。段寄存器 CS、 DS、 ES、 FS、 GS、 SS，在实模式下时，段中存储的是段基地址，即内存段的起始地址。 而在保护模式下时，由于段基址已经存入了段描述符中，所以段寄存器中再存放段基址是没有意义的，在段寄存器中存入的是一个叫作选择子的东西。选择子“基本上”是个索引值。由于段寄存器是 16 位，所以选择子也是 16 位，在其低 2 位即第 0～1 位， 用来存储 RPL，即请求特权级，可以表示 0、 1、 2、 3 四种特权级。在选择子的第 2 位是 TI 位，即 Table Indicator，用来指示选择子是在 GDT 中，还是 LDT 中索引描述符。 TI 为 0 表示在 GDT 中索引描述符， TI 为 1 表示在 LDT 中索引描述符。选择子的高 13 位，即第 3～15 位是 描述符的索引值，用此值在 GDT 中索引描述符。前面说过 GDT 相当于一个描述符数组，所以此选择子中的索引值就是 GDT 中的下标。选择子结构如下：</p>
<p><img src="/2022/03/28/x86%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E9%A2%84%E8%A7%88-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220328193601767.png" alt="image-20220328193601767"></p>
<p>此外， 扩充的存储器分段管理机制和可选的存储器分页管理机制，不仅为存储器共享和保护提供了硬件支持，而且为实现虚拟存储器提供了硬件支持; 支持多任务，能够快速地进行任务切换(switch)和保护任务环境(context); 4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码和数据的安全和保密及任务的隔离; 支持虚拟8086方式，便于执行8086程序。</p>
<h3 id="实模式到保护模式的切换"><a href="#实模式到保护模式的切换" class="headerlink" title="实模式到保护模式的切换"></a>实模式到保护模式的切换</h3><p>从实模式切换到保护模式大致可以分为以下几个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、屏蔽中断</span><br><span class="line"></span><br><span class="line">2、初始化全局描述符表（GDT）</span><br><span class="line"></span><br><span class="line">3、将CR0寄存器最低位置1</span><br><span class="line"></span><br><span class="line">4、执行远跳转</span><br><span class="line"></span><br><span class="line">5、初始化段寄存器和栈指针</span><br></pre></td></tr></table></figure>
<h4 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h4><p>在16位实模式下的中断由BIOS处理，进入保护模式后，中断将交给中断描述符表IDT里规定的函数处理，在刚进入保护模式时IDTR寄存器的初始值为0，一旦发生中断（例如BIOS的时钟中断）就将导致CPU发生异常，所以需要首先屏蔽中断。屏蔽中断可以使用cli指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli</span><br></pre></td></tr></table></figure>
<h4 id="初始化GDT"><a href="#初始化GDT" class="headerlink" title="初始化GDT"></a>初始化GDT</h4><p>在32位保护模式中，段与段之间是互相隔离的，当访问的地址超出段的界限时处理器就会阻止这种访问，因此每个段都需要有起始地址、范围、访问权限以及其他属性四个部分，这四个部分合在一起叫做段描述符（Segment Descriptor），总共需要8个字节来描述。但Intel为了保持向后兼容，将段寄存器仍然规定为16-bit，显然我们无法用16-bit的段寄存器来直接存储64-bit的段描述符。 </p>
<p>解决的办法是将所有64-bit的段描述符放到一个数组中，将16-bit段寄存器的值作为下标来访问这个数组（以字节为单位），获取64-bit的段描述符，这个数组就叫是全局描述符表</p>
<h4 id="将CR0最低位置1"><a href="#将CR0最低位置1" class="headerlink" title="将CR0最低位置1"></a>将CR0最低位置1</h4><p>CR0是系统内的32位控制寄存器之一，可以控制CPU的一些重要特性。其中最低位是保护允许位（Protected Mode Enable, PE），PE位置1后CPU进入保护模式（注意此时还是16位保护模式，不是32位保护模式），置0时则为实模式。现在我们要进入保护模式，即将CR0的最低位置1，汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-把 cr0 的最低位置为 1，开启保护模式</span><br><span class="line">mov eax, cr0</span><br><span class="line">or eax, 0x1</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>
<h4 id="执行远跳转"><a href="#执行远跳转" class="headerlink" title="执行远跳转"></a>执行远跳转</h4><p>将cr0最低位置1后，CPU就进入了保护模式，此时需要马上执行一条远跳转指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 08h:PModeMain</span><br></pre></td></tr></table></figure>
<p>这条指令有两个作用，第一个作用是将cs段寄存器的值修改为08h，切换到保护模式后，CPU寻址的方式就从实模式中的段地址 * 16 + 偏移地址改为了通过gdt寻址，所以这里的08h是段选择子而不是段地址，并且远跳转指令会自动将cs的值修改为对应的段选择子，这里是08h。</p>
<p>远跳转的另一个作用是清空CPU的流水线，流水线的作用在计组中有提到过，为了加速指令的执行，CPU在执行当前指令时会同时加载并解析接下来的一些指令，在进入保护模式之前，已经有许多指令进入了流水线，这些指令都是按16位模式处理的，而进入保护模式后的指令都是32位，所以这里通过一个远跳转来让CPU清空流水线。</p>
<p>切换到32位模式后，就应该执行32位的指令了，所以从PModeMain开始的指令都采用32位模式编译，通过[bits 32]这个标记实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">PModeMain:</span><br></pre></td></tr></table></figure>
<h4 id="初始化段寄存器和栈指针"><a href="#初始化段寄存器和栈指针" class="headerlink" title="初始化段寄存器和栈指针"></a>初始化段寄存器和栈指针</h4><p>上一步中我们将代码段寄存器cs初始化成了0x08，现在我们还需要初始化其他的段寄存器如数据段寄存器ds，拓展段寄存器es，栈段ss以及fs，gs两个由操作系统使用的段。 </p>
<p>另外我们还需要初始化栈指针ebp和esp，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">PModeMain:</span><br><span class="line">    mov ax, 0x10        ; 将数据段寄存器ds和附加段寄存器es置为0x10</span><br><span class="line">    mov ds, ax         </span><br><span class="line">    mov es, ax</span><br><span class="line">    mov fs, ax          ; fs和gs寄存器由操作系统使用，这里统一设成0x10</span><br><span class="line">    mov gs, ax</span><br><span class="line">    mov ax, 0x18        ; 将栈段寄存器ss置为0x18</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov ebp, 0x7c00     ; 现在栈顶指向 0x7c00</span><br><span class="line">    mov esp, ebp</span><br></pre></td></tr></table></figure>
<h3 id="需要修改的内容"><a href="#需要修改的内容" class="headerlink" title="需要修改的内容"></a>需要修改的内容</h3><ul>
<li><p>GDT初始化：定义段描述符、定义GDTR的数据结构、定义GDT选择子</p>
</li>
<li><p>数据段+堆栈段</p>
</li>
<li><p>16位代码段（实模式下）的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.设置代码运行环境，即给相关寄存器赋值；</span><br><span class="line">2.初始化16位代码段描述符 + 32位代码段描述符 + 堆栈段描述符 +数据段描述符；</span><br><span class="line">3.初始化全局描述符表寄存器GDTR的内容，因为其基地址还没有初始化， 然后通过lgdt [GdtPtr]，将内存中GDTR的内容加载到GDTR中，重点在于保存 GDT的基地址；</span><br><span class="line">4.关中断， 即设置CPU不响应任何其他的外部中断，因为CPU现在的时间片只属于当前加载的程序；</span><br><span class="line">5.打开地址线A20；</span><br><span class="line">6将CR0的 PE 位置1；PE位==1，表明CPU运行在保护模式下；</span><br><span class="line">7.跳转到保护模式： jmp dword SelectorCode32:0 ，这里的代码指提供了选择子，（2.3）末部分，已经说明了为什么通过选择子就可以索引到 32位代码段 LABEL_SEG_CODE32；（这就是从实模式跳入保护模式）</span><br></pre></td></tr></table></figure>
</li>
<li><p>32位代码段（由实模式跳入，即保护模式）的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.将对应选择子赋值到 对应寄存器， 即设置任务代码的运行环境，不得不提的是本段代码还改变了ss和esp，则在32位代码段中所有的堆栈操作将会在新增的堆栈段中进行；</span><br><span class="line">2.做任务；</span><br><span class="line">3.任务做完后，跳转到16位代码段，因为从保护模式跳回实模式，只能从16位代码段中跳回；</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="80x86系统指令寄存器"><a href="#80x86系统指令寄存器" class="headerlink" title="80x86系统指令寄存器"></a>80x86系统指令寄存器</h2><h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p><img src="/2022/03/28/x86%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E9%A2%84%E8%A7%88-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220328194436597.png" alt="image-20220328194436597"></p>
<p>  EFLAGS系统标志和IOPL字段控制I/O，可屏蔽的硬件中断、调试、任务切换和虚拟8086模式。仅允许特权代码（通常为操作系统过执行代码）修改这些位。</p>
<p>​       在64位模式下，RFLAGS寄存器扩展为64位，保留高32位。PFLAGS中系统标志（64位模式）或EFLAGS（兼容模式）。在IA-32e模式下，处理器不允许设置VM位，因为不支持virtual-8086模式（尝试设置该位将被忽略）。同样，处理器将不会设置NT位。但是处理器确实允许软件将NT位置1（请注意，如果将NT位置1，则IRET会在IA-32e模式下引起一般性保护故障）。在IA-32e模式下，YSCALL/SYSRET指令具有一种可编程的方法来指定哪些位是已RFLAGS/EFLAGS中清除。这些说明保存/恢复EFLAGS/RFLAGS。</p>
<h3 id="内存管理寄存器"><a href="#内存管理寄存器" class="headerlink" title="内存管理寄存器"></a>内存管理寄存器</h3><p><img src="/2022/03/28/x86%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E9%A2%84%E8%A7%88-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220328194633100.png" alt="image-20220328194633100"></p>
<h4 id="GDTR"><a href="#GDTR" class="headerlink" title="GDTR"></a>GDTR</h4><p>保存基地址（在保护模式下为32位，在IA-32e模式下为64位）和16位表GDT的限制。基地址指定GDT字节0的线性地址；表格限制指定了表中的字节数。LGDT和SGDT指令分别加载和存储GDTR寄存器。开机或重置在处理器中，基地址设置为默认值0，限制设置为0FFFFH。必须有新的基本地址将其作为保护模式操作的处理器初始化过程的一部分加载的GDTR。</p>
<h4 id="LDTR"><a href="#LDTR" class="headerlink" title="LDTR"></a>LDTR</h4><p>​       保留16位段选择器的结伴地址（在保护模式下为32位，在IA-32e模式下为64位）段限制和LDT的描述符属性。基地址指定字节的线性地址LDT段的0，段限制指定段中的字节数。LLDT和SLDT指令分别加载和存储LDTR寄存器的段选择器部分的包含LDT的段必须在GDT中具有段描述符。当LLDT指令加载一个LDTR中的段选择器：LDT描述符中的基地址、限制和描述符属性会自动加载到LDTR中。<br>​       发生任务切换时，LDTR会自动加载LDT的段选择器和描述符为新任务。在写入新的LDT信息之前，不会自动保存LDTR的内容进入寄存器。在处理器加电或重置时，段选择器和基地址被设置为默认值0和限制设置为0FFFFH。</p>
<h4 id="IDTR"><a href="#IDTR" class="headerlink" title="IDTR"></a>IDTR</h4><p>​        寄存器保存基地址（保护模式下为32位，IA-32e模式下为64位）和16位表限制IDT。基地址指定IDT字节0的线性地址，表限制指定数量表中的字节数。LIDT和SIDT指令分别加载和存储IDTR寄存器。开机或重置处理器后，基地址设置为默认值0，限制设置为0FFFFH。然后可以在处理器初始化过程中更改寄存器中的地址和限制。</p>
<h4 id="TR"><a href="#TR" class="headerlink" title="TR"></a>TR</h4><p>​        任务寄存器包含16位段选择器，基地址（在保护模式下为32位，在IA-32e中为64位），段限制和当前任务的TSS的描述符属性。选择器引用TSS、GDT的描述符。基地址指定TSS字节0的线性地址；段限制指定TSS中的字节数。LTR和STR指令分别加载和存储任务寄存器的段选择器部分。当LTR指令将段选择器加载到任务寄存器中时，基址、限制和描述符属性从TSS描述符将自动加载到任务寄存器中。处理器加电或重置时，基地址设置为默认值0，限制设置为0FFFFH。发生任务切换时，任务寄存器会自动加载段选择器和描述符新任务的TSS。在写入的新的TSS之前，不会自动保存任务寄存器的内容信息进去寄存器。</p>
<h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><h4 id="CR0"><a href="#CR0" class="headerlink" title="CR0"></a>CR0</h4><p>包含控制处理器的操作模式和状态的系统控制标志。</p>
<h4 id="CR3"><a href="#CR3" class="headerlink" title="CR3"></a>CR3</h4><p>包含分页结构层次结构基础的物理地址和两个标志（PCD和PWT）。仅指定基址的最高有效位（减去低12位）；低12位地址“0”假定为0.因此，第一个分页结构必须与页面（4KB）对齐边界。PCT和PWT标志控制处理器内部数据中该分页结构的缓存（它们不控制页面目录信息的TLB缓存）。使用物理地址扩展中，CR3寄存器包含页面目录指针表的基地址。在IA-32e模式下，CR3寄存器包含PML4表的基地址。</p>
<h2 id="系统指令"><a href="#系统指令" class="headerlink" title="系统指令"></a>系统指令</h2><p>LGDT加载GDTR寄存器——将GDT基址和限制从内存加载到GDTR寄存器。<br>SGDT存储GDTR寄存器——将GDT基址和GDTR寄存器中的限制存储到内存。<br>LIDT加载IDTR寄存器——将IDT基址和限制从存储器加载到IDTR寄存器中。<br>SIDT加载IDTR寄存器——将IDT寄存器的IDT基址和限制存储到内存中。<br>LLDT加载LDT寄存器——将LDT段选择器和段描述符从内存加载到LDTR，段选择器操作数也可以位于通用寄存器中。<br>SLDT存储LDT寄存器——将LDTR寄存器中的LDT段选择器存储到存储器或存储器中。<br>LTR记载任务寄存器——将TSS的段选择器和段描述符从内存加载到任务寄存器，段选择器操作数也可以位于通用寄存器中。<br>STR存储任务寄存器——将当前任务TSS的段选择器从任务存储器存储到存储器或通用寄存器。</p>
<h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/42309472</span><br><span class="line">https://mp.weixin.qq.com/s/VGhpbZaeyVwq3Ghs2E6eEw</span><br><span class="line">https://zhuanlan.zhihu.com/p/412845339</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/12/%E8%A7%A3%E5%86%B3%E5%B9%BF%E5%91%8A%E5%BC%B9%E7%AA%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/12/%E8%A7%A3%E5%86%B3%E5%B9%BF%E5%91%8A%E5%BC%B9%E7%AA%97/" class="post-title-link" itemprop="url">解决广告弹窗</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-12 20:00:20 / Modified: 20:25:48" itemprop="dateCreated datePublished" datetime="2022-03-12T20:00:20+08:00">2022-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="解决广告弹窗"><a href="#解决广告弹窗" class="headerlink" title="解决广告弹窗"></a>解决广告弹窗</h1><p>对于广告弹窗，我们采取安装火绒安全软件的方式来解决。具体流程如下</p>
<p>打开网站</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.huorong.cn/</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/12/%E8%A7%A3%E5%86%B3%E5%B9%BF%E5%91%8A%E5%BC%B9%E7%AA%97/image-20220312201421955.png" alt="image-20220312201421955"></p>
<p>点击上方一栏的个人产品</p>
<p><img src="/2022/03/12/%E8%A7%A3%E5%86%B3%E5%B9%BF%E5%91%8A%E5%BC%B9%E7%AA%97/image-20220312201439903.png" alt="image-20220312201439903"></p>
<p>点击免费下载</p>
<p>下载安装等步骤正常进行。</p>
<p>安装好之后如下</p>
<p><img src="/2022/03/12/%E8%A7%A3%E5%86%B3%E5%B9%BF%E5%91%8A%E5%BC%B9%E7%AA%97/image-20220312201528490.png" alt="image-20220312201528490"></p>
<p>点击安全工具</p>
<p>点击右上方的弹窗拦截</p>
<p><img src="/2022/03/12/%E8%A7%A3%E5%86%B3%E5%B9%BF%E5%91%8A%E5%BC%B9%E7%AA%97/image-20220312201548894.png" alt="image-20220312201548894"></p>
<p>注：首次点击需要应该需要下载，为正常现象。</p>
<p>到此工作完成。</p>
<p>注：完成之后建议把其他杀毒软件全部卸载。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
