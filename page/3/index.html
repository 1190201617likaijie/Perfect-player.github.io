<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">编译原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-04 10:47:20" itemprop="dateCreated datePublished" datetime="2022-01-04T10:47:20+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-19 10:03:47" itemprop="dateModified" datetime="2022-05-19T10:03:47+08:00">2022-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="存疑"><a href="#存疑" class="headerlink" title="存疑"></a>存疑</h2><p>z=x+1;的中间代码生成</p>
<p>移植问题(已解决)</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220419121711994.png" alt="image-20220419121711994"></p>
<p>虚属性？</p>
<p>中间代码生成，修改</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514151221654.png" alt="image-20220514151221654" style="zoom:25%;"></p>
<p>习题8.4 是否存在和这些规则一致的求值过程</p>
<p>9.1</p>
<p>9 10</p>
<p>12.2 </p>
<p>13.3</p>
<p>14.6</p>
<p>15.4 15.5 </p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>消除左递归</p>
<p>递归下降语法分析器</p>
<p>非递归下降语法分析器</p>
<p>句柄</p>
<p>判断是否为LL文法</p>
<p>LR文法的四种判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关系：LR(0)&lt;SLR(1)&lt;LALR(1)&lt;LR(1)</span><br></pre></td></tr></table></figure>
<p>1.判断LR(0)文法：<br>看项目中是否有归约-归约和移进-归约冲突。<br>如果无冲突则是LR(0)文法（如果是LR(0)文法则四种都是）；如果有冲突则不是LR(0)文法。（就要向下判断）</p>
<p>2.判断SLR(1)文法：<br>a:DFA中存在冲突项目（归约-归约，归约-移进）<br>b:{a1,a2,…,an},FOLLOW(B1),FOLLOW(B2)两两互不相交，（交集=空集）时是SLR(1)项目。<br>【也就是说，同时满足两个条件才是SLR（1）文法】</p>
<p>若不是再向下判断。</p>
<p>3.判断LR(1)文法：<br>构造带向前搜索符的DFA，无归约-归约冲突则是LR(1)文法。</p>
<p>【此处意思是如果有向前搜索符还有冲突的话就不是LR（1）文法，就要再向下判断】</p>
<p>4.判断LALR(1)文法：<br>合并同心集后无（归约-归约）冲突（在之前的基础上）<br>（核相同，向前搜索符不同）</p>
<p>（B-&gt;a,a<br>B-&gt;a,a|b<br>同心集）<br><strong>LR(0)项目集规范族的构造和分析的构造</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/m0_37154839/article/details/80316089</span><br></pre></td></tr></table></figure>
<p>设计SDD</p>
<p>改写SDT</p>
<p>四元式序列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/abc123lzf/article/details/103753507</span><br></pre></td></tr></table></figure>
<p><strong>中间代码生成</strong></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220518170348404.png" alt="image-20220518170348404" style="zoom:50%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220518170539086.png" alt="image-20220518170539086" style="zoom:50%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220518170614471.png" alt="image-20220518170614471" style="zoom:50%;"></p>
<p>赋值语句的翻译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newtemp( )：生成一个新的临时变量t，返回t的地址</span><br><span class="line">gen(code)：生成三地址指令code</span><br><span class="line">lookup(name)：查询符号表返回name 对应的记录</span><br></pre></td></tr></table></figure>
<p>数组引用的翻译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L的综合属性</span><br><span class="line">L.type：L生成的数组元素的类型</span><br><span class="line">L.offset：指示一个临时变量，该临时变量用于累加公式中的ij × wj项，从而计算数组元素的偏移量</span><br><span class="line">L.array：数组名在符号表的入口地址</span><br></pre></td></tr></table></figure>
<p>控制语句的翻译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">继承属性</span><br><span class="line">B.true：是一个地址，该地址用来存放当B为真时控制流转向的指令的标号</span><br><span class="line">B.false：是一个地址，该地址用来存放当B为假时控制流转向的指令的标号</span><br><span class="line">S.next：是一个地址，该地址用来存放紧跟在S代码之后执行的指令(S的后继指令)的标号</span><br></pre></td></tr></table></figure>
<p><strong>回填</strong></p>
<p>非终结符B的综合属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.truelist：指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是当B为真时控制流应该转向的指令的标号</span><br><span class="line">B.falselist：指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是当B为假时控制流应该转向的指令的标号</span><br></pre></td></tr></table></figure>
<p>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">makelist( i )</span><br><span class="line">创建一个只包含i的列表，i是跳转指令的标号，函数返回指向新创建的列表的指针</span><br><span class="line">merge( p1, p2 )</span><br><span class="line">将 p1 和 p2 指向的列表进行合并，返回指向合并后的列表的指针</span><br><span class="line">backpatch( p, i )</span><br><span class="line">将 i 作为目标标号插入到 p所指列表中的各指令中</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextquad：即将生成的下一条指令的标号</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220517011523873.png" alt="image-20220517011523873" style="zoom: 25%;"></p>
<h2 id="什么是编译"><a href="#什么是编译" class="headerlink" title="什么是编译"></a>什么是编译</h2><p>编译：将<strong>高级语言</strong>翻译成<strong>汇编语言</strong>或<strong>机器语言</strong>的过程。</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220104110715843.png" alt="image-20220104110715843" style="zoom:50%;"></p>
<p>预处理器：把存储在不同文件中的源程序聚合在一起；把被称为宏的缩写语句转换为原始语句。</p>
<p>可重定位：在内存中存放的起始位置L不是固定的</p>
<p>加载器：修改可重定位地址；将修改后的指令和数据放到内存中适当的位置。</p>
<p>链接器：将多个可重定位的机器代码文件连接到一起；解决外部内存地址问题</p>
<h3 id="编译系统的结构"><a href="#编译系统的结构" class="headerlink" title="编译系统的结构"></a>编译系统的结构</h3><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220104113047587.png" alt="image-20220104113047587" style="zoom:50%;"></p>
<h3 id="词法分析概述"><a href="#词法分析概述" class="headerlink" title="词法分析概述"></a>词法分析概述</h3><p>词法分析的主要任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词转换成统一的机内表示——词法单元(token)形式。</span><br><span class="line">token:&lt;种别码，属性值&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220105104115216.png" alt="image-20220105104115216" style="zoom:50%;"></p>
<h3 id="语法分析概述"><a href="#语法分析概述" class="headerlink" title="语法分析概述"></a>语法分析概述</h3><p>语法分析器从词法分析器输出的token序列中识别出各类短语，并构造语法分析树。</p>
<h3 id="语义分析概述"><a href="#语义分析概述" class="headerlink" title="语义分析概述"></a>语义分析概述</h3><p>主要任务：</p>
<p>任务一：收集标识符的属性信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">：</span><br><span class="line">种属:简单变量、复合变量(数组，记录)、过程</span><br><span class="line">类型:整型、实型、字符型、布尔型、指针型</span><br><span class="line">存储类型，长度</span><br><span class="line">值</span><br><span class="line">作用域</span><br><span class="line">参数和返回值信息</span><br></pre></td></tr></table></figure>
<p>符号表：用来存放标识符的属性信息的数据结构</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220106095418057.png" alt="image-20220106095418057" style="zoom:50%;"></p>
<p>任务二：语义检查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量或过程未经声明就使用；</span><br><span class="line">变量或过程名重复声明；</span><br><span class="line">运算分量类型不匹配；</span><br><span class="line">操作符与操作数之间的类型不匹配</span><br></pre></td></tr></table></figure>
<h3 id="中间代码生成及编译器后端"><a href="#中间代码生成及编译器后端" class="headerlink" title="中间代码生成及编译器后端"></a>中间代码生成及编译器后端</h3><p>常用的中间表示形式：</p>
<p>三地址码；语法结构树/语法树</p>
<h4 id="三地址码"><a href="#三地址码" class="headerlink" title="三地址码"></a>三地址码</h4><p>三地址码由类似于汇编语言的指令序列组成，每个指令最多有三个操作数。</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220106095933969.png" alt="image-20220106095933969" style="zoom:50%;"></p>
<p>三地址指令的表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">四元式(op,arg1,arg2,result)</span><br><span class="line">三元式(op,arg1,arg2)</span><br><span class="line">间接三元式</span><br></pre></td></tr></table></figure>
<p>目标代码生成以源程序的中间表示形式作为输入，并把它映射到目标语言；目标代码生成的一个重要任务是为程序中使用的变量合理分配寄存器。</p>
<p>代码优化：为改进代码，所进行的等价程序变换，使其运行得更快一些，占用空间更小一些。</p>
<h3 id="编译程序的生成"><a href="#编译程序的生成" class="headerlink" title="编译程序的生成"></a>编译程序的生成</h3><h4 id="编译器的T形图"><a href="#编译器的T形图" class="headerlink" title="编译器的T形图"></a>编译器的T形图</h4><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220419112048151.png" alt="image-20220419112048151" style="zoom:25%;"></p>
<h4 id="自展"><a href="#自展" class="headerlink" title="自展"></a>自展</h4><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220419112803975.png" alt="image-20220419112803975" style="zoom:25%;"></p>
<h4 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h4><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220419112828085.png" alt="image-20220419112828085" style="zoom: 25%;"></p>
<h2 id="语言及其文法"><a href="#语言及其文法" class="headerlink" title="语言及其文法"></a>语言及其文法</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>字母表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个有穷符号集合。</span><br></pre></td></tr></table></figure>
<p>字母表运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">乘积</span><br><span class="line">n次幂</span><br><span class="line">正闭包（正数次幂的并集）</span><br><span class="line">克林闭包(正闭包的基础上加个空串)</span><br></pre></td></tr></table></figure>
<p>串：字母表中符号的一个有穷序列</p>
<p>串的运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">连接，空串是连接运算的单位元</span><br><span class="line">串的幂运算</span><br></pre></td></tr></table></figure>
<h3 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h3><p>文法</p>
<p>$G=(V_T,V_N,P,S)$</p>
<p>$V_T$:终结符集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">终结符是文法所定义的语言的基本符号，有事也称为token</span><br></pre></td></tr></table></figure>
<p>$V_N$：非终结符集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">非终结符是用来表示语法成分的符号，有时也称为&quot;语法变量&quot;</span><br></pre></td></tr></table></figure>
<p>$V_T$与$V_N$不相交，二者相并统称为文法符号集。</p>
<p>P：产生式集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">描述了将终结符和非终结符组合成串的方法</span><br></pre></td></tr></table></figure>
<p>S:开始符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始符号表示的是该文法中最大的语法成分</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220107105320903.png" alt="image-20220107105320903" style="zoom: 25%;"></p>
<p>符号约定</p>
<p>终结符</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220107110153976.png" alt="image-20220107110153976" style="zoom: 25%;"></p>
<p>非终结符</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220107110227112.png" alt="image-20220107110227112" style="zoom: 25%;"></p>
<p>注</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220107110401057.png" alt="image-20220107110401057" style="zoom: 25%;"></p>
<h3 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h3><p>符号串$a<em>0$经过n步推导出$a_n$,可简记为$a_0\Longrightarrow </em>{}^{n}a_n $</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220108100026833.png" alt="image-20220108100026833" style="zoom: 25%;"></p>
<p>句子是不包含非终结符的句型。</p>
<h3 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h3><p>Chomsky文法分类体系</p>
<h4 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h4><p>$\alpha \longrightarrow \beta $</p>
<p>无限制文法，其中$\alpha$中至少包含一个非终结符。</p>
<p>由0型文法G生成的语言称为 <strong>0型语言</strong></p>
<h4 id="1型文法"><a href="#1型文法" class="headerlink" title="1型文法"></a>1型文法</h4><p>$\alpha \longrightarrow \beta $</p>
<p>上下文有关文法，CSG</p>
<script type="math/tex; mode=display">
|\alpha| < |\beta|</script><p>产生式的一般形式:</p>
<script type="math/tex; mode=display">
\alpha_1A\alpha_2\longrightarrow\alpha_1\beta\alpha_2(\beta\ne\varepsilon)</script><h4 id="2型文法"><a href="#2型文法" class="headerlink" title="2型文法"></a>2型文法</h4><p>$\alpha \longrightarrow \beta $</p>
<p>上下文无关文法，CFG</p>
<p>其中$\alpha\in V_N$</p>
<p>产生式的一般形式：</p>
<script type="math/tex; mode=display">
A\longrightarrow \beta</script><h4 id="3型文法"><a href="#3型文法" class="headerlink" title="3型文法"></a>3型文法</h4><p>$\alpha \longrightarrow \beta $</p>
<p>正则文法，RG</p>
<p>右线性文法：$A\longrightarrow wB或A\longrightarrow w$</p>
<p>左线性文法：$A\longrightarrow Bw或A\longrightarrow w$</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220429171644864.png" alt="image-20220429171644864" style="zoom: 25%;"></p>
<h3 id="CFG的分析树"><a href="#CFG的分析树" class="headerlink" title="CFG的分析树"></a>CFG的分析树</h3><p>给定一个句型，其分析树中的每一棵子树的边缘称为该句型的一个短语。</p>
<p>直接短语：高度为2的子树的边缘。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接短语一定是某产生式的右部</span><br><span class="line">但产生式的右部不一定是给定句型的直接短语</span><br></pre></td></tr></table></figure>
<p>二义性文法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果一个文法可以为某个句子生成多颗分析树，则称这个文法是二义性的。</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220109105001704.png" alt="image-20220109105001704" style="zoom:50%;"></p>
<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220109105354813.png" alt="image-20220109105354813" style="zoom: 25%;"></p>
<h3 id="正则定义"><a href="#正则定义" class="headerlink" title="正则定义"></a>正则定义</h3><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220111100400281.png" alt="image-20220111100400281" style="zoom: 25%;"></p>
<h3 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h3><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220111101353306.png" alt="image-20220111101353306" style="zoom: 25%;"></p>
<p><strong>最长子串匹配原则</strong>：当输入串的多个前缀与一个或多个模式匹配时，总是选择最长的前缀进行匹配</p>
<h3 id="有穷自动机的分类"><a href="#有穷自动机的分类" class="headerlink" title="有穷自动机的分类"></a>有穷自动机的分类</h3><p>DFA确定的有穷自动机</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220112104246612.png" alt="image-20220112104246612" style="zoom: 25%;"></p>
<p>NFA非确定的有穷自动机</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220112104402251.png" alt="image-20220112104402251" style="zoom: 25%;"></p>
<p>正则文法与正则表达式与有穷自动机等价</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220112104637911.png" alt="image-20220112104637911" style="zoom: 25%;"></p>
<p>带有空边的NFA与不带空边的NFA有等价性</p>
<h3 id="从正则表达式到有穷自动机"><a href="#从正则表达式到有穷自动机" class="headerlink" title="从正则表达式到有穷自动机"></a>从正则表达式到有穷自动机</h3><p>先构造NFA,再从NFA到DFA。</p>
<p>根据RE构造NFA</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220501150009650.png" alt="image-20220501150009650" style="zoom:25%;"></p>
<p>假设正则表达式r1和r2对应的NFA分别为N(r1)和N(r2)</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220501150031625.png" alt="image-20220501150031625" style="zoom:25%;"></p>
<h3 id="从NFA到DFA的转换"><a href="#从NFA到DFA的转换" class="headerlink" title="从NFA到DFA的转换"></a>从NFA到DFA的转换</h3><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220114100302890.png" alt="image-20220114100302890" style="zoom: 25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220114100719876.png" alt="image-20220114100719876" style="zoom: 25%;"></p>
<h3 id="识别单词的DFA"><a href="#识别单词的DFA" class="headerlink" title="识别单词的DFA"></a>识别单词的DFA</h3><p> 词法分析阶段可检测错误的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单词拼写错误</span><br><span class="line">非法字符</span><br></pre></td></tr></table></figure>
<p>错误恢复策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最简单的错误恢复策略：恐慌模式</span><br><span class="line">从剩余的输入中不断删除字符，直到词法分析器能够在剩余的开头发现一个正确的字符为止。</span><br></pre></td></tr></table></figure>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><h3 id="自顶向下分析概述"><a href="#自顶向下分析概述" class="headerlink" title="自顶向下分析概述"></a>自顶向下分析概述</h3><p>从分析树的顶部向底部方向构造分析树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最左推导：总是选择每个句型的最左非终结符进行替换。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最右推导：总是选择每个句型的最右非终结符进行替换。</span><br></pre></td></tr></table></figure>
<p>在自底向上的分析中，总是采用最左规约的方式，因此把最左规约称为规范规约，而最右推导相应的称为规范推导。</p>
<p>自顶向下选择最左推导。</p>
<h4 id="自顶向下分析存在的问题"><a href="#自顶向下分析存在的问题" class="headerlink" title="自顶向下分析存在的问题"></a>自顶向下分析存在的问题</h4><p>同一非终结符的多个候选式存在共同前缀，将导致回溯现象</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220512192055179.png" alt="image-20220512192055179" style="zoom: 50%;"></p>
<p>左递归文法会使递归下降分析器陷入无限循环</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220512192124252.png" alt="image-20220512192124252" style="zoom:50%;"></p>
<h4 id="消除直接左递归"><a href="#消除直接左递归" class="headerlink" title="消除直接左递归"></a>消除直接左递归</h4><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220512192544030.png" alt="image-20220512192544030" style="zoom: 50%;"></p>
<p>消除直接左递归的一般形式</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220512192836269.png" alt="image-20220512192836269" style="zoom:50%;"></p>
<h4 id="消除间接左递归"><a href="#消除间接左递归" class="headerlink" title="消除间接左递归"></a>消除间接左递归</h4><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220512192935922.png" alt="image-20220512192935922" style="zoom:50%;"></p>
<h4 id="提取左公因子"><a href="#提取左公因子" class="headerlink" title="提取左公因子"></a>提取左公因子</h4><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220512193513607.png" alt="image-20220512193513607" style="zoom:50%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220512193523610.png" alt="image-20220512193523610" style="zoom:50%;"></p>
<h4 id="预测分析"><a href="#预测分析" class="headerlink" title="预测分析"></a>预测分析</h4><p>需要回溯的分析器叫不确定分析器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">预测分析：递归下降分析技术的一个特例，通过在输入中向前看固定个数符号来选择正确的A-产生式。</span><br><span class="line">预测分析不需要回溯，是一种确定的自顶向下分析方法。</span><br></pre></td></tr></table></figure>
<p>可以对某些文法构造出向前看k个输入符号的预测分析器，该类文法有时也称为LL(k) 文法类</p>
<h3 id="预测分析法"><a href="#预测分析法" class="headerlink" title="预测分析法"></a>预测分析法</h3><h4 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h4><p>S_文法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个产生式的右部都以终结符开始</span><br><span class="line">同一非终结符的各个候选式的首终结符都不同</span><br><span class="line">S_文法不含ε产生式</span><br></pre></td></tr></table></figure>
<p>什么时候使用ε产生式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果当前某非终结符A与当前输入符a不匹配时，若存在A→ε，可以通过检查a是否可以出现在 A的后面，来决定是否使用产生式 A→ε（若文法中无 A→ε ，则应报错）</span><br></pre></td></tr></table></figure>
<p>后继符号集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可能在某个句型中紧跟在A后边的终结符a的集合，记为FOLLOW(A)</span><br><span class="line">	FOLLOW(A)=&#123;a| S -&gt;* αAaβ, a∈VT，α,β∈(VT∪VN)*&#125;</span><br><span class="line">如果 A是某个句型的的最右符号，则将结束符“$”添加到FOLLOW(A)中</span><br></pre></td></tr></table></figure>
<p>产生式的可选集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">产生式A→β的可选集是指可以选用该产生式进行推导时对应的输入符号的集合，记为SELECT( A→β )</span><br><span class="line">SELECT( A→aβ ) = &#123; a &#125;</span><br><span class="line">SELECT( A→ε )=FOLLOW( A )</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220512212721662.png" alt="image-20220512212721662" style="zoom:50%;"></p>
<p>q_文法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个产生式的右部或为ε ，或以终结符开始</span><br><span class="line">具有相同左部的产生式有不相交的可选集</span><br><span class="line">q_文法不含右部以非终结符打头的产生式</span><br></pre></td></tr></table></figure>
<p>串首终结符集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个文法符号串α， α的串首终结符集FIRST(α)被定义为可以从α推导出的所有串首终结符构成的集合。如果α * ε，那么ε也在FIRST(α)中</span><br></pre></td></tr></table></figure>
<p>LL(1)文法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当且仅当G的任意两个具有相同左部的产生式A → α | β 满足下面的条件：</span><br><span class="line">不存在终结符a使得α 和β都能够推导出以a开头的串</span><br><span class="line">α 和β至多有一个能推导出ε </span><br><span class="line">如果 β -&gt;* ε，则FIRST (α)∩FOLLOW(A) =Φ；</span><br><span class="line">如果 α -&gt;* ε，则FIRST (β)∩FOLLOW(A) =Φ；</span><br></pre></td></tr></table></figure>
<p>即同一非终结符的各个产生式的可选集互不相交</p>
<p>第一个L表示从左向右扫描输入，第二个L表示最左推导</p>
<p>follow(A)计算方法</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220512220412044.png" alt="image-20220512220412044" style="zoom:50%;"></p>
<p>预测分析表</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220512220850395.png" alt="image-20220512220850395" style="zoom:33%;"></p>
<p>预测分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">递归的方式：基于预测分析表对递归下降分析法进行扩展</span><br><span class="line">非递归的方式：显式地维护一个栈结构来模拟最左推导过程</span><br></pre></td></tr></table></figure>
<h4 id="递归的预测分析法"><a href="#递归的预测分析法" class="headerlink" title="递归的预测分析法"></a>递归的预测分析法</h4><h4 id="非递归的预测分析法"><a href="#非递归的预测分析法" class="headerlink" title="非递归的预测分析法"></a>非递归的预测分析法</h4><p>非递归的预测分析显式地维护一个栈结构，而不是通过递归调用的方式隐式地维护栈。这样的语法分析器可以模拟最左推导过程</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220512221720701.png" alt="image-20220512221720701" style="zoom:33%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220512221741289.png" alt="image-20220512221741289" style="zoom:33%;"></p>
<p>预测分析步骤</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.构造文法</span><br><span class="line">2.改造文法：消除二义性、消除左递归、消除回溯</span><br><span class="line">3.求每个变量的FIRST集和FOLLOW集，从而求得每个候选式的SELECT集</span><br><span class="line">4.检查是不是 LL(1) 文法。若是，构造预测分析表</span><br><span class="line">5.对于递归的预测分析，根据预测分析表为每一个非终结符编写一个过程；对于非递归的预测分析，实现表驱动</span><br><span class="line">  的预测分析算法</span><br></pre></td></tr></table></figure>
<p>二义性判定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于任一个上下文无关文法，不存在一个算法判断其是否为二义性，但能给出一个充分条件，满足则无二义性，不满足也未必有二义性</span><br></pre></td></tr></table></figure>
<h4 id="预测分析中的错误检测"><a href="#预测分析中的错误检测" class="headerlink" title="预测分析中的错误检测"></a>预测分析中的错误检测</h4><p>两种情况下可以检测到错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">栈顶的终结符和当前输入符号不匹配</span><br><span class="line">栈顶非终结符与当前输入符号在预测分析表对应项中的信息为空</span><br></pre></td></tr></table></figure>
<p>错误恢复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">恐慌模式：忽略输入中的一些符号，直到输入中出现由设计者选定的同步词法单元(synchronizing token)集合中的某个词法单元；如果终结符在栈顶而不能匹配，一个简单的办法就是弹出此终结符</span><br></pre></td></tr></table></figure>
<h3 id="自底向上的分析"><a href="#自底向上的分析" class="headerlink" title="自底向上的分析"></a>自底向上的分析</h3><p>自底向上的语法分析采用最左归约方式（反向构造句子的最右推导）</p>
<h4 id="移入-归约分析"><a href="#移入-归约分析" class="headerlink" title="移入-归约分析"></a>移入-归约分析</h4><p>工作过程</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513095056700.png" alt="image-20220513095056700" style="zoom: 25%;"></p>
<p>四种动作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">移入：将下一个输入符号移到栈的顶端</span><br><span class="line">归约：被归约的符号串的右端必然处于栈顶。语法分析器在栈中确定这个串的左端，并决定用哪个非终结符来替换这个串</span><br><span class="line">接收：宣布语法分析过程成功完成</span><br><span class="line">报错：发现一个语法错误，并调用错误恢复子例程</span><br></pre></td></tr></table></figure>
<p>存在问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">归约-归约冲突</span><br><span class="line">移入-归约冲突</span><br></pre></td></tr></table></figure>
<p><strong>归约-归约冲突</strong></p>
<p>造成错误的原因：错误地识别了句柄</p>
<p>句柄：句型的最左直接短语</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513100212940.png" alt="image-20220513100212940" style="zoom:25%;"></p>
<p><strong>移入-归约冲突</strong></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513100150507.png" alt="image-20220513100150507" style="zoom: 25%;"></p>
<h3 id="LR分析法"><a href="#LR分析法" class="headerlink" title="LR分析法"></a>LR分析法</h3><p>是最大的、可以构造出相应移入-归约语法分析器的文法类<br>L: 对输入进行从左到右的扫描<br>R: 反向构造出一个最右推导序列</p>
<p>LR(k)分析<br>需要向前查看k个输入符号的LR分析</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513102223085.png" alt="image-20220513102223085" style="zoom: 25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513102611274.png" alt="image-20220513102611274" style="zoom:25%;"></p>
<p>看PPT例题分析</p>
<h4 id="LR-0-分析"><a href="#LR-0-分析" class="headerlink" title="LR(0) 分析"></a>LR(0) 分析</h4><p>右部某位置标有圆点的产生式称为相应文法的一个LR(0)项目（简称为项目）</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513103304315.png" alt="image-20220513103304315" style="zoom:25%;"></p>
<p>产生式A→ε 只生成一个项目A→ · </p>
<p>增广文法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果G 是一个以S为开始符号的文法，则G的增广文法 G&#x27; 就是在G中加上新开始符号S&#x27; 和产生式S&#x27; → S而得到的文法</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513103407672.png" alt="image-20220513103407672" style="zoom:25%;"></p>
<p>引入这个新的开始产生式的目的是使得文法开始符号仅出现在一个产生式的左边，从而使得分析器只有一个接受状态</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513103852131.png" alt="image-20220513103852131" style="zoom: 25%;"></p>
<p>初始项目：S’→·S</p>
<p>接收项目：S’→S·</p>
<p>归约项目：·在末尾的项目</p>
<p>后继项目：同属于一个产生式的项目，但圆点的位置只相差一个符号，  则称后者是前者的后继项目</p>
<p>A→α· Xβ的后继项目是A→αX·β</p>
<p>可以把等价的项目组成一个项目集( I ) ，称为项目集闭包(Closure of Item Sets)，每个项目集闭包对应着自动机的一个状态</p>
<p>eg：</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513104546195.png" alt="image-20220513104546195" style="zoom: 25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513104843423.png" alt="image-20220513104843423" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513104852180.png" alt="image-20220513104852180" style="zoom:25%;"></p>
<p>LR(0)分析过程的冲突</p>
<p>移进归约冲突</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513105245484.png" alt="image-20220513105245484" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513105343336.png" alt="image-20220513105343336" style="zoom:25%;"></p>
<p>在状态2时，当遇到*号时，不清楚应该移入还是归约。</p>
<p>归约归约冲突</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513105500066.png" alt="image-20220513105500066" style="zoom:25%;"></p>
<p>状态二有两个归约和一个移入，移进/归约冲突和归约/归约冲突混合。</p>
<p>如果LR(0)分析表中没有语法分析动作冲突，那么给定的文法就称为LR(0)文法</p>
<p>不是所有CFG(上下文无关文法)都能用LR(0)方法进行分析，也就是说，CFG不总是LR(0)文法。</p>
<h4 id="SLR-分析"><a href="#SLR-分析" class="headerlink" title="SLR 分析"></a>SLR 分析</h4><p>LR(0)解决不了冲突的原因</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">句柄都是相对一个句型而言的，因此应该将句柄的识别放在句型这样一个上下文环境中考虑</span><br><span class="line">LR(0)考虑了A的上文（规范句型的前缀），但未考虑A的下文，因此消解冲突能力有限</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513135613449.png" alt="image-20220513135613449" style="zoom:25%;"></p>
<p>SLR冲突</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513135724655.png" alt="image-20220513135724655" style="zoom:25%;"></p>
<p>当状态2遇到=时，会有移入归约冲突。</p>
<p>存在问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLR只是简单地考察下一个输入符号b是否属于与归约项目A→α相关联的FOLLOW(A)，但b∈FOLLOW(A)只是归约α的一个必要条件，而非充分条件</span><br></pre></td></tr></table></figure>
<h4 id="LR-1-分析"><a href="#LR-1-分析" class="headerlink" title="LR(1)分析"></a>LR(1)分析</h4><p>在特定位置，A的后继符集合是FOLLOW(A)的子集，而SLR分析法则将其全部考虑了进去。</p>
<p>将一般形式为 [A→α·β, a]的项称为 LR(1) 项，其中A→αβ 是一个产生式，a 是一个终结符(这里将$视为一个特殊的终结符)它表示在当前状态下，A后面必须紧跟的终结符，称为该项的展望符(lookahead)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LR(1) 中的1指的是项的第二个分量的长度</span><br><span class="line">在形如[A→α·β, a]且β ≠ ε的项中，展望符a没有任何作用</span><br><span class="line">但是一个形如[A→α·, a]的项在只有在下一个输入符号等于a时才可以按照A→α 进行归约</span><br><span class="line">这样的a的集合总是FOLLOW(A)的子集，而且它通常是一个真子集</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513143948062.png" alt="image-20220513143948062" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513144511943.png" alt="image-20220513144511943" style="zoom:25%;"></p>
<p>如果除展望符外，两个LR(1)项目集是相同的，则称这两个LR(1)项目集是同心的</p>
<p>LR(1)分析实际上是根据后继符集合的不同，将原始的LR(0)状态分裂成不同的LR(1)状态</p>
<h4 id="LALR分析"><a href="#LALR分析" class="headerlink" title="LALR分析"></a>LALR分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">寻找具有相同核心的LR  (1) 项集，并将这些项集合并为一个项集。 所谓项集的核心就是其第一分量的集合</span><br><span class="line">然后根据合并后得到的项集族构造语法分析表</span><br><span class="line">如果分析表中没有语法分析动作冲突，给定的文法就称为LALR  (1) 文法，就可以根据该分析表进行语法分析</span><br></pre></td></tr></table></figure>
<p>合并同心项集时产生归约-归约冲突的例子</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513145829960.png" alt="image-20220513145829960" style="zoom:25%;"></p>
<p>合并同心项集不会产生移进-归约冲突</p>
<p>合并同心项集后，虽然不产生冲突，但可能会推迟错误的发现</p>
<p>LALR分析法可能会作多余的归约动作，但绝不会作错误的移进操作</p>
<p>LALR(1)的特点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">形式上与LR(1)相同</span><br><span class="line">大小上与LR(0)/SLR相当</span><br><span class="line">分析能力介于SLR和LR(1)二者之间：LR(0)&lt; SLR&lt;LALR(1)&lt;LR(1)</span><br><span class="line">合并后的展望符集合仍为FOLLOW集的子集</span><br></pre></td></tr></table></figure>
<h4 id="二义性文法的LR分析"><a href="#二义性文法的LR分析" class="headerlink" title="二义性文法的LR分析"></a>二义性文法的LR分析</h4><p>每个二义性文法都不是LR的<br>某些类型的二义性文法在语言的描述和实现中很有用</p>
<p>用优先级和结合性解决冲突</p>
<p>应该保守地使用二义性文法，并且必须在严格控制之下使用，因为稍有不慎就会导致语法分析器所识别的语言出现偏差</p>
<h4 id="LR分析中的错误处理"><a href="#LR分析中的错误处理" class="headerlink" title="LR分析中的错误处理"></a>LR分析中的错误处理</h4><p>语法错误的检测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当LR分析器在查询语法分析动作表并发现一个报错条目时，就检测到了一个语法错误</span><br></pre></td></tr></table></figure>
<p>错误恢复策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">恐慌模式错误恢复</span><br><span class="line">短语层次错误恢复</span><br></pre></td></tr></table></figure>
<p>恐慌错误恢复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从栈顶向下扫描，直到发现某个状态si，它有一个对应于某个非终结符A的GOTO目标，可以认为从这个A推导出的串中包含错误</span><br><span class="line">然后丢弃0个或多个输入符号，直到发现一个可能合法地紧跟在A之后的符号a为止</span><br><span class="line">之后将si+1 = GOTO(si , A)压入栈中，继续进行正常的语法分析</span><br><span class="line">实践中可能会选择多个这样的非终结符A。通常这些非终结符代表了主要的程序段，比如表达式、语句或块</span><br></pre></td></tr></table></figure>
<p>短语层次错误恢复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">检查LR分析表中的每一个报错条目，并根据语言的使用方法来决定程序员所犯的何种错误最有可能引起这个语法错误</span><br><span class="line">然后构造出适当的恢复过程</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513151319857.png" alt="image-20220513151319857" style="zoom:25%;"></p>
<h2 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h2><p>语法制导翻译使用CFG来引导对语言的翻译，是一种面向文法的翻译技术</p>
<p>基本思想</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如何表示语义信息：为CFG中的文法符号设置语义属性，用来表示语法成分对应的语义信息</span><br><span class="line">如何计算语义属性：文法符号的语义属性值是用与文法符号所在产生式（语法规则）相关联的语义规则来计算的</span><br><span class="line">对于给定的输入串x ，构建x的语法分析树，并利用与产生式（语法规则）相关联的语义规则来计算分析树中各结点对应的语义属性值</span><br></pre></td></tr></table></figure>
<p>语法制导定义(Syntax-Directed Definitions, SDD)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SDD是对CFG的推广</span><br><span class="line">将每个文法符号和一个语义属性集合相关联</span><br><span class="line">将每个产生式和一组语义规则相关联，这些规则用于计算该产生式中各文法符号的属性值</span><br><span class="line">如果X是一个文法符号，a是X的一个属性，则用X.a表示属性a在某个标号为X的分析树结点上的值</span><br></pre></td></tr></table></figure>
<p>语法制导翻译方案 (Syntax-Directed Translation Scheme , SDT )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDT是在产生式右部嵌入了程序片段的CFG，这些程序片段称为语义动作。一个语义动作在产生式中的位置决定了这个动作的执行时间</span><br></pre></td></tr></table></figure>
<h3 id="语法制导定义SDD"><a href="#语法制导定义SDD" class="headerlink" title="语法制导定义SDD"></a>语法制导定义SDD</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>语法制导定义SDD是对CFG的推广</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将每个文法符号和一个语义属性集合相关联</span><br><span class="line">将每个产生式和一组语义规则相关联，用来计算该产生式中各文法符号的属性值</span><br></pre></td></tr></table></figure>
<p>文法符号的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">综合属性 (synthesized attribute)</span><br><span class="line">继承属性 (inherited attribute)</span><br></pre></td></tr></table></figure>
<p>综合属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在分析树结点 N上的非终结符A的综合属性只能通过 N的子结点或 N本身的属性值来定义</span><br><span class="line">终结符可以具有综合属性。终结符的综合属性值是由词法分析器提供的词法值，因此在SDD中没有计算终结符属性值的语义规则</span><br></pre></td></tr></table></figure>
<p>继承属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在分析树结点 N上的非终结符A的继承属性只能通过 N的父结点、N的兄弟结点或 N本身的属性值来定义</span><br><span class="line">终结符没有继承属性。终结符从词法分析器处获得的属性值被归为综合属性值</span><br></pre></td></tr></table></figure>
<p>属性文法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个没有副作用的SDD有时也称为属性文法</span><br><span class="line">属性文法的规则仅仅通过其它属性值和常量来定义一个属性值</span><br></pre></td></tr></table></figure>
<h4 id="SDD的求值顺序"><a href="#SDD的求值顺序" class="headerlink" title="SDD的求值顺序"></a>SDD的求值顺序</h4><p>语义规则建立了属性之间的依赖关系，在对语法分析树节点的一个属性求值之前，必须首先求出这个属性值所依赖的所有属性值</p>
<p>依赖图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">依赖图是一个描述了分析树中结点属性间依赖关系的有向图</span><br><span class="line">分析树中每个标号为X的结点的每个属性a都对应着依赖图中的一个结点</span><br><span class="line">如果属性X.a的值依赖于属性Y.b的值，则依赖图中有一条从Y.b的结点指向X.a的结点的有向边</span><br></pre></td></tr></table></figure>
<p>eg：<img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513155754626.png" alt="image-20220513155754626" style="zoom:25%;"></p>
<p>属性值计算顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样的排序将一个有向图变成了一个线性排序，这个排序称为这个图的拓扑排序</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于只具有综合属性的SDD ，可以按照任何自底向上的顺序计算它们的值</span><br><span class="line">对于同时具有继承属性和综合属性的SDD，不能保证存在一个顺序来对各个节点上的属性进行求值</span><br><span class="line">如果图中没有环，那么至少存在一个拓扑排序</span><br></pre></td></tr></table></figure>
<h3 id="S-属性定义与L-属性定义"><a href="#S-属性定义与L-属性定义" class="headerlink" title="S-属性定义与L-属性定义"></a>S-属性定义与L-属性定义</h3><p>仅仅使用综合属性的SDD称为S属性的SDD，或S-属性定义、S-SDD</p>
<p>如果一个SDD是S属性的，可以按照语法分析树节点的任何自底向上顺序来计算它的各个属性值</p>
<p>L-属性定义(也称为L属性的SDD或L-SDD)的直观含义：在一个产生式所关联的各属性之间，依赖图的边可以从左到右，但不能从右到左</p>
<p>正式定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个SDD是L-属性定义，当且仅当它的每个属性要么是一个综合属性，要么是满足如下条件的继承属性：假设存在一个产生式A→X1X2…Xn，其右部符号Xi (1&lt;= i &lt;= n)的继承属性仅依赖于下列属性：</span><br><span class="line">A的继承属性</span><br><span class="line">产生式中Xi左边的符号 X1, X2, … , Xi-1 的属性</span><br><span class="line">Xi本身的属性，但Xi 的全部属性不能在依赖图中形成环路</span><br></pre></td></tr></table></figure>
<p>虚属性：就是一个动作，不干其他事情。</p>
<h3 id="语法制导翻译方案SDT"><a href="#语法制导翻译方案SDT" class="headerlink" title="语法制导翻译方案SDT"></a>语法制导翻译方案SDT</h3><p>语法制导翻译方案(SDT )是在产生式右部中嵌入了程序片段(称为语义动作)的CFG</p>
<p>SDD定义了各属性的计算方法（计算规则），SDT进一步明确了各属性的计算时机（计算顺序）</p>
<p>这两种情况下，SDT可在语法分析过程中实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本文法可以使用LR分析技术，且SDD是S属性的</span><br><span class="line">基本文法可以使用LL分析技术，且SDD是L属性的</span><br></pre></td></tr></table></figure>
<h4 id="S-SDD转换为SDT"><a href="#S-SDD转换为SDT" class="headerlink" title="S-SDD转换为SDT"></a>S-SDD转换为SDT</h4><p>将每个语义动作都放在产生式的最后</p>
<p>S-属性定义的SDT 实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果一个S-SDD的基本文法可以使用LR分析技术，那么它的SDT可以在LR语法分析过程中实现</span><br><span class="line">当归约发生时执行相应的语义动作</span><br></pre></td></tr></table></figure>
<p>语法分析器的扩展</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为每个栈记录增加属性值字段，存放文法符号的综合属性值</span><br><span class="line">在每次归约时调用计算综合属性值的语义子程序</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513164603555.png" alt="image-20220513164603555" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513164616906.png" alt="image-20220513164616906" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513164754145.png" alt="image-20220513164754145" style="zoom:25%;"></p>
<h4 id="将L-SDD转换为SDT"><a href="#将L-SDD转换为SDT" class="headerlink" title="将L-SDD转换为SDT"></a>将L-SDD转换为SDT</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将计算某个非终结符号A的继承属性的动作插入到产生式右部中紧靠在A的本次出现之前的位置上</span><br><span class="line">将计算一个产生式左部符号的综合属性的动作放置在这个产生式右部的最右端</span><br></pre></td></tr></table></figure>
<p>如果一个L-SDD的基本文法可以使用LL分析技术，那么它的SDT可以在LL或LR语法分析过程中实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在非递归的预测分析过程中进行语义翻译</span><br><span class="line">在递归的预测分析过程中进行语义翻译</span><br><span class="line">在LR分析过程中进行语义翻译</span><br></pre></td></tr></table></figure>
<h3 id="L-属性定义的自顶向下翻译"><a href="#L-属性定义的自顶向下翻译" class="headerlink" title="L-属性定义的自顶向下翻译"></a>L-属性定义的自顶向下翻译</h3><h4 id="在非递归的预测分析过程中进行翻译"><a href="#在非递归的预测分析过程中进行翻译" class="headerlink" title="在非递归的预测分析过程中进行翻译"></a>在非递归的预测分析过程中进行翻译</h4><p>扩展语法分析栈</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220513205659076.png" alt="image-20220513205659076" style="zoom: 50%;"></p>
<p>看例题</p>
<p>分析栈中的每一个记录都对应着一段执行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">综合记录出栈时，要将综合属性值复制给后面特定的语义动作</span><br><span class="line">变量展开时（即变量本身的记录出栈时），如果其含有继承属性，则要将继承属性值复制给后面特定的语义动作</span><br></pre></td></tr></table></figure>
<h4 id="在递归的预测分析过程中进行翻译"><a href="#在递归的预测分析过程中进行翻译" class="headerlink" title="在递归的预测分析过程中进行翻译"></a>在递归的预测分析过程中进行翻译</h4><p>为每个非终结符A构造一个函数，A的每个继承属性对应该函数的一个形参，函数的返回值是A的综合属性值</p>
<p>对出现在A产生式右部中的每个文法符号的每个属性都设置一个局部变量</p>
<p>例题</p>
<p>算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为每个非终结符A构造一个函数，A的每个继承属性对应该函数的一个形参，函数的返回值是A的综合属性值。对出现在A产生式中的每个文法符号的每个属性都设置一个局部变量</span><br><span class="line">非终结符A的代码根据当前的输入决定使用哪个产生式</span><br></pre></td></tr></table></figure>
<h3 id="L-属性定义的自底向上翻译"><a href="#L-属性定义的自底向上翻译" class="headerlink" title="L-属性定义的自底向上翻译"></a>L-属性定义的自底向上翻译</h3><p>给定一个以LL文法为基础的L-SDD，可以修改这个文法，并在LR语法分析过程中计算这个新文法之上的SDD</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个以LL文法为基础的L-属性定义，可以修改这个文法，并在LR语法分析过程中计算这个新文法之上的SDD</span><br><span class="line">首先构造SDT，在各个非终结符之前放置语义动作来计算它的继承属性， 并在产生式后端放置语义动作计算综合属性</span><br><span class="line">对每个内嵌的语义动作，向文法中引入一个标记非终结符来替换它。每个这样的位置都有一个不同的标记，并且对于任意一个标记M都有一个产生式M→ε</span><br><span class="line">如果标记非终结符M在某个产生式A→α&#123;a&#125;β中替换了语义动作a，对a进行修改得到a&#x27; ，并且将a&#x27;关联到M→ε 上。动作a&#x27;</span><br><span class="line">(a) 将动作a需要的A或α中符号的任何属性作为M的继承属性进行复制</span><br><span class="line">(b) 按照a中的方法计算各个属性，但是将计算得到的这些属性作为M的综合属性</span><br></pre></td></tr></table></figure>
<h2 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h2><h3 id="声明语句的翻译"><a href="#声明语句的翻译" class="headerlink" title="声明语句的翻译"></a>声明语句的翻译</h3><p>主要任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">收集标识符的类型等属性信息，并为每一个名字分配一个相对地址</span><br></pre></td></tr></table></figure>
<p>名字的类型和相对地址信息保存在相应的符号表记录中</p>
<h4 id="类型表达式"><a href="#类型表达式" class="headerlink" title="类型表达式"></a>类型表达式</h4><p>基本类型是类型表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">integer</span><br><span class="line">real</span><br><span class="line">char</span><br><span class="line">boolean</span><br><span class="line">type_error (出错类型)</span><br><span class="line">void (无类型)</span><br></pre></td></tr></table></figure>
<p>可以为类型表达式命名，类型名也是类型表达式</p>
<p>将类型构造符(type constructor)作用于类型表达式可以构成新的类型表达式</p>
<p><strong>数组构造符array</strong></p>
<p>若T是类型表达式，则array ( I, T )是类型表达式( I是一个整数)</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514094900862.png" alt="image-20220514094900862" style="zoom:25%;"></p>
<p><strong>指针构造符pointer</strong></p>
<p>若T 是类型表达式，则 pointer ( T ) 是类型表达式，它表示一个指针类型</p>
<p><strong>笛卡尔乘积构造符X</strong></p>
<p>若T1 和T2是类型表达式，则笛卡尔乘积T1 X T2 是类型表达式</p>
<p><strong>函数构造符→</strong></p>
<p>若T1、T2、…、Tn 和R是类型表达式，则T1T2 …Tn→ R是类型表达式</p>
<p><strong>记录构造符record</strong></p>
<p>若有标识符N1 、N2 、…、Nn 与类型表达式T1 、T2 、…、Tn ， 则    record ( ( N1  X T1 ) X ( N2 X T2 )X …X ( Nn X Tn )) 是一个类型表达式</p>
<p>eg：<img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514095400390.png" alt="image-20220514095400390" style="zoom: 25%;"></p>
<h4 id="局部变量的存储分配"><a href="#局部变量的存储分配" class="headerlink" title="局部变量的存储分配"></a>局部变量的存储分配</h4><p>对于声明语句，语义分析的主要任务就是收集标识符的类型等属性信息，并为每一个名字分配一个相对地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从类型表达式可以知道该类型在运行时刻所需的存储单元数量称为类型的宽度(width)</span><br><span class="line">在编译时刻，可以使用类型的宽度为每一个名字分配一个相对地址</span><br></pre></td></tr></table></figure>
<p>名字的类型和相对地址信息保存在相应的符号表记录中</p>
<h3 id="赋值语句的翻译"><a href="#赋值语句的翻译" class="headerlink" title="赋值语句的翻译"></a>赋值语句的翻译</h3><h4 id="简单赋值语句的翻译"><a href="#简单赋值语句的翻译" class="headerlink" title="简单赋值语句的翻译"></a>简单赋值语句的翻译</h4><p>newtemp( )：生成一个新的临时变量t，返回t的地址</p>
<p>gen(code)：生成三地址指令code</p>
<p>lookup(name)：查询符号表返回name 对应的记录</p>
<p>增量翻译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在增量方法中，gen( )不仅要构造出一个新的三地址指令，还要将它添加到至今为止已生成的指令序列之后</span><br></pre></td></tr></table></figure>
<p>ppt例子</p>
<h4 id="数组引用的翻译"><a href="#数组引用的翻译" class="headerlink" title="数组引用的翻译"></a>数组引用的翻译</h4><p>将数组引用翻译成三地址码时要解决的主要问题是确定数组元素的存放地址，也就是数组元素的寻址</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514114112824.png" alt="image-20220514114112824" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514142140992.png" alt="image-20220514142140992" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514142202241.png" alt="image-20220514142202241" style="zoom:25%;"></p>
<p>符号表的组织——数组</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514142237490.png" alt="image-20220514142237490" style="zoom:25%;"></p>
<h3 id="控制语句的翻译"><a href="#控制语句的翻译" class="headerlink" title="控制语句的翻译"></a>控制语句的翻译</h3><h4 id="控制流语句"><a href="#控制流语句" class="headerlink" title="控制流语句"></a>控制流语句</h4><p>继承属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.true：是一个地址，该地址用来存放当B为真时控制流转向的指令的标号</span><br><span class="line">B.false：是一个地址，该地址用来存放当B为假时控制流转向的指令的标号</span><br><span class="line">S.next：是一个地址，该地址用来存放紧跟在S代码之后执行的指令(S的后继指令)的标号</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514143929654.png" alt="image-20220514143929654" style="zoom:25%;"></p>
<p>if-then-else</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514144057301.png" alt="image-20220514144057301" style="zoom:25%;"></p>
<p>if-then</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514144152954.png" alt="image-20220514144152954" style="zoom:25%;"></p>
<p>while-do</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514144250284.png" alt="image-20220514144250284" style="zoom:25%;"></p>
<p>控制流语句SDT编写要点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分析每一个非终结符之前</span><br><span class="line">先计算继承属性</span><br><span class="line">再观察代码结构图中该非终结符对应的方框顶部是否有导入箭头。如果有，调用label( )函数</span><br><span class="line">上一个代码框执行完不顺序执行下一个代码框时，生成一条显式跳转指令</span><br><span class="line">有自下而上的箭头时，设置begin属性。且定义后直接调用label( )函数绑定地址</span><br></pre></td></tr></table></figure>
<h4 id="布尔表达式的翻译"><a href="#布尔表达式的翻译" class="headerlink" title="布尔表达式的翻译"></a>布尔表达式的翻译</h4><p>在跳转代码中，逻辑运算符&amp;&amp;、|| 和 ! 被翻译成跳转指令。运算符本身不出现在代码中，布尔表达式的值是通过代码序列中的位置来表示的</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514144701666.png" alt="image-20220514144701666" style="zoom:25%;"></p>
<p>布尔表达式的SDT</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514144801933.png" alt="image-20220514144801933" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514145311289.png" alt="image-20220514145311289" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514145338517.png" alt="image-20220514145338517" style="zoom:25%;"></p>
<h4 id="SDT的通用实现方法"><a href="#SDT的通用实现方法" class="headerlink" title="SDT的通用实现方法"></a>SDT的通用实现方法</h4><p>任何SDT都可以通过下面的方法实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先建立一棵语法分析树</span><br><span class="line">然后按照从左到右的深度优先顺序来执行这些动作</span><br></pre></td></tr></table></figure>
<p>例题</p>
<p>存疑，修改</p>
<h3 id="回填"><a href="#回填" class="headerlink" title="回填"></a>回填</h3><h4 id="布尔表达式回填"><a href="#布尔表达式回填" class="headerlink" title="布尔表达式回填"></a>布尔表达式回填</h4><p>基本思想</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生成一个跳转指令时，暂时不指定该跳转指令的目标标号。这样的指令都被放入由跳转指令组成的列表中。同一个列表中的所有跳转指令具有相同的目标标号。等到 能够确定正确的目标标号时，才去填充这些指令的目标标号</span><br></pre></td></tr></table></figure>
<p>非终结符B的综合属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.truelist：指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是当B为真时控制流应该转向的指令的标号</span><br><span class="line">B.falselist：指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是当B为假时控制流应该转向的指令的标号</span><br></pre></td></tr></table></figure>
<p>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">makelist( i )</span><br><span class="line">创建一个只包含i的列表，i是跳转指令的标号，函数返回指向新创建的列表的指针</span><br><span class="line">merge( p1, p2 )</span><br><span class="line">将 p1 和 p2 指向的列表进行合并，返回指向合并后的列表的指针</span><br><span class="line">backpatch( p, i )</span><br><span class="line">将 i 作为目标标号插入到 p所指列表中的各指令中</span><br></pre></td></tr></table></figure>
<p>例题</p>
<h4 id="控制流语句回填"><a href="#控制流语句回填" class="headerlink" title="控制流语句回填"></a>控制流语句回填</h4><p>综合属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S.next1ist：指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是按照运行顺序紧跟在S代码之后的指令的标号</span><br></pre></td></tr></table></figure>
<p>例题</p>
<p>回填技术SDT编写要点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文法改造</span><br><span class="line">在list箭头指向的位置设置标记非终结符M</span><br><span class="line">在产生式末尾的语义动作中</span><br><span class="line">计算综合属性</span><br><span class="line">调用backpatch ( )函数回填各个list</span><br></pre></td></tr></table></figure>
<h3 id="switch语句的翻译"><a href="#switch语句的翻译" class="headerlink" title="switch语句的翻译"></a>switch语句的翻译</h3><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514162527513.png" alt="image-20220514162527513" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514162534065.png" alt="image-20220514162534065" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514162733153.png" alt="image-20220514162733153" style="zoom:25%;"></p>
<h3 id="过程调用语句的翻译"><a href="#过程调用语句的翻译" class="headerlink" title="过程调用语句的翻译"></a>过程调用语句的翻译</h3><p>需要一个队列q存放E1.addr 、E2.addr、…、 En.addr，以生成</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514163207424.png" alt="image-20220514163207424" style="zoom:25%;"></p>
<p>例子</p>
<h2 id="运行存储分配"><a href="#运行存储分配" class="headerlink" title="运行存储分配"></a>运行存储分配</h2><h3 id="存储组织"><a href="#存储组织" class="headerlink" title="存储组织"></a>存储组织</h3><p>一个目标程序运行所需的存储空间主要包括</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514163839643.png" alt="image-20220514163839643" style="zoom:25%;"></p>
<p><strong>存储分配策略</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于那些在编译时刻就可以确定大小的数据对象，可以在编译时刻就为它们分配存储空间，这样的分配策略称为静态存储分配</span><br><span class="line">反之，如果不能在编译时完全确定数据对象的大小，就要采用动态存储分配的策略。即在编译时仅产生各种必要的信息，而在运行时刻，再动态地分配数据对象的存储空间</span><br><span class="line">栈式存储分配</span><br><span class="line">堆式存储分配</span><br><span class="line">静态和动态分别对应编译时刻和运行时刻</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514194257711.png" alt="image-20220514194257711" style="zoom:25%;"></p>
<p><strong>活动记录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用过程(或函数、方法)作为用户自定义动作的单元的语言，其编译器通常以过程为单位分配存储空间</span><br><span class="line">过程体的每次执行称为该过程的一个活动(activation)</span><br><span class="line">过程每执行一次，就为它分配一块连续存储区，用来管理过程一次执行所需的信息，这块连续存储区称为活动记录( activation record )</span><br></pre></td></tr></table></figure>
<p><strong>活动记录的一般形式</strong></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514194518053.png" alt="image-20220514194518053" style="zoom:25%;"></p>
<h3 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在静态存储分配中，编译器为每个过程确定其活动记录在目标程序中的位置</span><br><span class="line">这样，过程中每个名字的存储位置就确定了</span><br><span class="line">因此，这些名字的存储地址可以被编译到目标代码中</span><br><span class="line">过程每次执行时，它的名字都绑定到同样的存储单元</span><br></pre></td></tr></table></figure>
<p>适合静态存储分配的语言必须满足以下条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组上下界必须是常数</span><br><span class="line">不允许过程的递归调用</span><br><span class="line">不允许用户动态建立数据实体</span><br></pre></td></tr></table></figure>
<p>满足这些条件的语言有BASIC和FORTRAN等</p>
<p>常用的静态存储分配方法：顺序分配法、层次分配法</p>
<p><strong>顺序分配法</strong></p>
<p>按照过程出现的先后顺序逐段分配存储空间<br>各过程的活动记录占用互不相交的存储空间</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514195326335.png" alt="image-20220514195326335" style="zoom:25%;"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：处理上简单</span><br><span class="line">缺点：对内存空间的使用不够经济合理</span><br></pre></td></tr></table></figure>
<p><strong>层次分配法</strong></p>
<p>通过对过程间的调用关系进行分析，凡属无相互调用关系的并列过程，尽量使其局部数据共享存储空间</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514195613542.png" alt="image-20220514195613542" style="zoom:25%;"></p>
<p>层次分配算法</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514195658467.png" alt="image-20220514195658467" style="zoom:25%;"></p>
<h3 id="栈式存储分配"><a href="#栈式存储分配" class="headerlink" title="栈式存储分配"></a>栈式存储分配</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有些语言使用过程、函数或方法作为用户自定义动作的单元，几乎所有针对这些语言的编译器都把它们的(至少一部分的)运行时刻存储以栈的形式进行管理，称为栈式存储分配</span><br><span class="line">当一个过程被调用时，该过程的活动记录被压入栈；当过程结束时，该活动记录被弹出栈</span><br><span class="line">这种安排不仅允许活跃时段不交叠的多个过程调用之间共享空间，而且允许以如下方式为一个过程编译代码：它的非局部变量的相对地址总是固定的，和过程调用序列无关</span><br></pre></td></tr></table></figure>
<p><strong>活动树</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用来描述程序运行期间控制进入和离开各个活动的情况的树称为活动树</span><br><span class="line">树中的每个结点对应于一个活动。根结点是启动程序执行的main过程的活动</span><br><span class="line">在表示过程p的某个活动的结点上，其子结点对应于被p的这次活动调用的各个过程的活动。按照这些活动被调用的顺序，自左向右地显示它们。一个子结点必须在其右兄弟结点的活动开始之前结束</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每个活跃的活动都有一个位于控制栈中的活动记录</span><br><span class="line">活动树的根的活动记录位于栈底</span><br><span class="line">程序控制所在的活动的记录位于栈顶</span><br><span class="line">栈中全部活动记录的序列对应于在活动树中到达当前控制所在的活动结点的路径</span><br></pre></td></tr></table></figure>
<p>设计活动记录的一些原则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在调用者和被调用者之间传递的值一般被放在被调用者的活动记录的开始位置，这样它们可以尽可能地靠近调用者的活动记录</span><br><span class="line">固定长度的项被放置在中间位置:控制连、访问链、机器状态字</span><br><span class="line">在早期不知道大小的项被放置在活动记录的尾部</span><br><span class="line">栈顶指针寄存器top_sp指向活动记录中局部数据开始的位置，以该位置作为基地址</span><br></pre></td></tr></table></figure>
<h4 id="调用序列和返回序列"><a href="#调用序列和返回序列" class="headerlink" title="调用序列和返回序列"></a>调用序列和返回序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">过程调用和过程返回都需要执行一些代码来管理活动记录栈，保存或恢复机器状态等</span><br><span class="line">调用序列</span><br><span class="line">实现过程调用的代码段。为一个活动记录在栈中分配空间，并在此记录的字段中填写信息</span><br><span class="line">返回序列</span><br><span class="line">恢复机器状态，使得调用过程能够在调用结束之后继续执行</span><br><span class="line">一个调用代码序列中的代码通常被分割到调用过程（调用者）和被调用过程（被调用者）中。返回序列也是如此</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514203627726.png" alt="image-20220514203627726" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514203641791.png" alt="image-20220514203641791" style="zoom:25%;"></p>
<p><strong>调用者和被调用者之间的任务划分</strong></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514203739336.png" alt="image-20220514203739336" style="zoom:25%;"></p>
<p><strong>变长数据的存储分配</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在现代程序设计语言中，在编译时刻不能确定大小的对象将被分配在堆区。但是，如果它们是过程的局部对象，也可以将它们分配在运行时刻栈中。尽量将对象放置在栈区的原因：可以避免对它们的空间进行垃圾回收，也就减少了相应的开销</span><br><span class="line">只有一个数据对象局部于某个过程，且当此过程结束时它变得不可访问，才可以使用栈为这个对象分配空间</span><br></pre></td></tr></table></figure>
<h3 id="非局部数据的访问"><a href="#非局部数据的访问" class="headerlink" title="非局部数据的访问"></a>非局部数据的访问</h3><p>一个过程除了可以使用过程自身声明的局部数据以外，还可以使用过程外声明的非局部数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">全局数据</span><br><span class="line">外围过程定义的数据</span><br></pre></td></tr></table></figure>
<p>如何访问非局部数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问链（静态链）</span><br><span class="line">display表（嵌套层次显示表）</span><br></pre></td></tr></table></figure>
<h4 id="访问链"><a href="#访问链" class="headerlink" title="访问链"></a>访问链</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">静态作用域规则：只要过程b的声明嵌套在过程a的声明中，过程b就可以访问过程a中声明的对象</span><br><span class="line">可以在相互嵌套的过程的活动记录之间建立一种称为访问链(Access link)的指针，使得内嵌的过程可以访问外层过程中声明的对象</span><br><span class="line">如果过程b在源代码中直接嵌套在过程a中(b的嵌套深度比a的嵌套深度多1)，那么b的任何活动中的访问链都指向最近的a的活动</span><br></pre></td></tr></table></figure>
<p><strong>嵌套深度</strong></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514205925465.png" alt="image-20220514205925465" style="zoom: 50%;"></p>
<p>例子</p>
<p><strong>访问链的建立</strong></p>
<p>假设嵌套深度为nx的过程x调用嵌套深度为ny的过程y (x→y)</p>
<p>nx &lt; ny的情况(外层调用内层)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y一定是直接在x中定义的 (例如：s→q,  q→p) ，因此，ny=nx +1</span><br><span class="line">在调用代码序列中增加一个步骤：在y的访问链中放置一个指向x的活动记录的指针</span><br></pre></td></tr></table></figure>
<p>nx = ny的情况(本层调用本层 )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：递归调用 (q→q )</span><br><span class="line">被调用者的活动记录的访问链与调用者的活动记录的访问链是相同的，可以直接复制</span><br></pre></td></tr></table></figure>
<p>nx &gt; ny的情况(内层调用外层，如： p→e )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用者x必定嵌套在某个过程z中，而z中直接定义了被调用者y</span><br><span class="line">从x的活动记录开始，沿着访问链经过nx - ny + 1步就可以找到离栈顶最近的z的活动记录。 y的访问链必须指向z的这个活动记录</span><br></pre></td></tr></table></figure>
<p>嵌套深度是在编译阶段通过静态分析就能确定的</p>
<p><strong>display表</strong></p>
<p>慕课没有</p>
<p>看例题，注意嵌套深度与树无关，在编译阶段就决定。</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>形式参数（formal parameter）：在过程定义中使用的参数<br>实际参数（actual parameter）：在调用过程时使用的参数</p>
<p>形参和实参相关联的几种方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">传值（Call- by-Value）</span><br><span class="line">传地址（Call- by-Reference）</span><br><span class="line">传值结果（Call- by-Value-Result）</span><br><span class="line">传名（Call- by-Name）</span><br></pre></td></tr></table></figure>
<h4 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">把实参的值传递给相应的形参</span><br><span class="line">实现方法</span><br><span class="line">调用过程把实参的值计算出来，并传递到被调用过程相应的形式单元中</span><br><span class="line">被调用过程中，像引用局部数据一样引用形式参数，直接访问对应的形式单元</span><br></pre></td></tr></table></figure>
<h4 id="传地址"><a href="#传地址" class="headerlink" title="传地址"></a>传地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">把实参的地址传递给相应的形参</span><br><span class="line">实现方法</span><br><span class="line">调用过程把实参的地址传递到被调用过程相应的形式单元中</span><br><span class="line">被调用过程中，对形参的引用或赋值被处理成对形式单元的间接访问</span><br></pre></td></tr></table></figure>
<h4 id="传值结果"><a href="#传值结果" class="headerlink" title="传值结果"></a>传值结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">传地址的一种变形</span><br><span class="line">实现方法</span><br><span class="line">每个形参对应两个形式单元。第一个形式单元存放实参的地址，第二个形式单元存放实参的值</span><br><span class="line">在过程体中，对形参的引用或赋值看作对它的第二个形式单元的直接访问</span><br><span class="line">过程完成返回前，把第二个单元的内容存放到第一个单元所指的实参单元中</span><br></pre></td></tr></table></figure>
<h4 id="传名"><a href="#传名" class="headerlink" title="传名"></a>传名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">相当于把被调用过程的过程体抄到调用出现的地方，但把其中出现的形参都替换成相应的实参</span><br><span class="line">实现方法</span><br><span class="line">在进入被调用过程之前不对实参预先进行计值，而是让过程体中每当使用到相应的实参时才逐次对它实行计值（或计算地址）</span><br><span class="line">通常把实参处理成一个子程序（称为参数子程序），每当过程体中使用到相应的实参时就调用这个子程序</span><br></pre></td></tr></table></figure>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>符号表是用于存放标识符的属性信息的数据结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">种属 (Kind)</span><br><span class="line">类型 (Type)</span><br><span class="line">存储位置、长度</span><br><span class="line">作用域 </span><br><span class="line">参数和返回值信息</span><br></pre></td></tr></table></figure>
<p>符号表的作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">辅助代码生成</span><br><span class="line">一致性检查</span><br></pre></td></tr></table></figure>
<p>例子</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220514213155111.png" alt="image-20220514213155111"></p>
<p>标识符的基本处理方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当在某一层的声明语句中识别出一个标识符(id的定义性出现)时，以此标识符查相应于本层的符号表</span><br><span class="line">如果查到，则报错并发出诊断信息“id重复声明”</span><br><span class="line">否则，在符号表中加入新登记项，将标识符及有关信息填入</span><br><span class="line">当在可执行语句部分扫视到标识符时( id的应用性出现)</span><br><span class="line">首先在该层符号表中查找该id，如果找不到，则到直接外层符号表中去查，如此等等，一旦找到，则在表中取出有关信息并作相应处理</span><br><span class="line">如果查遍所有外层符号表均未找到该id，则报错并发出诊断信息“id未声明”</span><br></pre></td></tr></table></figure>
<p>符号表的建立？</p>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h4 id="流图"><a href="#流图" class="headerlink" title="流图"></a>流图</h4><p>基本块(Basic Block)是满足下列条件的最大的连续三地址指令序列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">控制流只能从基本块的第一条指令进入该块。也就是说，没有跳转到基本块中间或末尾指令的转移指令</span><br><span class="line">除了基本块的最后一条指令，控制流在离开基本块之前不会跳转或者停机</span><br></pre></td></tr></table></figure>
<p>每个基本块由一组总是一起执行的指令组成</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515003940960.png" alt="image-20220515003940960" style="zoom:25%;"></p>
<p>流图的每个结点是一个基本块<br>从基本块B到基本块C之间有一条边当且仅当基本块C的第一条指令可能紧跟在B的最后一条指令之后执行，此时称B是C的前驱(predecessor) ，   C是B的后继(successor)</p>
<h3 id="优化的分类"><a href="#优化的分类" class="headerlink" title="优化的分类"></a>优化的分类</h3><p>机器无关优化：针对中间代码<br>机器相关优化：针对目标代码<br>局部代码优化：单个基本块范围内的优化<br>全局代码优化：面向多个基本块的优化</p>
<p>常用的优化方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">删除公共子表达式</span><br><span class="line">删除无用代码</span><br><span class="line">代码移动</span><br><span class="line">强度削弱</span><br><span class="line">删除归纳变量</span><br></pre></td></tr></table></figure>
<h4 id="删除公共子表达式"><a href="#删除公共子表达式" class="headerlink" title="删除公共子表达式"></a>删除公共子表达式</h4><p>如果表达式x op y先前已被计算过，并且从先前的计算到现在，x op y中变量的值没有改变，那么x op y的这次出现就称为公共子表达式</p>
<p>局部公共子表达式；全局公共子表达式</p>
<p>例子</p>
<h4 id="删除无用代码"><a href="#删除无用代码" class="headerlink" title="删除无用代码"></a>删除无用代码</h4><p>复制传播</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">常用的公共子表达式消除算法和其它一些优化算法会引入一些复制语句(形如x = y的赋值语句)</span><br><span class="line"> 复制传播：在复制语句x = y之后尽可能地用y代替x</span><br></pre></td></tr></table></figure>
<p>复制传播给删除无用代码带来机会</p>
<p>无用代码(死代码Dead-Code ) ：其计算结果永远不会被使用的语句</p>
<p>例子</p>
<p><strong>常量合并</strong></p>
<p>如果在编译时刻推导出一个表达式的值是常量，就可以使用该常量来替代这个表达式。该技术被称为常量合并</p>
<h4 id="代码移动"><a href="#代码移动" class="headerlink" title="代码移动"></a>代码移动</h4><p>这个转换处理的是那些不管循环执行多少次都得到相同结果的表达式(即循环不变计算，loop-invariant computation) ，在进入循环之前就对它们求值</p>
<p>对于多重嵌套的循环，循环不变计算是相对于某个循环而言的。可能对于更加外层的循环，它就不是循环不变计算</p>
<h4 id="强度削弱"><a href="#强度削弱" class="headerlink" title="强度削弱"></a>强度削弱</h4><p>用较快的操作代替较慢的操作，如用加代替乘</p>
<p>归纳变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于一个变量x ，如果存在一个正的或负的常数c使得每次x被赋值时它的值总增加c ，那么x就称为归纳变量(Induction Variable)</span><br></pre></td></tr></table></figure>
<h4 id="删除归纳变量"><a href="#删除归纳变量" class="headerlink" title="删除归纳变量"></a>删除归纳变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在沿着循环运行时，如果有一组归纳变量的值的变化保持步调一致，常常可以将这组变量删除为只剩一个</span><br></pre></td></tr></table></figure>
<h3 id="基本块的优化"><a href="#基本块的优化" class="headerlink" title="基本块的优化"></a>基本块的优化</h3><p>很多重要的局部优化技术首先把一个基本块转换成为一个无环有向图</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515144138737.png" alt="image-20220515144138737" style="zoom:25%;"></p>
<p>基于基本块的 DAG 删除无用代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从一个DAG上删除所有没有附加活跃变量（活跃变量是指其值可能会在以后被使用的变量）的根结点(即没有父结点的结点) 。重复应用这样的处理过程就可以从DAG中消除所有对应于无用代码的结点</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515144511396.png" alt="image-20220515144511396" style="zoom:25%;"></p>
<p>数组元素赋值指令的表示</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515144602509.png" alt="image-20220515144602509" style="zoom:25%;"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在a[j]=y时，有可能改变a[i]的值</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515144738742.png" alt="image-20220515144738742" style="zoom:25%;"></p>
<p>根据基本块的DAG可以获得一些非常有用的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">确定哪些变量的值在该基本块中赋值前被引用过</span><br><span class="line">在DAG中创建了叶结点的那些变量</span><br><span class="line">确定哪些语句计算的值可以在基本块外被引用</span><br><span class="line">在DAG构造过程中为语句s（该语句为变量x定值）创建的节点N，在DAG构造结束时x仍然是N的定值变量</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515144412561.png" alt="image-20220515144412561" style="zoom:25%;"></p>
<p>例子</p>
<h3 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h3><p>一组用来获取有关数据如何沿着程序执行路径流动的相关信息的技术</p>
<p>在每一种数据流分析应用中，都会把每个程序点和一个数据流值关联起来</p>
<p>数据流分析的主要应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">到达-定值分析 (Reaching-Definition Analysis)</span><br><span class="line">活跃变量分析 (Live-Variable Analysis)</span><br><span class="line">可用表达式分析 (Available-Expression Analysis)</span><br></pre></td></tr></table></figure>
<p>数据流分析模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语句的数据流模式</span><br><span class="line"> IN[s]:	语句s之前的数据流值</span><br><span class="line">	 OUT[s]:	语句s之后的数据流值</span><br><span class="line"> fs：语句s的传递函数(transfer function)</span><br><span class="line">     一个赋值语句s之前和之后的数据流值的关系</span><br><span class="line">     传递函数的两种风格</span><br><span class="line">        信息沿执行路径前向传播 (前向数据流问题)：OUT[s] = fs (IN[s])</span><br><span class="line">        信息沿执行路径逆向传播 (逆向数据流问题)：IN[s] = fs (OUT[s])</span><br></pre></td></tr></table></figure>
<h4 id="到达定值分析"><a href="#到达定值分析" class="headerlink" title="到达定值分析"></a>到达定值分析</h4><p>定值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量x的定值是(可能)将一个值赋给x的语句</span><br></pre></td></tr></table></figure>
<p>到达定值(Reaching Definition)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果存在一条从紧跟在x的定值d后面的点到达某一程序点p的路径，而且在此路径上d没有被“杀死” (如果在此路径上有对变量x的其它定值d′，则称定值d被定值d′“杀死”了) ，则称定值d到达程序点p</span><br><span class="line">直观地讲，如果某个变量x的一个定值d到达点p，在点p处使用的x的值可能就是由d最后赋予的</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515155110137.png" alt="image-20220515155110137" style="zoom:25%;"></p>
<p><strong>到达定值分析的主要用途</strong></p>
<p>循环不变计算的检测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果循环中含有赋值x=y+z ，而y和z所有可能的定值都在循环外面(包括y或z是常数的特殊情况) ，那么y+z就是循环不变计算</span><br></pre></td></tr></table></figure>
<p>常量合并</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果对变量x的某次使用只有一个定值可以到达，并且该定值把一个常量赋给x ，那么可以简单地把x替换为该常量</span><br></pre></td></tr></table></figure>
<p>判定变量x在p点上是否未经定值就被引用</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515155325874.png" alt="image-20220515155325874" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515155539821.png" alt="image-20220515155539821" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515155645902.png" alt="image-20220515155645902" style="zoom:25%;"></p>
<p>例子</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515155911362.png" alt="image-20220515155911362" style="zoom:25%;"></p>
<p><strong>到达定值的计算</strong></p>
<p>例题</p>
<p>引用-定值链</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515160301603.png" alt="image-20220515160301603" style="zoom:25%;"></p>
<h4 id="活跃变量分析"><a href="#活跃变量分析" class="headerlink" title="活跃变量分析"></a>活跃变量分析</h4><p>活跃变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于变量x和程序点p，如果在流图中沿着从p开始的某条路径会引用变量x在p点的值，则称变量x在点p是活跃(live)的，否则称变量x在点p不活跃(dead)</span><br></pre></td></tr></table></figure>
<p>例子</p>
<p><strong>活跃变量信息的主要用途</strong></p>
<p>删除无用赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无用赋值：如果x在点p的定值在基本块内所有后继点都不被引用，且x在基本块出口之后又是不活跃的，那么x在点p的定值就是无用的</span><br></pre></td></tr></table></figure>
<p>为基本块分配寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果所有寄存器都被占用，并且还需要申请一个寄存器，则应该考虑使用已经存放了死亡值的寄存器，因为这个值不需要保存到内存</span><br><span class="line"> 如果一个值在基本块结尾处是死的就不必在结尾处保存这个值</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515165840678.png" alt="image-20220515165840678" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515170431350.png" alt="image-20220515170431350" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515170613886.png" alt="image-20220515170613886" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515172411560.png" alt="image-20220515172411560" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515173505087.png" alt="image-20220515173505087" style="zoom:25%;"></p>
<h4 id="可用表达式分析"><a href="#可用表达式分析" class="headerlink" title="可用表达式分析"></a>可用表达式分析</h4><p>可用表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果从流图的首节点到达程序点 p的每条路径都对表达式x op y进行计算，并且从最后一个这样的计算到点p之间没有再次对x或y定值，那么表达式x op y在点 p是可用的(available)</span><br></pre></td></tr></table></figure>
<p>表达式可用的直观意义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在点 p上，x op y已经在之前被计算过，不需要重新计算</span><br></pre></td></tr></table></figure>
<p><strong>主要通途</strong></p>
<p>消除全局公共子表达式</p>
<p>进行复制传播</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515193957942.png" alt="image-20220515193957942" style="zoom:25%;"></p>
<p><strong>可用表达式传递函数</strong></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515194252677.png" alt="image-20220515194252677" style="zoom:25%;"></p>
<p><strong>可用表达式的数据流方程</strong></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515194545925.png" alt="image-20220515194545925" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515194801190.png" alt="image-20220515194801190" style="zoom:25%;"></p>
<p>注意此处初始化</p>
<h3 id="流图中的循环"><a href="#流图中的循环" class="headerlink" title="流图中的循环"></a>流图中的循环</h3><p>支配结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果从流图的入口结点到结点n的每条路径都经过结点d，则称结点d支配(dominate)结点n，记为d dom n</span><br></pre></td></tr></table></figure>
<p>寻找支配节点</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515195118328.png" alt="image-20220515195118328" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515195158344.png" alt="image-20220515195158344" style="zoom:25%;"></p>
<p><strong>回边</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果存在从结点n到d的有向边n→d，且d dom n，那么这条边称为回边</span><br></pre></td></tr></table></figure>
<p><strong>自然循环</strong></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515195547361.png" alt="image-20220515195547361" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515195949826.png" alt="image-20220515195949826" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515200001241.png" alt="image-20220515200001241" style="zoom:25%;"></p>
<p>自然循环的一个重要性质</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果两个自然循环的首结点不相同，则这两个循环要么互不相交，要么一个完全包含(嵌入)在另外一个里面</span><br></pre></td></tr></table></figure>
<p>最内循环 (Innermost Loops): 不包含其它循环的循环</p>
<p>如果两个循环具有相同的首结点，那么很难说哪个是最内循环。此时把两个循环合并</p>
<h3 id="全局优化"><a href="#全局优化" class="headerlink" title="全局优化"></a>全局优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">删除全局公共子表达式</span><br><span class="line">删除复制语句</span><br><span class="line">代码移动</span><br><span class="line">作用于递归变量的强度削弱</span><br><span class="line">删除递归变量</span><br></pre></td></tr></table></figure>
<h4 id="删除全局公共子表达式"><a href="#删除全局公共子表达式" class="headerlink" title="删除全局公共子表达式"></a>删除全局公共子表达式</h4><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515200350777.png" alt="image-20220515200350777" style="zoom:25%;"></p>
<h4 id="删除复制语句"><a href="#删除复制语句" class="headerlink" title="删除复制语句"></a><strong>删除复制语句</strong></h4><p>对于复制语句s: x=y，如果在x的所有引用点都可以用对y的引用代替对x的引用(复制传播)，那么可以删除复制语句 x=y</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515200456345.png" alt="image-20220515200456345" style="zoom:25%;"></p>
<h4 id="代码移动-1"><a href="#代码移动-1" class="headerlink" title="代码移动"></a>代码移动</h4><p><strong>循环不变计算检测算法</strong></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515200548207.png" alt="image-20220515200548207" style="zoom:25%;"></p>
<p><strong>代码外提</strong></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515200759125.png" alt="image-20220515200759125" style="zoom:25%;"></p>
<p><strong>循环不变计算语句 s : x = y + z 移动的条件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) s所在的基本块是循环所有出口结点(有后继结点在循环外的结点)的支配结点</span><br><span class="line">(2) 循环中没有其它语句对x赋值</span><br><span class="line">(3) 循环中对x的引用仅由s到达</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515201036529.png" alt="image-20220515201036529" style="zoom:25%;"></p>
<p>例子</p>
<h4 id="作用于归纳变量的强度削弱"><a href="#作用于归纳变量的强度削弱" class="headerlink" title="作用于归纳变量的强度削弱"></a>作用于归纳变量的强度削弱</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于一个变量x ，如果存在一个正的或负的常量c ，使得每次x被赋值时，它的值总是增加c ，则称x为归纳变量</span><br><span class="line">如果循环L中的变量i 只有形如i =i+c的定值(c是常量)，则称i为循环L的基本归纳变量</span><br><span class="line">如果j = c×i+d，其中i是基本归纳变量，c和d是常量，则j也是一个归纳变量，称j属于i族</span><br><span class="line">每个归纳变量都关联一个三元组。如果j = c×i+d，其中i是基本归纳变量，c和d是常量，则与j相关联的三元组是( i, c, d )</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515201237286.png" alt="image-20220515201237286" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515201248830.png" alt="image-20220515201248830" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515201356302.png" alt="image-20220515201356302" style="zoom:25%;"></p>
<h4 id="归纳变量的删除"><a href="#归纳变量的删除" class="headerlink" title="归纳变量的删除"></a>归纳变量的删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于在强度削弱算法中引入的复制语句j=t，如果在归纳变量j的所有引用点都可以用对t的引用代替对j的引用，并且j在循环的出口处不活跃，则可以删除复制语句j=t</span><br><span class="line"></span><br><span class="line">强度削弱后，有些归纳变量的作用只是用于测试。如果可以用对其它归纳变量的测试代替对这种归纳变量的测试，那么可以删除这种归纳变量</span><br></pre></td></tr></table></figure>
<p>删除仅用于测试的归纳变量</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515211020194.png" alt="image-20220515211020194" style="zoom:25%;"></p>
<h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><h3 id="代码生成器的主要任务"><a href="#代码生成器的主要任务" class="headerlink" title="代码生成器的主要任务"></a>代码生成器的主要任务</h3><p>指令选择</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择适当的目标机指令来实现中间表示(IR)语句</span><br></pre></td></tr></table></figure>
<p>寄存器分配（allocation）和指派（assignment）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把哪个值放在哪个寄存器中</span><br></pre></td></tr></table></figure>
<p>指令排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按照什么顺序来安排指令的执行</span><br></pre></td></tr></table></figure>
<h3 id="一个简单的目标机模型"><a href="#一个简单的目标机模型" class="headerlink" title="一个简单的目标机模型"></a>一个简单的目标机模型</h3><p>三地址机器模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">加载、保存、运算、跳转等操作</span><br><span class="line">内存按字节寻址</span><br><span class="line">n个通用寄存器R0, R1, …, Rn-1</span><br><span class="line">假设所有的运算分量都是整数</span><br><span class="line">指令之间可能有一个标号</span><br></pre></td></tr></table></figure>
<h3 id="指令选择"><a href="#指令选择" class="headerlink" title="指令选择"></a>指令选择</h3><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515215146285.png" alt="image-20220515215146285" style="zoom:25%;"></p>
<p><strong>过程调用和返回的目标代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用静态内存分配的方式</span><br><span class="line">使用栈式内存分配的方式</span><br></pre></td></tr></table></figure>
<p>callee的活动记录在静态区中的起始位置</p>
<p>callee的目标代码在代码区中的起始位置</p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515215844342.png" alt="image-20220515215844342" style="zoom:25%;"></p>
<h3 id="寄存器的选择"><a href="#寄存器的选择" class="headerlink" title="寄存器的选择"></a>寄存器的选择</h3><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515220019625.png" alt="image-20220515220019625" style="zoom:25%;"></p>
<p><strong>寄存器描述符和地址描述符</strong></p>
<p>寄存器描述符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记录每个寄存器当前存放的是哪些变量的值</span><br></pre></td></tr></table></figure>
<p>地址描述符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">记录运行时每个名字的当前值存放在哪个或哪些位置</span><br><span class="line">该位置可能是寄存器、栈单元、内存地址或者是它们的某个集合</span><br><span class="line">这些信息可以存放在该变量名对应的符号表条目中</span><br></pre></td></tr></table></figure>
<p><strong>基本块的收尾处理</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在基本块结束之前，基本块中使用的变量可能仅存放在某个寄存器中</span><br><span class="line">如果这个变量是一个只在基本块内部使用的临时变量，当基本块结束时，可以忘记这些临时变量的值并假设这些寄存器是空的</span><br><span class="line">对于一个在基本块的出口处可能活跃的变量x ,  如果它的地址描述符表明它的值没有存放在x的内存位置上,  则生成指令“ST x, R” ( R是在基本块结尾处存放 x值的寄存器 )</span><br></pre></td></tr></table></figure>
<p><strong>管理寄存器和地址描述符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当代码生成算法生成加载、保存和其他指令时，它必须同时更新寄存器和地址描述符</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515220152288.png" alt="image-20220515220152288" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515220242413.png" alt="image-20220515220242413" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515220310043.png" alt="image-20220515220310043" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515220624081.png" alt="image-20220515220624081" style="zoom:25%;"></p>
<h4 id="寄存器选择函getReg"><a href="#寄存器选择函getReg" class="headerlink" title="寄存器选择函getReg"></a>寄存器选择函getReg</h4><p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515221133482.png" alt="image-20220515221133482" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515221317333.png" alt="image-20220515221317333" style="zoom:25%;"></p>
<p><img src="/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20220515221332913.png" alt="image-20220515221332913" style="zoom:25%;"></p>
<h3 id="窥孔优化"><a href="#窥孔优化" class="headerlink" title="窥孔优化"></a>窥孔优化</h3><p><strong>窥孔</strong>(peephole)是程序上的一个小的滑动窗口</p>
<p><strong>窥孔优化</strong>是指在优化的时候，检查目标指令的一个滑动窗口(即窥孔) ，并且只要有可能就在窥孔内用更快或更短的指令来替换窗口中的指令序列</p>
<p>也可以在中间代码生成之后直接应用窥孔优化来提高中间表示形式的质量</p>
<p><strong>具有窥孔优化特点的程序变换的例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">冗余指令删除</span><br><span class="line">控制流优化</span><br><span class="line">代数优化</span><br><span class="line">机器特有指令的使用</span><br></pre></td></tr></table></figure>
<h2 id="习题总结"><a href="#习题总结" class="headerlink" title="习题总结"></a>习题总结</h2><h3 id="重点-1"><a href="#重点-1" class="headerlink" title="重点"></a>重点</h3><p>已掌握</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3.1 4.1 4.2  5.1(5.1.2重点) 6.1 6.2 7.1 7.2 7.3 7.4 7.5 (规范LR项集族) 7.6 7.7 7.8  7.9</span><br><span class="line">8.1 8.3 9.2(设计SDD) 9.3(设计SDD) 9.4(改写SDT) 12.2(四元式) 12.3(翻译赋值语句) 13.1(控制流处理方案) 13.2 13.3(控制流四元式) 14.1(求truelist) 14.2 14.3 14.4(构造SDT) 14.6(设计sdt) 15.1 15.2(快排) 15.3(Fibonacci) 15.4(栈问题，考前再看一下) 15.5 15.6(符号表) 16.3 16.4(DAG) 16.5 16.6(带跳转和[]=的DAG) 16.7 16.8(基本块) </span><br><span class="line">17.1(到达定值分析) 18.1(可用表达式分析) 18.2(活跃变量分析,逆分析) 18.3(到达定值分析应用) 19.1(重点，各种值的找取)</span><br><span class="line">19.2(重点，代码优化) 19.6</span><br></pre></td></tr></table></figure>
<p>未掌握</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4.1.3的消除左递归方法 </span><br><span class="line">9.1 扩展SDD</span><br><span class="line">10.1(构造递归下降SDD)</span><br><span class="line">13.4 13.5 *13.6(翻译方案) </span><br><span class="line">14.5(超级复杂的SDT构造)</span><br><span class="line">19.5</span><br></pre></td></tr></table></figure>
<h3 id="非重点"><a href="#非重点" class="headerlink" title="非重点"></a>非重点</h3><p>已掌握</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.2 2.1 8.2 8.4(是否存在一致的求值过程)</span><br></pre></td></tr></table></figure>
<p>未掌握</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.1 6.3 18.4 18.5</span><br></pre></td></tr></table></figure>
<p>各种链</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/24/NLP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/24/NLP/" class="post-title-link" itemprop="url">NLP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-24 17:08:09" itemprop="dateCreated datePublished" datetime="2021-12-24T17:08:09+08:00">2021-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-29 00:31:44" itemprop="dateModified" datetime="2021-12-29T00:31:44+08:00">2021-12-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>NLP任务：分词、词性标注、未登录词识别</p>
<p>语言的性质：共时性；历时性</p>
<p>语法单位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">句子是语言中最大的语法单位</span><br><span class="line">词组是词的组合，它是句子里面作用相当于词而本身又是由词组成的大于词的单位。</span><br><span class="line">词是最重要的一级语法单位，它是造句的时候能够独立运用的最小单位。</span><br><span class="line">语素是语言中音义结合的最小单位。就汉语来说，大抵一个汉字就是一个语素，但是也有两个字表示一个语素的，如：“咖啡”</span><br></pre></td></tr></table></figure>
<h2 id="语料库"><a href="#语料库" class="headerlink" title="语料库"></a>语料库</h2><p>• 语料库（corpus）一词在语言学上意指大量的文本，通常经过整理， 具有既定格式与标记</p>
<p>语料库的种类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共时语料库与历时语料库</span><br><span class="line">通用语料库与专用语料库</span><br></pre></td></tr></table></figure>
<h3 id="语料加工"><a href="#语料加工" class="headerlink" title="语料加工"></a>语料加工</h3><p>文本处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">垃圾格式问题</span><br><span class="line">大小写</span><br><span class="line">标记化</span><br><span class="line">空格</span><br><span class="line">连字符</span><br><span class="line">词法</span><br><span class="line">句子定义—启发式算法</span><br><span class="line">句子边界的研究</span><br></pre></td></tr></table></figure>
<p>格式标注</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通用标记语言SGML</span><br><span class="line">SGML是超文本格式的最高层次标准，是可以定义标记语言的元语言</span><br><span class="line">语法标注</span><br></pre></td></tr></table></figure>
<p>Zipf法则 • 一个词地频率f和它的词频排序位置r： f*r=k (k为常数)</p>
<p><img src="/2021/12/24/NLP/image-20211227150000774.png" alt="image-20211227150000774"></p>
<p>如果设置参数B=1, ρ=0，Mandelbrot公式就简化为Zipf法则</p>
<p>搭配抽取</p>
<p><img src="/2021/12/24/NLP/image-20211227150045052.png" alt="image-20211227150045052" style="zoom:50%;"></p>
<h2 id="语料库加工-双语句子自动对齐-amp-双语词典获取"><a href="#语料库加工-双语句子自动对齐-amp-双语词典获取" class="headerlink" title="语料库加工_双语句子自动对齐&amp; 双语词典获取"></a>语料库加工_双语句子自动对齐&amp; 双语词典获取</h2><h3 id="句子对齐问题描述"><a href="#句子对齐问题描述" class="headerlink" title="句子对齐问题描述"></a>句子对齐问题描述</h3><p>基于长度的句子对齐  基本思想：源语言和目标语言的句子长度存在一定 的比例关系</p>
<p>要求：最小（句珠内无句珠）； 唯一（一个句子仅属于一个句珠）； 无交叉（后句对齐一定在前句对齐位置之后）</p>
<h3 id="基于共现的双语词典的获取"><a href="#基于共现的双语词典的获取" class="headerlink" title="基于共现的双语词典的获取"></a>基于共现的双语词典的获取</h3><p>基本思想：如果汉语词出现在某个双语句对 中，其译文也必定在这个句对中。</p>
<p>汉英词典的迭代获取策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">迭代策略</span><br><span class="line">1) 初始化；</span><br><span class="line">2) 使用对数相似性模型计算汉英翻译词对候选；</span><br><span class="line">3) 选取前n个汉英对译词对；</span><br><span class="line">4) 双语句对中剔除选定的翻译词对；</span><br><span class="line">5) 若不满足终止条件，重复步骤2；</span><br><span class="line"> 几点说明：复合词暂未考虑；可加入交互方式;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基于共现的词汇对译模型</p>
<p>评价方式：专家独立于上下文进行判别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">评价1：每5000个翻译词对候选中正确的译文数</span><br><span class="line">评价2：综合考虑翻译词典的性能</span><br></pre></td></tr></table></figure>
<h2 id="汉语自动分词"><a href="#汉语自动分词" class="headerlink" title="汉语自动分词"></a>汉语自动分词</h2><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词干提取vs词形还原：分别用于IR 和 NLP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">词干提取（stemming）是抽取词的词干或词根形式（不一定能够表达完整语义</span><br><span class="line">词形还原（lemmatization），是把一个任何形式的语言词汇还原为一般形式（能表达完整语义）</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">词干提取主要是采用“缩减”的方法</span><br><span class="line">词形还原主要采用“转变”的方法</span><br><span class="line">在复杂性上：词干提取方法相对简单，词形还原更复杂</span><br><span class="line">在实现方法上：主流方法类似，但具体实现上各有侧重</span><br></pre></td></tr></table></figure>
<p>词性标注</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">词性标注（part-of-speech tagging）,又称为词类标注或者简称</span><br><span class="line">标注，是指为分词结果中的每个单词标注一个正确的词性的程序，</span><br><span class="line">也即确定每个词是名词、动词、形容词或者其他词性的过程</span><br><span class="line">• 词性标注是很多NLP任务的预处理步骤，如句法分析，经过词性</span><br><span class="line">标注后的文本会带来很大的便利性，但也不是不可或缺的步骤</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="分词算法"><a href="#分词算法" class="headerlink" title="分词算法"></a>分词算法</h3><p>正向最大匹配分词(Forward Maximum  Matching method, FMM)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基本思想：将当前能够匹配的最长词输出</span><br><span class="line">• 1. 设自动分词词典中最长词条所含汉字个数为I</span><br><span class="line">• 2. 取被处理材料当前字符串序数中的I个字作为匹配字段，查找分词词典。</span><br><span class="line">若词典中有这样的一个I字词，则匹配成功，匹配字段作为一个词被切分出</span><br><span class="line">来，转6</span><br><span class="line">• 3. 如果词典中找不到这样的一个I字词，则匹配失败</span><br><span class="line">• 4. 匹配字段去掉最后一个汉字，I--</span><br><span class="line">• 5. 重复2-4，直至切分成功为止</span><br><span class="line">• 6. I重新赋初值，转2，直到切分出所有词为止</span><br></pre></td></tr></table></figure>
<p>逆向最大匹配分词(Backward  Maximum Matching method, BMM法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分词过程与FMM方法相同，不过是从句子(或文</span><br><span class="line">章)末尾开始处理，每次匹配不成功时去掉的是</span><br><span class="line">最前面的一个汉字</span><br></pre></td></tr></table></figure>
<p>实验表明：逆向最大匹配法比最大匹配法更有效</p>
<p>最大匹配法的问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• 存在分词错误：增加知识、局部修改</span><br><span class="line">• 局部修改：增加歧义词表，排歧规则</span><br><span class="line">无法发现分词歧义-&gt;从单向匹配改为双向最大匹配</span><br></pre></td></tr></table></figure>
<p>双向匹配法（Bi-direction Matching  method, BM法）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">双向最大匹配法是将正向最大匹配法（FMM）得到的分词</span><br><span class="line">结果和逆向最大匹配法（BMM）得到的结果进行比较，从</span><br><span class="line">而决定正确的分词方法</span><br></pre></td></tr></table></figure>
<p>最少分词法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">• 分词结果中含词数最少</span><br><span class="line">• 优化代替了贪心</span><br><span class="line">• 等价于最短路径</span><br><span class="line">•算法：</span><br><span class="line">• 动态规划算法</span><br><span class="line">• 优点：好于单向的最大匹配方法</span><br><span class="line">• 最大匹配：独立自主/和平/等/互利/的/原则</span><br><span class="line">• 最短路径：独立自主/和/平等互利/的/原则</span><br><span class="line">• 缺点：忽略了所有覆盖歧义，也无法解决大部分交叉歧义</span><br><span class="line">• 结合成分子时</span><br><span class="line">• 结合|成分|子 &#123;&#125; 结|合成|分子 &#123;&#125; 结合|成|分</span><br></pre></td></tr></table></figure>
<h3 id="分词问题：歧义"><a href="#分词问题：歧义" class="headerlink" title="分词问题：歧义"></a>分词问题：歧义</h3><p>交集型切分歧义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">汉字串AJB被称作交集型切分歧义，如果满足AJ、JB同时</span><br><span class="line">为词(A、J、B分别为汉字串)。此时汉字串J被称作交集串。</span><br></pre></td></tr></table></figure>
<p>组合型切分歧义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• 汉字串AB被称作组合型切分歧义，如果满足条件：A、</span><br><span class="line">B、AB同时为词</span><br></pre></td></tr></table></figure>
<p>交集型歧义字段中含有交集字段的个数，称为链长</p>
<p>“真歧义”和“伪歧义”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• 真歧义指存在两种或两种以上的可实现的切分形式</span><br><span class="line">• 伪歧义一般只有一种正确的切分形式</span><br></pre></td></tr></table></figure>
<p>分词问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">歧义</span><br><span class="line">未登录词</span><br><span class="line">新词</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分词质量评价</p>
<p><img src="/2021/12/24/NLP/image-20211227193857156.png" alt="image-20211227193857156" style="zoom:50%;"></p>
<h2 id="中文分词-统计建模"><a href="#中文分词-统计建模" class="headerlink" title="中文分词_统计建模"></a>中文分词_统计建模</h2><h3 id="基于N元文法的分词（MM）"><a href="#基于N元文法的分词（MM）" class="headerlink" title="基于N元文法的分词（MM）"></a>基于N元文法的分词（MM）</h3><p>MM(马尔可夫模型/过程) ：有限历史假设，仅依 赖前n-1个词</p>
<p>一种最简化的情况：一元文法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P（S）=p(w1) ·p(w2) ·p(w3)….p(wn)</span><br><span class="line"> 等价于最大频率分词</span><br><span class="line"> 即把切分路径上每一个词的概率相乘得到该切</span><br><span class="line">分路径的概率</span><br><span class="line"> 把词概率的负对数理解成路径“代价”，输出</span><br><span class="line">结果就是整体代价最“小”分词序列</span><br></pre></td></tr></table></figure>
<p>采用二元语法(bi-gram)：性能进一步提高</p>
<p><img src="/2021/12/24/NLP/image-20211227195204331.png" alt="image-20211227195204331" style="zoom:50%;"></p>
<p> 更大的n：对下一个词出现的约束性信息更多，更大的辨别力。  更小的n：出现的次数更多，更可靠的统计结果，更高的可靠性。</p>
<p>等价类映射：降低语言模型参数空间</p>
<p>数据平滑（smoothing）：保持模型的辨别能力</p>
<h3 id="基于HMM的分词-词性标注一体化"><a href="#基于HMM的分词-词性标注一体化" class="headerlink" title="基于HMM的分词/词性标注一体化"></a>基于HMM的分词/词性标注一体化</h3><p>输入：待处理句子S </p>
<p> 输出：S的 词序列 W = w1 ,w2…wn </p>
<p>词性序列 T = t1 ,t2…tn </p>
<p> 提示  W可以代表S  分词结果即观测序列  词性序列是状态序列</p>
<p>公式推导</p>
<p><img src="/2021/12/24/NLP/image-20211227200001707.png" alt="image-20211227200001707" style="zoom:50%;"></p>
<p><img src="/2021/12/24/NLP/image-20211227200011651.png" alt="image-20211227200011651" style="zoom:50%;"></p>
<p><img src="/2021/12/24/NLP/image-20211227200200077.png" alt="image-20211227200200077"></p>
<h3 id="由字构词的汉语分词方法"><a href="#由字构词的汉语分词方法" class="headerlink" title="由字构词的汉语分词方法"></a>由字构词的汉语分词方法</h3><p>基本思路  分词过程：一个字的分类问题；  每个字在词语中属于一个确定位置</p>
<p>字的的标注过程中，对所有的字根据预定义的特 征进行词位特征学习，获得一个概率模型</p>
<p>由字构词的分词技术的优势</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> 简化了分词系统的设计  文本中的词表词和未登录词都是用统一的字 标注过程来实现的，分词过程成为字重组的 简单过程。  既可以不必专门强调词表词信息，也不用专 门设计特定的未登录词识别模块</span><br></pre></td></tr></table></figure>
<h3 id="汉语分词方法的后处理方法"><a href="#汉语分词方法的后处理方法" class="headerlink" title="汉语分词方法的后处理方法"></a>汉语分词方法的后处理方法</h3><p>为什么不采用更精巧的模型？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">四元或更高阶...  不可行，需要大量的参数  不得不做一些平滑或差值  难度随模型复杂度而加剧</span><br></pre></td></tr></table></figure>
<p>两个重要组成部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 允许的错误校正转换的详细说明</span><br><span class="line"> 学习算法</span><br></pre></td></tr></table></figure>
<p>输入数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个已经标注好的语料库，</span><br><span class="line">*一个词典</span><br></pre></td></tr></table></figure>
<p>基于转换错误驱动的规则方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 学习和标注在该方法种都是简单和直观的</span><br><span class="line"> 成功用于词性标注、句法分析、介词附着以及</span><br><span class="line">语义消歧</span><br><span class="line"> 经验上，没有出现过拟合现象</span><br><span class="line"> 可以被用来解决大部分后处理问题</span><br><span class="line"> 效率的提升优化，考验工程能力</span><br></pre></td></tr></table></figure>
<p>标注可以采用 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> 隐马尔科夫模型（HMM）  最大熵（ME）  最大熵马尔科夫模型（MEMM）  条件随机场（CRF）等</span><br></pre></td></tr></table></figure>
<h2 id="隐马尔科夫模型"><a href="#隐马尔科夫模型" class="headerlink" title="隐马尔科夫模型"></a>隐马尔科夫模型</h2><h3 id="马尔科夫-Markov-模型"><a href="#马尔科夫-Markov-模型" class="headerlink" title="马尔科夫(Markov)模型"></a>马尔科夫(Markov)模型</h3><p>马尔科夫模型是一种统计模型，广泛的应用在语音识别， 词性自动标注，音字转换，概率文法等各个自然语言处理 的应用领域。</p>
<p>随机过程又称为随机函数，是随时间随机变化的过程。马 尔科夫模型描述了一类重要随机过程。</p>
<p>系统在时间t处于状态𝑠𝑗的概率取决于其在时间1,2,…t-1的 状态，该概率为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">𝑃(𝑞𝑡 = 𝑠𝑗|𝑞𝑡−1 = 𝑠𝑖, 𝑞𝑡−2 = 𝑠𝑘, … )</span><br></pre></td></tr></table></figure>
<p>离散的一阶马尔科夫链：系统在时间t的状态只与时间t-1 的状态有关。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">𝑃(𝑞𝑡 = 𝑠𝑗|𝑞𝑡−1 = 𝑠𝑖, 𝑞𝑡−2 = 𝑠𝑘, … ) = 𝑃(𝑞𝑡 = 𝑠𝑗|𝑞𝑡−1 = 𝑠𝑖)</span><br></pre></td></tr></table></figure>
<p>状态转移概率𝑎𝑖𝑗必须满足以下条件：</p>
<p><img src="/2021/12/24/NLP/image-20211227203707059.png" alt="image-20211227203707059" style="zoom:50%;"></p>
<p>N个状态的一阶马尔科夫过程有𝑁2，可以表示成为一个状 态转移矩阵</p>
<p>eg:状态𝑠1：名词 状态𝑠2：动词 状态𝑠3：形容词</p>
<p>如果在该文字中某句子的第一个词为名词，那么该句子 中三类词出现顺序为O=“名动形名”的概率。</p>
<p><img src="/2021/12/24/NLP/image-20211227203903492.png" alt="image-20211227203903492" style="zoom:50%;"></p>
<p>马尔科夫(Markov)模型：有限状态机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">马尔科夫模型可视为随机的有限状态机。</span><br><span class="line">圆圈表示状态，状态之间的转移用带箭头的弧表示，弧上</span><br><span class="line">的数字为状态转移的概率。</span><br><span class="line">初始状态用标记为start的输入箭头表示。</span><br><span class="line">假设任何状态都可作为终止状态。</span><br><span class="line">对每个状态来说，发出弧上的概率和为1。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>eg:</p>
<p><img src="/2021/12/24/NLP/image-20211227204121800.png" alt="image-20211227204121800" style="zoom:50%;"></p>
<p>一般地，一个HMM记为一个五元组μ＝（S，K， A，B，π），其中，S为状态的集合，K为输出符 号的集合，π，A和B分别是初始状态的概率分布、 状态转移概率和符号发射概率。为了简单，有时也将其记为三元组μ＝（A，B，π）</p>
<p>隐马尔可夫模型：三个基本问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.估值问题：给定一个观察序列 O = 𝑂1𝑂2 … 𝑂𝑇 和模型μ＝(A，</span><br><span class="line">B，π)，如何快速地计算出给定模型μ情况下，观察序列O的</span><br><span class="line">概率，即𝑃 𝑂 𝜇 ?</span><br><span class="line">2.序列问题：给定一个观察序列 O = 𝑂1𝑂2 … 𝑂𝑇 和模型μ＝(A，</span><br><span class="line">B，π),如何快速有效的选择在一定意义下“最优”的状态序</span><br><span class="line">列 𝑄 = 𝑞1𝑞2 … 𝑞𝑇 ，使得该状态序列“最好的解释”观察序列？</span><br><span class="line">3.参数估计问题：给定一个观察序列O = 𝑂1𝑂2 … 𝑂𝑇，如何根</span><br><span class="line">据最大似然估计来求模型的参数值？即如何调节模型μ＝(A，</span><br><span class="line">B，π)的参数，使得𝑃 𝑂 𝜇 最大？</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="隐马尔可夫模型：求解观察序列的概率"><a href="#隐马尔可夫模型：求解观察序列的概率" class="headerlink" title="隐马尔可夫模型：求解观察序列的概率"></a>隐马尔可夫模型：求解观察序列的概率</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定观察序列O = 𝑂1𝑂2 … 𝑂𝑇和模型𝜇 =(𝐴, 𝐵, π)，快速的计算出给定模型𝜇情况下观察序列O的概率，即𝑃 （𝑂|𝜇） 。</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/24/NLP/image-20211227210645264.png" alt="image-20211227210645264" style="zoom:50%;"></p>
<p>隐马尔可夫模型：前向算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本思想：定义前向变量𝛼𝑡(𝑖)，前向变量𝛼𝑡(𝑖)是在时间t，HMM输出了序列𝑂1𝑂2 … 𝑂𝑡 ，并且位于状态𝑠𝑖的概率。</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/24/NLP/image-20211227211103464.png" alt="image-20211227211103464" style="zoom:50%;"></p>
<p>前向算法总的复杂度为O(𝑁2𝑇)</p>
<p>隐马尔可夫模型：后向算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后向变量𝛽𝑡(𝑖)是在给定模型𝜇 = (𝐴, 𝐵, π)，并且在时间t状态为𝑠𝑖的条件下，HMM输出观察序列𝑂𝑡+1 … 𝑂𝑇的概率。</span><br></pre></td></tr></table></figure>
<p>与计算前向变量一样，可以用动态规划的算法计算后向变量。</p>
<p><img src="/2021/12/24/NLP/image-20211227211441031.png" alt="image-20211227211441031" style="zoom:50%;"></p>
<p>时间复杂度：O(𝑁2𝑇)</p>
<h4 id="序列问题"><a href="#序列问题" class="headerlink" title="序列问题"></a>序列问题</h4><p>隐马尔可夫模型：维特比算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">维特比算法用于求解HMM中的第二个问题，给定一个观</span><br><span class="line">察序列O = 𝑂1𝑂2 … 𝑂𝑇和模型𝜇 = (𝐴, 𝐵, π)，如何快速有效</span><br><span class="line">的选择在一定意义下最优的状态序列𝑄 = 𝑞1𝑞2 … 𝑞𝑇，使得</span><br><span class="line">该状态序列“最好的解释”观察序列。</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/24/NLP/image-20211227211917788.png" alt="image-20211227211917788" style="zoom:50%;"></p>
<p><img src="/2021/12/24/NLP/image-20211227211938609.png" alt="image-20211227211938609" style="zoom:50%;"></p>
<p>存在问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单独最优不一定整体最优</span><br></pre></td></tr></table></figure>
<h4 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h4><p>最 大似然估计</p>
<p>EM</p>
<h2 id="句法分析"><a href="#句法分析" class="headerlink" title="句法分析"></a>句法分析</h2><h3 id="句法分析概述"><a href="#句法分析概述" class="headerlink" title="句法分析概述"></a>句法分析概述</h3><p>基本任务：确定句子的句法结构或句子中词汇之间的依存关系。</p>
<p>定义：判断单词序列（一般为句子）判读其构成是否合乎 给定的语法(recognition)，如果是，则给出其（树）结构 (parsing)</p>
<p>描述一种语言可以有三种途径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">穷举法：把语言中的所有句子都枚举出来。显然，这种方法只适合句子数目有限的语</span><br><span class="line">语法/文法描述：语言中的每个句子用严格定义的规则来构造，利用规则生成语言中合法的句子</span><br><span class="line">自动机法：通过对输入句子进行合法性检验，区别哪些是语言中的句子，哪些不是语言中的句子</span><br></pre></td></tr></table></figure>
<p>形式语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">四元组 𝐺 = &#123;𝑁, Σ, 𝑃, 𝑆&#125;</span><br><span class="line">𝑁是非终结符(non-terminal symbol)的有限集合(有时也称变量集或句法种类集)</span><br><span class="line">Σ是终结符号(terminal symbol)的有限集合，𝑁 ∩ Σ = ∅</span><br><span class="line">𝑃是一组重写规则的有限集合：𝑃 = 𝛼 → 𝛽 ，其中𝛼, 𝛽是由V中元素构成的串，但是𝛼中至少应含一个非终结符</span><br><span class="line">𝑆 ∈ 𝑁称为句子符或初始符</span><br></pre></td></tr></table></figure>
<p>形式语法种类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正则文法</span><br><span class="line">上下文无关文法</span><br><span class="line">上下文相关文法</span><br><span class="line">无约束文法</span><br></pre></td></tr></table></figure>
<p>控制策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">自顶向下、自底向上</span><br><span class="line">移进-归约是自底向上语法分析的一种形式</span><br><span class="line"> 使用一个栈来保存文法符号，并用一个输入缓冲区来存放将要进行语</span><br><span class="line">法分析的其余符号</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>搜索策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">深搜广搜</span><br></pre></td></tr></table></figure>
<p>扫描策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自左至右，自右至左</span><br></pre></td></tr></table></figure>
<p>移进-归约是自底向上语法分析的一种形式</p>
<p>CFG缺陷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 对于一个中等长度的输入句子来说，要利用大覆盖度的语法规</span><br><span class="line">则分析出所有可能的句子结构是非常困难的，分析过程的复杂</span><br><span class="line">度往往使程序无法实现</span><br><span class="line"> 即使能分析出句子所有可能的结构，也难以在巨大的句法分析</span><br><span class="line">结果集中实现有效的消歧，并选择出最有可能的分析结果</span><br><span class="line"> 手工编写的规则一般带有一定的主观性，对于实际应用系统来</span><br><span class="line">说，往往难以覆盖大领域的所有复杂语言</span><br><span class="line"> 写规则本身是一件大工作量的复杂劳动，而且编写的规则对特</span><br><span class="line">定的领域有密切的相关性，不利于句法分析系统向其他领域移</span><br><span class="line">植</span><br></pre></td></tr></table></figure>
<h3 id="概率上下文无关文法-PCFG"><a href="#概率上下文无关文法-PCFG" class="headerlink" title="概率上下文无关文法(PCFG)"></a>概率上下文无关文法(PCFG)</h3><p>概率上下文无关文法就是一个为规则增添了概率的简单CFG， 指明了不同重写规则的可能性大小</p>
<p>在基于PCFG的句法分析模型中，假设满足以下三个条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上下文无关性</span><br><span class="line">祖先无关性</span><br><span class="line">位置不变性</span><br></pre></td></tr></table></figure>
<p>剪枝策略：Beam search（集束搜索）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一种启发式图搜索算法，为了减少搜索占用的时间和空间，在每一步深度扩展的时候，</span><br><span class="line">减掉一些质量比较差的节点，保留质量较高的一些节点</span><br><span class="line">优点是减少空间消耗，提高时间效率</span><br><span class="line">缺点是有可能存在潜在的最佳方案被丢弃，beam search算法是不完全的</span><br></pre></td></tr></table></figure>
<p>PCFG的优点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可利用概率减少分析过程的搜索空间</span><br><span class="line">可以利用概率对概率较小的子树剪枝，加快分析效</span><br><span class="line">率</span><br><span class="line">可以定量地比较两个语法的性能</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PCFG的缺陷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结构相关性</span><br><span class="line">词汇相关性</span><br></pre></td></tr></table></figure>
<h2 id="词义消歧"><a href="#词义消歧" class="headerlink" title="词义消歧"></a>词义消歧</h2><p>word sense disambiguation     WSD</p>
<p>义位：语义系统中能独立存在的基本语义单位</p>
<p>WSD需要解决三个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)如何判断一个词是不是多义词？ 如何表示一个多义词的不同意思？</span><br><span class="line">(2)对每个多义词，预先要有关于它的 各个不同义项的清晰的区分标准</span><br><span class="line">(3)对出现在具体语境中的每个多义词，为它确定一个合适的义项</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基于机器词典的WSD</span><br><span class="line">基于义类词典的WSD</span><br><span class="line">基于语料库的WSD</span><br><span class="line">基于统计方法的WSD</span><br><span class="line">基于规则的WSD</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">用词典资源进行词义排歧，是利用词典中对多义</span><br><span class="line">词的各个义项的描写，求多义词的释义跟其上下</span><br><span class="line">文环境词的释义之间的交集，判断词义的亲和程</span><br><span class="line">度，来确定词义；</span><br><span class="line">由于词典释义的概括性，这种方法应用于实际语</span><br><span class="line">料中多义词的排歧，效果不一定理想</span><br></pre></td></tr></table></figure>
<p>基于义类词典的WSD方法</p>
<p><img src="/2021/12/24/NLP/image-20211227233833336.png" alt="image-20211227233833336" style="zoom:50%;"></p>
<p>互信息：I（X；Y）反映的是在知道了Y的值 以后X的不确定性的减少量。</p>
<p>基于Bayes判别的WSD方法</p>
<p><img src="/2021/12/24/NLP/image-20211227235729108.png" alt="image-20211227235729108" style="zoom:50%;"></p>
<p>词义消歧——基于多分类器集成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">总结</span><br><span class="line">还有很多问题需要探讨</span><br><span class="line">❖如何选用更有效的分类器</span><br><span class="line">❖单分类器的结果怎样更高效地集成</span><br><span class="line">❖如何在单分类器中选取更有效的特征</span><br><span class="line"> 集成学习的研究对自然语言处理中的其他任务</span><br></pre></td></tr></table></figure>
<h2 id="篇章"><a href="#篇章" class="headerlink" title="篇章"></a>篇章</h2><p>概念</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Anaphor:指代语</span><br><span class="line">Entity(referent):实体（指称对象）</span><br><span class="line">Reference:指称。用于指称实体的语言表示</span><br><span class="line">Antecedent:先行语。语篇中引入的一个相对明确的指称意义表述（如张三）；</span><br><span class="line">Coreference:共指（同指）。当两种表述均指称相同对象（实体）时，这两种表述具有共指关系</span><br></pre></td></tr></table></figure>
<p>六类指称表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Indefinite NPs（不定名词）: 一辆汽车</span><br><span class="line"> Definite NPs （有定名词）: 那个人</span><br><span class="line"> Pronouns （人称代词）: 它，他</span><br><span class="line"> Demonstratives （指示代词）: 这，那</span><br><span class="line"> One-anaphora （one指代）: one (in English)</span><br><span class="line"> Zero anaphora （0型指代）: 省略</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>指代一般包括两种情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">– 回指(Anaphora)：强调指代语与另一个表述之间的关</span><br><span class="line">系。指代语的指称对象通常不明确，需要确定其与先行</span><br><span class="line">语之间的关系来解释指代语的语义</span><br><span class="line">• 张先生走过来，给大家看他的新作品</span><br><span class="line">– 共指(coreference)：强调一个表述与另一个表述是否</span><br><span class="line">指向相同的实体，可以独立于上下文存在</span><br><span class="line">• 第44任美国总统 与奥巴马</span><br></pre></td></tr></table></figure>
<h3 id="衔接和连贯"><a href="#衔接和连贯" class="headerlink" title="衔接和连贯"></a>衔接和连贯</h3><p>以词汇表示的关联，通常称为“衔接(cohesion)，强调其构成成分</p>
<p>通过句子意义表示的关联称为连贯Coherence，强调整体上表达某种意义</p>
<h3 id="篇章表示和相似度计算"><a href="#篇章表示和相似度计算" class="headerlink" title="篇章表示和相似度计算"></a>篇章表示和相似度计算</h3><p>将文档表示为如下所示的向量： 𝑑𝑗 = (𝑤1,𝑗 , 𝑤2,𝑗 , 𝑤3,𝑗 , … , 𝑤𝑡,𝑗)  向量的每一维都对应于词表中的一个词。  如果某个词出现在了文档中，那它在向量中的值就非 零。  这个值有很多计算方法，我们使用词语在文档中出现 的次数表示。</p>
<h2 id="机器翻译"><a href="#机器翻译" class="headerlink" title="机器翻译"></a>机器翻译</h2><h3 id="传统机器翻译方法"><a href="#传统机器翻译方法" class="headerlink" title="传统机器翻译方法"></a>传统机器翻译方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接翻译法</span><br></pre></td></tr></table></figure>
<p>基于规则的翻译方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对源语言和目标语言均进行适当描述</span><br><span class="line">吧翻译机制与语法分开</span><br><span class="line">用规则描述语法的翻译方式</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">▪优点：</span><br><span class="line">▪ 可以较好地保持原文的结构，产生的译文结构与源文的结构关系密切</span><br><span class="line">▪ 尤其对于语言现象的或句法结构的明确的源语言语句具有较强的处理能力</span><br><span class="line">▪弱点：</span><br><span class="line">▪ 规则一般由人工编写，工作量大，主观性强，一致性难以保障</span><br><span class="line">▪ 不利于系统扩充，对非规范语言现 象缺乏相应的处理能力</span><br></pre></td></tr></table></figure>
<p>基于实例的翻译方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法：输入语句-&gt;与事例相似度比较-&gt;翻译结果</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">▪ 方法优点</span><br><span class="line">▪ 不要求源语言句子必须符合语法规定;</span><br><span class="line">▪ 翻译机制一般不需要对源语言句子做深入分析;</span><br><span class="line">▪ 方法弱点</span><br><span class="line">▪ 两个不同的句子之间的相似性(包括结构相似性和语义相似性)往往难以把握</span><br><span class="line">▪ 在口语中，句子结构一般比较松散，成分冗余和成分省略都较严重;</span><br><span class="line">▪ 系统往往难以处理事例库中没有记录的陌生的语言现象；</span><br><span class="line">▪ 当事例库达到一定规模时，其事例检索的效率较低;</span><br></pre></td></tr></table></figure>
<h3 id="基于统计的机器翻译模型"><a href="#基于统计的机器翻译模型" class="headerlink" title="基于统计的机器翻译模型"></a>基于统计的机器翻译模型</h3><p>噪声信道模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种语言T 由于经过一个噪声信道而发生变形从而在信道的另一端呈现为另一种语言 S</span><br></pre></td></tr></table></figure>
<p>翻译问题可定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">▪ 如何根据观察到的 S，恢复最为可能的T 问题。</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/24/NLP/image-20211228101907190.png" alt="image-20211228101907190" style="zoom:50%;"></p>
<p>▪三个关键问题 ▪ (1)估计语言模型概率 p(T)； ▪ (2)估计翻译概率 p(S|T)； ▪ (3)快速有效地搜索T 使得 p(T)×p(S | T) 最大</p>
<h4 id="基于词的统计机器翻译模型"><a href="#基于词的统计机器翻译模型" class="headerlink" title="基于词的统计机器翻译模型"></a>基于词的统计机器翻译模型</h4><p>IBM模型1：词汇翻译（词对齐）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">▪ 基于词的统计翻译模型</span><br><span class="line">▪ 引入了词对齐的问题</span><br><span class="line">▪ 通过EM算法学习词对齐</span><br><span class="line">▪ 缺陷</span><br><span class="line">▪ 无法刻画翻译过程中重排序、添词、舍词等情况；</span><br><span class="line">▪ 例如：</span><br><span class="line">▪ Seldom do I go to work by bus.</span><br><span class="line">▪ 我很少乘公共汽车上班</span><br></pre></td></tr></table></figure>
<p>IBM模型2：增加绝对对齐模型</p>
<p>IBM模型3：引入繁衍率模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前述模型存在的问题</span><br><span class="line">▪ 在随机选择对位关系的情况下，与目标语言句子中的单词t对应的源语言句子中的单</span><br><span class="line">词数目是一个随机变量；</span><br></pre></td></tr></table></figure>
<p>繁衍率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义：与目标语言句子中的单词t对应的源语言句子中的单词数目的变量</span><br><span class="line">▪ 记做Фt，称该变量为单词t的繁衍能力或产出率(fertility)。一个具体的取值记做：Фt</span><br><span class="line">▪ 繁衍率刻画的是目标语言单词与源语言单词之间一对多的关系</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="基于短语的统计机器翻译模型"><a href="#基于短语的统计机器翻译模型" class="headerlink" title="基于短语的统计机器翻译模型"></a>基于短语的统计机器翻译模型</h4><p>基本思想</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">▪ 把训练语料库中所有对齐的短语及其翻译概率存储起来，作为一部带</span><br><span class="line">概率的短语词典</span><br><span class="line">▪ 这里所说的短语是任意连续的词串，不一定是一个独立的语言单位</span><br><span class="line">▪ 翻译的时候将输入的句子与短语词典进行匹配，选择最好的短语划分，</span><br><span class="line">将得到的短语译文重新排序，得到最优的译文.</span><br></pre></td></tr></table></figure>
<h3 id="系统融合"><a href="#系统融合" class="headerlink" title="系统融合"></a>系统融合</h3><p>几个相似的系统执行同一个任务时，可能有多个输出结果，系统融合将这些结果进行融 合，抽取其有用信息，归纳得到任务的最终输出结果。</p>
<p>目标：最终的输出比之前的输入结果都要好</p>
<p>句子级系统融合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两种技术</span><br><span class="line">最小贝叶斯风险解码；通用线性模型</span><br></pre></td></tr></table></figure>
<p>句子级系统融合方法不会产生新的翻译句子，而是在已有的翻 译句子中挑选出最好的一个</p>
<p>短语级系统融合 ▪ 利用多个翻译系统的输出结果，重新抽取短语翻译规则集合，并利用 新的短语翻译规则进行重新解码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本思想：首先合并参与融合的所有系统的短语表，从中抽取</span><br><span class="line">一个新的源语言到目标语言的短语表，然后使用新的短语表和</span><br><span class="line">语言模型去重新解码源语言句子。</span><br></pre></td></tr></table></figure>
<p>词语级系统融合 ▪ 首先将多个翻译系统的译文输出进行词语对齐，构建一个混淆网络， 对混淆网络中的每个位置的候选词进行置信度估计， 最后进行混淆网 络解码</p>
<p>小结</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">句子级系统融合</span><br><span class="line">▪ 未生成新的翻译假设，有效的保护原来翻译假设中短语的连续性和句子词序，但</span><br><span class="line">是也没有吸收借鉴其他翻译假设中词或者短语层次的知识。</span><br><span class="line">▪ 短语级系统融合</span><br><span class="line">▪ 借鉴其他翻译系统的短语表知识，利用传统的基于短语的翻译引擎来重新解码源</span><br><span class="line">语言的句子。有效的保持短语的连续性和译文的局部词序。但是不能很好的利用</span><br><span class="line">非连续短语和句法知识来克服译文的远距离调序问题</span><br><span class="line">▪ 词语级系统融合</span><br><span class="line">▪ 从词的粒度重组了输出译文，充分利用了各个翻译假设的词汇级别的知识，取长</span><br><span class="line">补短。但是在混淆网络解码时，并不能保证新生成的翻译句子的词序一致性和短</span><br><span class="line">语连续性</span><br></pre></td></tr></table></figure>
<h2 id="应用：语言自动生成"><a href="#应用：语言自动生成" class="headerlink" title="应用：语言自动生成"></a>应用：语言自动生成</h2><h3 id="自然语言生成概述"><a href="#自然语言生成概述" class="headerlink" title="自然语言生成概述"></a>自然语言生成概述</h3><p>NLG生成模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 马尔可夫链：通过当前单词可以预测句子中的下一个单</span><br><span class="line">词。</span><br><span class="line">缺点：无法探测当前单词与句子中其他单词的关系以及句</span><br><span class="line">子的结构，使得预测结果不够准确。</span><br><span class="line">2. 循环神经网络(RNN)：通过前馈网络传递序列的每个项目</span><br><span class="line">信息，并将模型的输出作为序列中下一项的输入，每个项</span><br><span class="line">目存储前面步骤中的信息。</span><br><span class="line">优点：能够捕捉输入数据的序列特征</span><br><span class="line">缺点：第一，RNN短期记忆无法生成连贯的长句子；第二，</span><br><span class="line">因为 RNN 不能并行计算，无法适应主流趋势。</span><br><span class="line">3. 长短期记忆网络(LSTM)，解决梯度消失问题，但难以并行化</span><br><span class="line">4. Seq2Seq，能够解决大部分序列不等长的问题</span><br><span class="line">5. Attention模型</span><br><span class="line">6. Transformer模型，能够在不考虑单词位置的情况</span><br><span class="line">下，直接捕捉句子中所有单词之间的关系</span><br><span class="line">7. ELMO模型</span><br><span class="line">8. BERT模型</span><br></pre></td></tr></table></figure>
<h3 id="数据到文本的生成"><a href="#数据到文本的生成" class="headerlink" title="数据到文本的生成"></a>数据到文本的生成</h3><p>以包含键值对的数据作为输入，旨在 自动生成流畅的、贴近事实的文本以描 述输入数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 信号分析模块(Siganl Analysis)</span><br><span class="line"> 数据阐释模块(Data Interpretation)</span><br><span class="line"> 文档规划模块(Document Planning)</span><br><span class="line"> 微规划与实现模块(Microplanning and Realisation)</span><br></pre></td></tr></table></figure>
<p>应用领域：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 天气预报领域的文本生成系统</span><br><span class="line"> 针对空气质量的文本生成系统</span><br><span class="line"> 针对财经数据的文本生成系统</span><br><span class="line"> 面向医疗诊断数据的文本生成系统</span><br><span class="line"> 基于体育数据生成文本摘要</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="文本到文本的生成"><a href="#文本到文本的生成" class="headerlink" title="文本到文本的生成"></a>文本到文本的生成</h3><p>对给定文本进行变换和处理从而获得新文本的技术</p>
<p>应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 对联自动生成</span><br><span class="line"> 诗歌自动生成</span><br><span class="line"> 作文自动生成</span><br><span class="line"> 对话生成*---这个任务现阶段一般不作为NLG的研究分支来探讨</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="词和文档表示与相似度计算"><a href="#词和文档表示与相似度计算" class="headerlink" title="词和文档表示与相似度计算"></a>词和文档表示与相似度计算</h2><h3 id="词的表示"><a href="#词的表示" class="headerlink" title="词的表示"></a>词的表示</h3><p>独热表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个词对应一个向量，向量的维度等于词典的大小，向量中只有一个元素值为1，其余的元素均为0 ，值为1的元素对应的下标为该词在词典中的位置</span><br></pre></td></tr></table></figure>
<p>词频 -逆文档频率(TF -IDF)</p>
<p>词嵌入方法的问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">静态词向量</span><br><span class="line">词向量无法随语境变化</span><br><span class="line">不能处理一词多义</span><br><span class="line">多义词无法区分多个含义</span><br><span class="line">不能有效区分反义词</span><br><span class="line">反义词的上下文很相似</span><br></pre></td></tr></table></figure>
<p>词向量</p>
<p>skip-gram</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 将目标词和邻近的 </span><br><span class="line">语境词作为正面例子。</span><br><span class="line">2.随机抽取词库中的其他词 </span><br><span class="line">词库中的其他词，以获得负面样本。</span><br><span class="line">3. 使用逻辑回归来训练一个分类器，以区分这两种情况。</span><br><span class="line">区分这两种情况。</span><br><span class="line">4. 使用权重作为嵌入。</span><br></pre></td></tr></table></figure>
<h3 id="文档表示"><a href="#文档表示" class="headerlink" title="文档表示"></a>文档表示</h3><p><img src="/2021/12/24/NLP/image-20211228162546651.png" alt="image-20211228162546651" style="zoom:50%;"></p>
<h3 id="文本相似度计算"><a href="#文本相似度计算" class="headerlink" title="文本相似度计算"></a>文本相似度计算</h3><p>编辑距离，动态规划</p>
<h2 id="信息抽取"><a href="#信息抽取" class="headerlink" title="信息抽取"></a>信息抽取</h2><h3 id="信息抽取的定义、任务及发展"><a href="#信息抽取的定义、任务及发展" class="headerlink" title="信息抽取的定义、任务及发展"></a>信息抽取的定义、任务及发展</h3><p>信息抽取中的主要任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">命名实体识别：</span><br><span class="line">识别和分类文本中出现的“实体提及”</span><br><span class="line">实体链接：</span><br><span class="line">将“实体提及”链接到知识库中对应的实体</span><br><span class="line">关系抽取：</span><br><span class="line">找到句子中有关系的两个实体，并识别出他们之间的关系类型</span><br><span class="line">事件抽取：</span><br><span class="line">事件抽取就要是找到一个事件对应的元素。</span><br></pre></td></tr></table></figure>
<h3 id="命名实体识别"><a href="#命名实体识别" class="headerlink" title="命名实体识别"></a>命名实体识别</h3><p>挑战</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">种类繁多，命名方式灵活多样</span><br><span class="line">同一实体对应很多变体</span><br><span class="line">相同的词或者短语可以表示不同类别的实</span><br><span class="line">体</span><br><span class="line">存在嵌套</span><br><span class="line">细粒度</span><br><span class="line">语言不断进化，新的挑战不断出现</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主要方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于规则的方法 基于词典的方法 机器学习方法 ◼最大熵 ◼条件随机场 ◼深度学</span><br></pre></td></tr></table></figure>
<p>命名实体识别的评价</p>
<p><img src="/2021/12/24/NLP/image-20211228163639194.png" alt="image-20211228163639194" style="zoom:50%;"></p>
<p><img src="/2021/12/24/NLP/image-20211228163649954.png" alt="image-20211228163649954" style="zoom:50%;"></p>
<h3 id="实体链接"><a href="#实体链接" class="headerlink" title="实体链接"></a>实体链接</h3><p>将“实体提及”链接到知识库中对应的实体</p>
<h3 id="关系抽取"><a href="#关系抽取" class="headerlink" title="关系抽取"></a>关系抽取</h3><p>自动识别由一对实体和联系这对实体的关系构成的 相关三元组</p>
<p>预定义关系抽取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">任务</span><br><span class="line">给定实体关系类别，给定语料，抽取目标关系对</span><br><span class="line">评测语料（MUC, ACE, KBP, SemEval）</span><br><span class="line">专家标注语料，语料质量高</span><br><span class="line">抽取的目标类别已经定义好</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基于神经网络的关系抽取方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要问题：如何设计合理的网络结构，从而捕捉更多的信息，进而更准确的完成关系的抽取</span><br><span class="line">网络结构：不同的网络结构捕捉文本中不同的信息</span><br></pre></td></tr></table></figure>
<p>开放域关系抽取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">实体类别和关系类别不固定、数量大</span><br><span class="line">难点问题</span><br><span class="line"> 如何获取训练语料</span><br><span class="line"> 如何获取实体关系类别</span><br><span class="line"> 如何针对不同类型目标文本抽取关系</span><br><span class="line">需要研究新的抽取方法</span><br><span class="line"> 基于句法的方法</span><br><span class="line"> 基于知识监督的方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="深度学习简介"><a href="#深度学习简介" class="headerlink" title="深度学习简介"></a>深度学习简介</h2><p>常用的深度学习模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">激活函数</span><br><span class="line">深度神经网络（Deep Neural Network, DNN）</span><br><span class="line">卷积神经网络（Convolutional Neural Network,CNN)</span><br><span class="line">循环神经网络 (Recurrent Neural Network, RNN) </span><br><span class="line">注意力机制（Attention Mechanisms）</span><br></pre></td></tr></table></figure>
<p>pooling</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">目的：</span><br><span class="line">扩大视野：就如同先从近处看一张图片，然后离远一些再看同一张图片，有些细节就会被忽略。</span><br><span class="line">降维：在保留图片局部特征的前提下，使得图片更小，更易于计算。</span><br><span class="line">平移不变性，轻微扰动不会影响输出。</span><br><span class="line">维持同尺寸，便于后端处理。</span><br></pre></td></tr></table></figure>
<p>深度学习模型的应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DBN的应用</span><br><span class="line">基于DBN的问答对挖掘</span><br><span class="line">CNN的应用</span><br><span class="line">关系分类</span><br><span class="line">句子分类</span><br><span class="line">LSTM-RNN的应用</span><br><span class="line">命名实体识别</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">深度学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-24 17:07:48" itemprop="dateCreated datePublished" datetime="2021-12-24T17:07:48+08:00">2021-12-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">计算机组织原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-13 16:49:24" itemprop="dateCreated datePublished" datetime="2021-12-13T16:49:24+08:00">2021-12-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/09/ASP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/09/ASP/" class="post-title-link" itemprop="url">ASP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-09 21:45:59" itemprop="dateCreated datePublished" datetime="2021-12-09T21:45:59+08:00">2021-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-11 22:43:48" itemprop="dateModified" datetime="2021-12-11T22:43:48+08:00">2021-12-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="简单登录程序"><a href="#简单登录程序" class="headerlink" title="简单登录程序"></a>简单登录程序</h3><p>跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.Redirect(&quot;URL&quot;)</span><br></pre></td></tr></table></figure>
<p>返回弹窗</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.Write(&quot;&lt;script&gt;alter(&#x27;用户名或密码错误&#x27;);&lt;/script&gt;&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="文本框的使用"><a href="#文本框的使用" class="headerlink" title="文本框的使用"></a>文本框的使用</h3><p>text默认为单行模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;单行模式&lt;/p&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;asp:TextBox ID=&quot;TextBox1&quot; runat=&quot;server&quot;&gt;&lt;/asp:TextBox&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">    &lt;p&gt;密码模式&lt;/p&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;asp:TextBox ID=&quot;TextBox2&quot; runat=&quot;server&quot; TextMode=&quot;Password&quot;&gt;&lt;/asp:TextBox&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">    &lt;p&gt;多行模式&lt;/p&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;asp:TextBox ID=&quot;TextBox3&quot; runat=&quot;server&quot; TextMode=&quot;MultiLine&quot;&gt;&lt;/asp:TextBox&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/09/ASP/image-20211209221532497.png" alt="image-20211209221532497" style="zoom:50%;"></p>
<p>属性栏修改。</p>
<h3 id="判断单选框"><a href="#判断单选框" class="headerlink" title="判断单选框"></a>判断单选框</h3><p>单选框将GroupName设置为一样即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;label&gt;性别&lt;/label&gt;</span><br><span class="line">        &lt;asp:RadioButton ID=&quot;RadioButton1&quot; runat=&quot;server&quot; Text=&quot;男&quot; GroupName=&quot;sex&quot;/&gt;</span><br><span class="line">        &amp;nbsp;&amp;nbsp</span><br><span class="line">        &lt;asp:RadioButton ID=&quot;RadioButton2&quot; runat=&quot;server&quot; Text=&quot;女&quot; GroupName=&quot;sex&quot;/&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;asp:Button ID=&quot;Button1&quot; runat=&quot;server&quot; Text=&quot;提交&quot; OnClick=&quot;Button1_Click2&quot;  /&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void Button1_Click2(object sender, EventArgs e)</span><br><span class="line">   &#123;</span><br><span class="line">       if (RadioButton1.Checked == true)</span><br><span class="line">       &#123;</span><br><span class="line">           Response.Write(&quot;&lt;script&gt;alert(&#x27;性别为男&#x27;);&lt;/script&gt;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (RadioButton2.Checked == true)</span><br><span class="line">       &#123;</span><br><span class="line">           Response.Write(&quot;&lt;script&gt;alert(&#x27;性别为女&#x27;);&lt;/script&gt;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断多选框"><a href="#判断多选框" class="headerlink" title="判断多选框"></a>判断多选框</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“+string+”</span><br></pre></td></tr></table></figure>
<h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;asp:DropDownList ID=&quot;DropDownList1&quot; runat=&quot;server&quot;&gt;</span><br><span class="line">           &lt;asp:ListItem&gt;原平&lt;/asp:ListItem&gt;</span><br><span class="line">           &lt;asp:ListItem&gt;忻州&lt;/asp:ListItem&gt;</span><br><span class="line">           &lt;asp:ListItem&gt;五台&lt;/asp:ListItem&gt;</span><br><span class="line">           &lt;asp:ListItem&gt;定襄&lt;/asp:ListItem&gt;</span><br><span class="line">           &lt;asp:ListItem&gt;五寨&lt;/asp:ListItem&gt;</span><br><span class="line">       &lt;/asp:DropDownList&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DropDownList1.SelectedItem.Value</span><br><span class="line">DropDownList1.SelectedValue</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="呈现信息"><a href="#呈现信息" class="headerlink" title="呈现信息"></a>呈现信息</h3><p>构造一个用于盛放HTML代码的变量，用Response.Write(HTML),可先用Response.Clear()清理当前页面</p>
<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>Convert.ToDouble()</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">catch(Exception es)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a>显示数据</h3><p><img src="/2021/12/09/ASP/image-20211210120304445.png" alt="image-20211210120304445"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inf.InnerHtml=HTML;</span><br></pre></td></tr></table></figure>
<h3 id="读取全部数据"><a href="#读取全部数据" class="headerlink" title="读取全部数据"></a>读取全部数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foreach</span><br></pre></td></tr></table></figure>
<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p><img src="/2021/12/09/ASP/image-20211210135917242.png" alt="image-20211210135917242" style="zoom:50%;"></p>
<p><img src="/2021/12/09/ASP/image-20211210135930367.png" alt="image-20211210135930367" style="zoom:50%;"></p>
<h3 id="初始"><a href="#初始" class="headerlink" title="初始"></a>初始</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;/system.web&gt;</span><br><span class="line">	&lt;system.webServer&gt;</span><br><span class="line">		&lt;defaultDocument&gt;</span><br><span class="line">			&lt;files&gt;</span><br><span class="line">				&lt;clear/&gt;</span><br><span class="line">				&lt;add value=&quot;index.aspk&quot;/&gt;</span><br><span class="line">			&lt;/files&gt;</span><br><span class="line">		&lt;/defaultDocument&gt;</span><br><span class="line">	&lt;/system.webServer&gt;</span><br></pre></td></tr></table></figure>
<h3 id="显示表"><a href="#显示表" class="headerlink" title="显示表"></a>显示表</h3><p><img src="/2021/12/09/ASP/image-20211210175458347.png" alt="image-20211210175458347"></p>
<h3 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h3><p><img src="/2021/12/09/ASP/image-20211210184423626.png" alt="image-20211210184423626"></p>
<p><img src="/2021/12/09/ASP/image-20211210184758134.png" alt="image-20211210184758134"></p>
<p><img src="/2021/12/09/ASP/image-20211210185030345.png" alt="image-20211210185030345"></p>
<p><img src="/2021/12/09/ASP/image-20211210185043844.png" alt="image-20211210185043844"></p>
<p><img src="/2021/12/09/ASP/image-20211210190952668.png" alt="image-20211210190952668"></p>
<p><img src="/2021/12/09/ASP/image-20211210191832719.png" alt="image-20211210191832719"></p>
<p><img src="/2021/12/09/ASP/image-20211210191935390.png" alt="image-20211210191935390"></p>
<p><img src="/2021/12/09/ASP/image-20211211204121826.png" alt="image-20211211204121826"></p>
<p><img src="/2021/12/09/ASP/image-20211211204221557.png" alt="image-20211211204221557"></p>
<p><img src="/2021/12/09/ASP/image-20211211204301439.png" alt="image-20211211204301439"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/07/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%AE%A4%E7%AE%A1%E7%90%86%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/07/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%AE%A4%E7%AE%A1%E7%90%86%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">学校教室管理信息系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-07 15:23:19" itemprop="dateCreated datePublished" datetime="2021-12-07T15:23:19+08:00">2021-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-24 20:48:41" itemprop="dateModified" datetime="2022-04-24T20:48:41+08:00">2022-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数据库部分"><a href="#数据库部分" class="headerlink" title="数据库部分"></a>数据库部分</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建数据库School Classroom Management Information System-SCMIS</span></span><br><span class="line"><span class="keyword">create</span> database SCMIS</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">primary</span></span><br><span class="line">(</span><br><span class="line">name<span class="operator">=</span><span class="string">&#x27;f1&#x27;</span>,</span><br><span class="line">filename<span class="operator">=</span><span class="string">&#x27;F:\sqlserver\sqlwj\scmis\f1.mdf&#x27;</span>,</span><br><span class="line">size<span class="operator">=</span><span class="number">3</span>mb,</span><br><span class="line">maxsize<span class="operator">=</span>unlimited,</span><br><span class="line">filegrowth<span class="operator">=</span><span class="number">3</span><span class="operator">%</span></span><br><span class="line">),</span><br><span class="line">(</span><br><span class="line">name<span class="operator">=</span><span class="string">&#x27;f2&#x27;</span>,</span><br><span class="line">filename<span class="operator">=</span><span class="string">&#x27;F:\sqlserver\sqlwj\scmis\f2.ndf&#x27;</span>,</span><br><span class="line">size<span class="operator">=</span><span class="number">10</span>mb,</span><br><span class="line">maxsize<span class="operator">=</span><span class="number">500</span>mb,</span><br><span class="line">filegrowth<span class="operator">=</span><span class="number">6</span>mb</span><br><span class="line">)</span><br><span class="line">log <span class="keyword">on</span></span><br><span class="line">(</span><br><span class="line">name<span class="operator">=</span><span class="string">&#x27;f3&#x27;</span>,</span><br><span class="line">filename<span class="operator">=</span><span class="string">&#x27;F:\sqlserver\sqlwj\scmis\f3.ldf&#x27;</span>,</span><br><span class="line">size<span class="operator">=</span><span class="number">1</span>mb,</span><br><span class="line">maxsize<span class="operator">=</span>unlimited,</span><br><span class="line">filegrowth<span class="operator">=</span><span class="number">2</span><span class="operator">%</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建教师信息表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--创建教师信息表</span><br><span class="line">create table 教师信息</span><br><span class="line">(</span><br><span class="line">教师编号 varchar(15) not null,</span><br><span class="line">教师姓名 varchar(15) not null,</span><br><span class="line">性别 varchar(5) not null,</span><br><span class="line">所属院系 varchar(10) not null,</span><br><span class="line">职称 varchar(15) not null,</span><br><span class="line">身份证号 varchar(18) not null</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建学生信息表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--创建学生信息表</span><br><span class="line">create table 学生信息</span><br><span class="line">(</span><br><span class="line">学号 varchar(9) not null,</span><br><span class="line">院系号 varchar(5) not null,</span><br><span class="line">身份证号 varchar(18) not null</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建教室信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--创建教室信息表</span><br><span class="line">create table 教室信息</span><br><span class="line">(</span><br><span class="line">教室编号 varchar(5) not null,</span><br><span class="line">教学楼编号 varchar(2) not null,</span><br><span class="line">楼层号 varchar(2)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建教学楼信息表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--创建教学楼信息表</span><br><span class="line">create table 教学楼信息</span><br><span class="line">(</span><br><span class="line">教学楼名称 varchar(10) not null,</span><br><span class="line">教学楼编号 varchar(5) not null</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>有个信息不匹配，进行修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 教室信息</span><br><span class="line">alter column 教学楼编号 varchar(5) not null</span><br></pre></td></tr></table></figure>
<p>创建教室使用信息表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--创建教室使用信息表</span><br><span class="line">create table 教室使用信息</span><br><span class="line">(</span><br><span class="line">教学楼编号 varchar(5) not null,</span><br><span class="line">教室编号 varchar(5) not null,</span><br><span class="line">时间 varchar(10) not null,</span><br><span class="line">状态 varchar(10) not null</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建课程信息表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--创建课程信息表</span><br><span class="line">create table 课程信息</span><br><span class="line">(</span><br><span class="line">课程名称 varchar(15) not null,</span><br><span class="line">课程编号 varchar(10) not null,</span><br><span class="line">教师编号 varchar(15) not null,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建课程时间表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--创建课程时间表</span><br><span class="line">create table 课程时间</span><br><span class="line">(</span><br><span class="line">课程编号 varchar(10) not null,</span><br><span class="line">教师编号 varchar(15) not null,</span><br><span class="line">教师名称 varchar(10) not null,</span><br><span class="line">上课时间 varchar(10) not null</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">alter table 学生信息 add 密码 varchar(15)</span><br><span class="line"></span><br><span class="line">alter table 课程时间 add 上课教室 varchar(5)</span><br><span class="line"></span><br><span class="line">alter table 教室使用信息 add 开设课程 varchar(15) default &#x27;无&#x27;</span><br><span class="line"></span><br><span class="line">alter table 学生信息 add 姓名 varchar(15)</span><br><span class="line"></span><br><span class="line">alter table 教师信息</span><br><span class="line">alter column 所属院系 varchar(15) </span><br><span class="line"></span><br><span class="line">alter table 学生信息</span><br><span class="line">alter column 院系号 varchar(15) </span><br><span class="line"></span><br><span class="line">alter table 教室使用信息 add 课程编号 varchar(10) </span><br></pre></td></tr></table></figure>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--将教师信息表中教师编号设置为主键约束，身份证号设为唯一约束</span><br><span class="line">alter table 教师信息 </span><br><span class="line">add constraint PK_教师编号 primary key (教师编号)</span><br><span class="line">alter table 教师信息</span><br><span class="line">add constraint UQ_身份证号 unique(身份证号)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--将学生信息表中学号设置为主键约束，身份证号设为唯一约束</span><br><span class="line">alter table 学生信息 </span><br><span class="line">add constraint PK_学号 primary key (学号)</span><br><span class="line">alter table 学生信息</span><br><span class="line">add constraint UQ_身份证号学生 unique(身份证号)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--将教室信息中教室编号设置为主键</span><br><span class="line">alter table 教室信息</span><br><span class="line">add constraint PK_教室编号 primary key(教室编号)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--将教学楼信息中教学楼编号设置为主键</span><br><span class="line">alter table 教学楼信息</span><br><span class="line">add constraint PK_教学楼编号 primary key(教学楼编号)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--将教学楼信息中的教学楼编号与教室信息中的教学楼编号添加外键</span><br><span class="line">alter table 教室信息</span><br><span class="line">add constraint FK_教学楼编号 foreign key(教学楼编号)references 教学楼信息(教学楼编号)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--将教室使用信息表中教学楼编号与教学楼信息表中的教学楼编号添加外键</span><br><span class="line">alter table 教室使用信息</span><br><span class="line">add constraint FK_教学楼编号教室使用信息 foreign key (教学楼编号)references 教学楼信息(教学楼编号)</span><br><span class="line"></span><br><span class="line">--将教室使用信息表中教室编号与教室信息表中的教室编号添加外键</span><br><span class="line">alter table 教室使用信息</span><br><span class="line">add constraint FK_教室编号教室使用信息 foreign key (教室编号)references 教室信息(教室编号)</span><br><span class="line"></span><br><span class="line">--将教室使用信息表中教师状态做约束</span><br><span class="line">alter table 教室使用信息</span><br><span class="line">add constraint CK_状态 check(状态=&#x27;有课&#x27; or 状态=&#x27;讲座&#x27; or 状态=&#x27;活动&#x27; or 状态=&#x27;空闲&#x27; or 状态=&#x27;其他&#x27;)//删除掉该约束</span><br><span class="line"></span><br><span class="line">--将教室使用信息表中教室状态添加默认约束空闲</span><br><span class="line">alter table 教室使用信息</span><br><span class="line">add constraint DF_状态 default &#x27;空闲&#x27; for 状态</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--对课程信息表中课程编号添加主键约束</span><br><span class="line">alter table 课程信息</span><br><span class="line">　add constraint PK_课程编号 primary key (课程编号)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--对课程信息表中教师编号添加外键约束</span><br><span class="line">alter table 课程信息</span><br><span class="line">add constraint FK_教师编号课程信息 foreign key(教师编号)references 教师信息(教师编号)</span><br><span class="line"></span><br><span class="line">--对课程时间表中教师编号添加外键约束</span><br><span class="line">alter table 课程时间</span><br><span class="line">add constraint FK_教师编号课程时间 foreign key(教师编号)references 教师信息(教师编号)</span><br><span class="line"></span><br><span class="line">--对课程时间表中课程编号添加外键约束</span><br><span class="line">alter table 课程时间</span><br><span class="line">add constraint FK_课程编号课程时间 foreign key(课程编号)references 课程信息(课程编号)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--对教师信息中的性别添加约束</span><br><span class="line">　　alter table 教师信息</span><br><span class="line">　　add constraint CK_性别教师 check (性别=&#x27;男&#x27; or 性别=&#x27;女&#x27;)</span><br><span class="line"></span><br><span class="line">--对教室使用信息的时间进行约束</span><br><span class="line">  alter table 教室使用信息</span><br><span class="line">  add constraint CK_时间 check (时间=&#x27;周一一二&#x27; or 时间=&#x27;周一三四&#x27; or 时间=&#x27;周一五六&#x27; or 时间=&#x27;周一七八&#x27; or </span><br><span class="line">  时间=&#x27;周二一二&#x27; or 时间=&#x27;周二三四&#x27; or 时间=&#x27;周二五六&#x27; or 时间=&#x27;周二七八&#x27; or </span><br><span class="line">  时间=&#x27;周三一二&#x27; or 时间=&#x27;周三三四&#x27; or 时间=&#x27;周三五六&#x27; or 时间=&#x27;周三七八&#x27; or </span><br><span class="line">  时间=&#x27;周四一二&#x27; or 时间=&#x27;周四三四&#x27; or 时间=&#x27;周四五六&#x27; or 时间=&#x27;周四七八&#x27; or </span><br><span class="line">  时间=&#x27;周五一二&#x27; or 时间=&#x27;周五三四&#x27; or 时间=&#x27;周五五六&#x27; or 时间=&#x27;周五七八&#x27; or </span><br><span class="line">  时间=&#x27;周六一二&#x27; or 时间=&#x27;周六三四&#x27; or 时间=&#x27;周六五六&#x27; or 时间=&#x27;周六七八&#x27; or </span><br><span class="line">  时间=&#x27;周日一二&#x27; or 时间=&#x27;周日三四&#x27; or 时间=&#x27;周日五六&#x27; or 时间=&#x27;周日七八&#x27; </span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alter table 课程时间</span><br><span class="line">add constraint FK_教室 foreign key(上课教室) references 教室信息(教室编号)</span><br><span class="line"></span><br><span class="line">alter table 教室使用信息</span><br><span class="line">alter column 状态 varchar(15) not null</span><br><span class="line"></span><br><span class="line">alter table 学生信息</span><br><span class="line">add constraint UQ_ID unique (身份证号)</span><br></pre></td></tr></table></figure>
<h3 id="插入的信息"><a href="#插入的信息" class="headerlink" title="插入的信息"></a>插入的信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">insert into 教师信息</span><br><span class="line"> values(&#x27;001&#x27;,&#x27;张三&#x27;,&#x27;男&#x27;,&#x27;计算机&#x27;,&#x27;教授&#x27;,&#x27;123456789&#x27;)</span><br><span class="line"> insert into 教师信息</span><br><span class="line"> values(&#x27;002&#x27;,&#x27;李四&#x27;,&#x27;女&#x27;,&#x27;地理与海洋&#x27;,&#x27;教授&#x27;,&#x27;123123123&#x27;)</span><br><span class="line"> insert into 教师信息</span><br><span class="line">values(&#x27;003&#x27;,&#x27;王五&#x27;,&#x27;男&#x27;,&#x27;计算机&#x27;,&#x27;教授&#x27;,&#x27;456456456&#x27;)</span><br><span class="line"></span><br><span class="line"> select * from 教师信息</span><br><span class="line"></span><br><span class="line">insert into 教学楼信息</span><br><span class="line">values(&#x27;仙一&#x27;,&#x27;001&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教学楼信息</span><br><span class="line">values(&#x27;仙二&#x27;,&#x27;002&#x27;)</span><br><span class="line">select * from 教学楼信息</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;1101&#x27;,&#x27;001&#x27;,&#x27;1&#x27;)</span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;1102&#x27;,&#x27;001&#x27;,&#x27;1&#x27;)</span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;1103&#x27;,&#x27;001&#x27;,&#x27;1&#x27;)</span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;1104&#x27;,&#x27;001&#x27;,&#x27;1&#x27;)</span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;1201&#x27;,&#x27;001&#x27;,&#x27;2&#x27;)</span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;1202&#x27;,&#x27;001&#x27;,&#x27;2&#x27;)</span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;1203&#x27;,&#x27;001&#x27;,&#x27;2&#x27;)</span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;1204&#x27;,&#x27;001&#x27;,&#x27;2&#x27;)</span><br><span class="line"></span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;2101&#x27;,&#x27;002&#x27;,&#x27;1&#x27;)</span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;2102&#x27;,&#x27;002&#x27;,&#x27;1&#x27;)</span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;2103&#x27;,&#x27;002&#x27;,&#x27;1&#x27;)</span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;2104&#x27;,&#x27;002&#x27;,&#x27;1&#x27;)</span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;2201&#x27;,&#x27;002&#x27;,&#x27;2&#x27;)</span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;2202&#x27;,&#x27;002&#x27;,&#x27;2&#x27;)</span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;2203&#x27;,&#x27;002&#x27;,&#x27;2&#x27;)</span><br><span class="line">insert into 教室信息</span><br><span class="line">values(&#x27;2204&#x27;,&#x27;002&#x27;,&#x27;2&#x27;)</span><br><span class="line">select * from 教室信息</span><br></pre></td></tr></table></figure>
<p>插入课程信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exec information_entry &#x27;数据库&#x27;,&#x27;001&#x27;,&#x27;周一三四&#x27;,&#x27;张三&#x27;,&#x27;001&#x27;,&#x27;001&#x27;,&#x27;1102&#x27;</span><br><span class="line">exec information_entry &#x27;数据库&#x27;,&#x27;001&#x27;,&#x27;周二三四&#x27;,&#x27;张三&#x27;,&#x27;001&#x27;,&#x27;001&#x27;,&#x27;1102&#x27;</span><br><span class="line">exec information_entry &#x27;地理综合认知&#x27;,&#x27;002&#x27;,&#x27;周三三四&#x27;,&#x27;李四&#x27;,&#x27;002&#x27;,&#x27;001&#x27;,&#x27;1202&#x27;</span><br><span class="line">exec information_entry &#x27;地理综合认知&#x27;,&#x27;002&#x27;,&#x27;周四三四&#x27;,&#x27;李四&#x27;,&#x27;002&#x27;,&#x27;001&#x27;,&#x27;1202&#x27;</span><br><span class="line">exec information_entry &#x27;机器学习&#x27;,&#x27;003&#x27;,&#x27;周一五六&#x27;,&#x27;张三&#x27;,&#x27;001&#x27;,&#x27;002&#x27;,&#x27;2102&#x27;</span><br><span class="line">exec information_entry &#x27;机器学习&#x27;,&#x27;003&#x27;,&#x27;周二五六&#x27;,&#x27;张三&#x27;,&#x27;001&#x27;,&#x27;002&#x27;,&#x27;2102&#x27;</span><br><span class="line">exec information_entry &#x27;机器学习&#x27;,&#x27;004&#x27;,&#x27;周四七八&#x27;,&#x27;王五&#x27;,&#x27;003&#x27;,&#x27;002&#x27;,&#x27;2202&#x27;</span><br><span class="line">exec information_entry &#x27;机器学习&#x27;,&#x27;004&#x27;,&#x27;周五七八&#x27;,&#x27;王五&#x27;,&#x27;003&#x27;,&#x27;002&#x27;,&#x27;2202&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>插入课程信息存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">--插入课程信息</span><br><span class="line"></span><br><span class="line">go</span><br><span class="line">create procedure information_entry</span><br><span class="line"> @coursename varchar(15),--输入参数，课程名称</span><br><span class="line"> @coursenumber varchar(10),--输入参数，课程编号</span><br><span class="line"> @coursetime varchar(10),--输入参数，课程时间</span><br><span class="line"> @teachername varchar(10),--输入参数，教师名称</span><br><span class="line"> @teachernumber varchar(15),--输入参数，教师编号</span><br><span class="line"> @buildingnumber varchar(5),--输入参数，教学楼编号</span><br><span class="line"> @roomnumber varchar(5)--输入参数教室编号</span><br><span class="line">AS</span><br><span class="line"> insert into 课程信息</span><br><span class="line"> values(@coursename,@coursenumber,@teachernumber)</span><br><span class="line"> insert into 课程时间</span><br><span class="line"> values(@coursenumber,@teachernumber,@teachername,@coursetime)</span><br><span class="line"> insert into 教室使用信息</span><br><span class="line"> values(@buildingnumber,@roomnumber,@coursetime,&#x27;有课&#x27;)</span><br><span class="line">go</span><br></pre></td></tr></table></figure>
<p>修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create procedure information_entry</span><br><span class="line"> @coursename varchar(15),--输入参数，课程名称</span><br><span class="line"> @coursenumber varchar(10),--输入参数，课程编号</span><br><span class="line"> @coursetime varchar(10),--输入参数，课程时间</span><br><span class="line"> @teachername varchar(10),--输入参数，教师名称</span><br><span class="line"> @teachernumber varchar(15),--输入参数，教师编号</span><br><span class="line"> @buildingnumber varchar(5),--输入参数，教学楼编号</span><br><span class="line"> @roomnumber varchar(5)--输入参数教室编号</span><br><span class="line">AS</span><br><span class="line"> insert into 课程信息</span><br><span class="line"> values(@coursename,@coursenumber,@teachernumber)</span><br><span class="line"> insert into 课程时间</span><br><span class="line"> values(@coursenumber,@teachernumber,@teachername,@coursetime,@roomnumber)</span><br><span class="line"> insert into 教室使用信息</span><br><span class="line"> values(@buildingnumber,@roomnumber,@coursetime,&#x27;有课&#x27;,@coursename,@coursenumber)</span><br><span class="line">go</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查询指定教室使用情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">--查询指定教室使用情况</span><br><span class="line">create procedure classroom_query</span><br><span class="line"> @room varchar(5),</span><br><span class="line"> @time varchar(10),</span><br><span class="line"> @state varchar(10)=&#x27;空闲&#x27; output</span><br><span class="line"> AS</span><br><span class="line"> declare @state1 varchar(10)</span><br><span class="line"> select @state=状态</span><br><span class="line"> from 教室使用信息</span><br><span class="line"> where 教室编号=@room and 时间=@time</span><br><span class="line"> if @state IS NULL</span><br><span class="line">   set  @state=&#x27;空闲&#x27;</span><br><span class="line"> go</span><br><span class="line"></span><br><span class="line">修改</span><br><span class="line">create procedure classroom_query</span><br><span class="line"> @room varchar(5),</span><br><span class="line"> @time varchar(10),</span><br><span class="line"> @state varchar(10)=&#x27;空闲&#x27; output</span><br><span class="line"> AS</span><br><span class="line"></span><br><span class="line"> select @state=状态</span><br><span class="line"> from 教室使用信息</span><br><span class="line"> where 教室编号=@room and 时间=@time</span><br><span class="line"> if @state IS NULL</span><br><span class="line">   set  @state=&#x27;空闲&#x27;</span><br><span class="line">   else if @state=&#x27;有课&#x27;</span><br><span class="line">   begin</span><br><span class="line">    select @state=开设课程</span><br><span class="line"> from 教室使用信息</span><br><span class="line"> where 教室编号=@room and 时间=@time</span><br><span class="line"></span><br><span class="line">   end</span><br><span class="line"> go</span><br></pre></td></tr></table></figure>
<p>查询指定课程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create procedure course_query</span><br><span class="line"> @name varchar(10),</span><br><span class="line"> @state varchar(10) output</span><br><span class="line"> AS</span><br><span class="line"></span><br><span class="line"> select 课程信息.课程名称,课程信息.课程编号,课程时间.教师名称,课程时间.上课时间</span><br><span class="line"> from 课程时间 inner join 课程信息 on 课程信息.课程编号=课程时间.课程编号</span><br><span class="line"> where 课程信息.课程名称=@name</span><br><span class="line"> go</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>租借教室</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line"> create procedure borrow</span><br><span class="line"> @building varchar(5),</span><br><span class="line"> @room varchar(5),</span><br><span class="line"> @time varchar(10),</span><br><span class="line"> @reason varchar(10)</span><br><span class="line">AS</span><br><span class="line">declare @state varchar(10)</span><br><span class="line"> select @state=状态</span><br><span class="line"> from 教室使用信息</span><br><span class="line"> where 教室编号=@room and 时间=@time</span><br><span class="line"> if @state IS NULL</span><br><span class="line"> begin</span><br><span class="line">   set  @state=&#x27;空闲&#x27;</span><br><span class="line">   print &#x27;此时教室空闲，可以借用&#x27;</span><br><span class="line">   insert into 教室使用信息</span><br><span class="line">   values(@building,@room,@time,@reason)</span><br><span class="line">  end</span><br><span class="line">else</span><br><span class="line">  print &#x27;此教室被占用，正在&#x27;+@state</span><br><span class="line">  go</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">declare @state varchar(10)</span><br><span class="line">go</span><br><span class="line">create procedure borrow</span><br><span class="line"> @building varchar(5),</span><br><span class="line"> @room varchar(5),</span><br><span class="line"> @time varchar(10),</span><br><span class="line"> @reason varchar(10),</span><br><span class="line"> @state varchar(10) output</span><br><span class="line">AS</span><br><span class="line">declare @state1 varchar(10)</span><br><span class="line"> select @state1=状态</span><br><span class="line"> from 教室使用信息</span><br><span class="line"> where 教室编号=@room and 时间=@time</span><br><span class="line"> if @state1 IS NULL</span><br><span class="line"> begin</span><br><span class="line">   set  @state1=&#x27;空闲&#x27;</span><br><span class="line">   </span><br><span class="line">   print &#x27;此时教室空闲，可以借用&#x27;</span><br><span class="line">   insert into 教室使用信息</span><br><span class="line">   values(@building,@room,@time,@reason,&#x27;其他&#x27;,&#x27;其他&#x27;)</span><br><span class="line">  end</span><br><span class="line">else</span><br><span class="line">  print &#x27;此教室被占用，正在&#x27;+@state1</span><br><span class="line">  set @state=@state1</span><br><span class="line">  print @state</span><br><span class="line">  go</span><br><span class="line"></span><br><span class="line">  select *from 教室使用信息</span><br><span class="line">  declare @state varchar(10)</span><br><span class="line">  exec borrow &#x27;001&#x27;,&#x27;1102&#x27;,&#x27;周一三四&#x27;,&#x27;其他&#x27;,@state output</span><br><span class="line">  print @state</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>判断密码是否正确</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create procedure password_query</span><br><span class="line"> @user varchar(9),</span><br><span class="line"> @password varchar(15),</span><br><span class="line"> @state varchar(10)=&#x27;false&#x27; output</span><br><span class="line">AS</span><br><span class="line">declare @password1 varchar(15)</span><br><span class="line"> select @password1=密码  from 学生信息</span><br><span class="line"> where 学号=@user</span><br><span class="line"> if @password1 IS NOT NULL and @password1=@password</span><br><span class="line"> set @state=&#x27;true&#x27;</span><br><span class="line"> else</span><br><span class="line"> set @state=&#x27;false&#x27;</span><br><span class="line">go</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create procedure delete_course</span><br><span class="line"> @number varchar(10)</span><br><span class="line"> AS</span><br><span class="line">delete from 课程信息 where 课程编号=@number</span><br><span class="line">delete from 教室使用信息 where 课程编号=@number</span><br><span class="line">delete from 课程时间 where 课程编号=@number</span><br></pre></td></tr></table></figure>
<p>编写存储插入大量数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">--创建循环插入1000条记录的存储过程</span><br><span class="line">CREATE  PROCEDURE SP_CREATE_DATA1 </span><br><span class="line">AS</span><br><span class="line">declare @cnt INT=0;</span><br><span class="line">while @cnt&lt;100</span><br><span class="line">begin</span><br><span class="line">declare @a varchar(8)</span><br><span class="line">set @a=(SELECT   LEFT(LOWER(NEWID()),8))</span><br><span class="line">declare @b varchar(8)</span><br><span class="line">set @b=(SELECT   LEFT(LOWER(NEWID()),9))</span><br><span class="line">declare @c INT</span><br><span class="line">set @c=(SELECT 1 + RAND() * 2)</span><br><span class="line">    INSERT INTO 学生信息</span><br><span class="line">    VALUES</span><br><span class="line">    (</span><br><span class="line">     @a</span><br><span class="line">    </span><br><span class="line">    ,CASE @c  --随机选取3个枚举值</span><br><span class="line">          when 1 then &#x27;001&#x27;</span><br><span class="line">          when 2 then &#x27;002&#x27;</span><br><span class="line">          when 3 then &#x27;003&#x27;         </span><br><span class="line">     END</span><br><span class="line">	 ,@b</span><br><span class="line">	  ,@a</span><br><span class="line">	   ,@b</span><br><span class="line">   </span><br><span class="line">    );</span><br><span class="line">	set @cnt=@cnt+1;</span><br><span class="line">end;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">GO</span><br><span class="line">exec SP_CREATE_DATA1 </span><br><span class="line"></span><br><span class="line">CREATE  PROCEDURE SP_CREATE_DATA3 </span><br><span class="line">AS</span><br><span class="line">declare @cnt INT=0;</span><br><span class="line">while @cnt&lt;100</span><br><span class="line">begin</span><br><span class="line">declare @a varchar(8)</span><br><span class="line">set @a=(SELECT   LEFT(LOWER(NEWID()),8))</span><br><span class="line">declare @b varchar(8)</span><br><span class="line">set @b=(SELECT   LEFT(LOWER(NEWID()),9))</span><br><span class="line">declare @c INT</span><br><span class="line">set @c=(SELECT 1 + RAND() * 2)</span><br><span class="line">declare @d varchar(8)</span><br><span class="line">set @d=replace(str(@cnt,8),&#x27; &#x27;,&#x27;0&#x27;)</span><br><span class="line">    INSERT INTO 学生信息</span><br><span class="line">    VALUES</span><br><span class="line">    (</span><br><span class="line">     @d</span><br><span class="line">    </span><br><span class="line">    ,CASE @c  --随机选取3个枚举值</span><br><span class="line">          when 1 then &#x27;001&#x27;</span><br><span class="line">          when 2 then &#x27;002&#x27;</span><br><span class="line">          when 3 then &#x27;003&#x27;         </span><br><span class="line">     END</span><br><span class="line">	 ,@b</span><br><span class="line">	  ,@a</span><br><span class="line">	   ,@b</span><br><span class="line">   </span><br><span class="line">    );</span><br><span class="line">	set @cnt=@cnt+1;</span><br><span class="line">end;</span><br><span class="line">exec SP_CREATE_DATA3 </span><br><span class="line"></span><br><span class="line">declare @cnt INT=1</span><br><span class="line">declare @d varchar(8)</span><br><span class="line">set @d=replace(str(@cnt,8),&#x27; &#x27;,&#x27;0&#x27;)</span><br><span class="line">print @d</span><br><span class="line">select * from 学生信息</span><br></pre></td></tr></table></figure>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>创建视图，查询张三老师课程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--创建视图，查询计算机学院张三老师所有课程名称</span><br><span class="line">go</span><br><span class="line">create VIEW view_张三</span><br><span class="line">as </span><br><span class="line">select 课程名称 </span><br><span class="line">from 课程信息</span><br><span class="line">where 教师编号=&#x27;001&#x27;</span><br><span class="line">go</span><br></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exec information_entry &#x27;机器学习&#x27;,&#x27;004&#x27;,&#x27;周六七八&#x27;,&#x27;王五&#x27;,&#x27;003&#x27;,&#x27;002&#x27;,&#x27;2202&#x27;</span><br><span class="line">select *from 教室使用信息</span><br><span class="line">declare @state varchar(15)</span><br><span class="line">exec classroom_query &#x27;2202&#x27;,&#x27;周六七八&#x27;,@state output</span><br><span class="line">print @state</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare @state varchar(10)</span><br><span class="line">exec password_query &#x27;191830076&#x27;,&#x27;0323&#x27;,@state output</span><br><span class="line">print @state</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-01 15:39:33" itemprop="dateCreated datePublished" datetime="2021-12-01T15:39:33+08:00">2021-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-06 00:17:10" itemprop="dateModified" datetime="2021-12-06T00:17:10+08:00">2021-12-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h2><h3 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h3><h4 id="具体构成描述"><a href="#具体构成描述" class="headerlink" title="具体构成描述"></a>具体构成描述</h4><p>端系统通过通信链路和分组交换机连接到一起。</p>
<p>两种最著名的分组交换机为路由器和链路层交换机。链路层交换机通常用于接入网中，路由器通常用于网络核心中。</p>
<p>端系统通过 <strong>因特网服务提供商</strong>(Internet Service Provider,ISP)接入因特网。</p>
<p><strong>TCP</strong>(Transmission Control Protocol,传输控制协议)和 <strong>IP</strong>(Internet Protocol,网际协议)是因特网中最为重要的两个协议。</p>
<p>因特网的主要协议称为 <strong>TCP/IP</strong>协议。</p>
<p>因特网工程任务组。Internet Engineering Task Force,IETF</p>
<h4 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h4><p>有些应用程序涉及多个相互交换数据的端系统，称为 <strong>分布式应用程序</strong></p>
<p>与因特网相连的端系统提供了一套 <strong>套接字接口</strong>，该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。</p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p><strong>协议</strong>定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接受一条报文或其他事件所采取的动作。</p>
<h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><p>端系统也被称为 <em>主机</em>，因为它们容纳应用程序，主机有时又被划分为客户和服务器。</p>
<h4 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h4><h5 id="家庭介入"><a href="#家庭介入" class="headerlink" title="家庭介入"></a>家庭介入</h5><p>宽带住宅接入有两种最流行的类型: <strong>数字用户线</strong>(Digital Subscriber Line,DSL)和电缆。</p>
<h5 id="企业-和家庭-接入：以太网和WIFI"><a href="#企业-和家庭-接入：以太网和WIFI" class="headerlink" title="企业(和家庭)接入：以太网和WIFI"></a>企业(和家庭)接入：以太网和WIFI</h5><p>局域网LAN</p>
<h5 id="广域无线接入：3G和LTE"><a href="#广域无线接入：3G和LTE" class="headerlink" title="广域无线接入：3G和LTE"></a>广域无线接入：3G和LTE</h5><h4 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h4><p>物理媒体分成两种类型：导引型媒体和非导引型媒体</p>
<h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><h5 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h5><p>多数分组交换机在链路的输入端使用 <strong>存储转发传输</strong>机制。存储转发传输是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p>
<h5 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h5><p>每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个输出缓存，它用于粗出路由器准备发往那条链路的分组。</p>
<h5 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h5><p>每台路由器具有一个转发表，用于将目的地址映射成为输出链路。</p>
<h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>在电路交换网络中，在端系统通信会话期间，预留了端系统间沿路径通信所需要的资源。</p>
<h5 id="电路交换网络中的复用"><a href="#电路交换网络中的复用" class="headerlink" title="电路交换网络中的复用"></a>电路交换网络中的复用</h5><p>链路中的电路是通过 <strong>频分复用</strong>(FDM)或 <strong>时分复用</strong>(TDM)来实现的。</p>
<h5 id="分组交换与电路交换的对比"><a href="#分组交换与电路交换的对比" class="headerlink" title="分组交换与电路交换的对比"></a>分组交换与电路交换的对比</h5><p>趋势朝着分组交换方向发展。</p>
<h4 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h4><p>今天的因特网是一个网络的网络，由十多个第一层ISP和数十万个较低层ISP组成。</p>
<h3 id="分组交换网中的时延、丢包和吞吐量"><a href="#分组交换网中的时延、丢包和吞吐量" class="headerlink" title="分组交换网中的时延、丢包和吞吐量"></a>分组交换网中的时延、丢包和吞吐量</h3><h4 id="分组交换网中的时延概述"><a href="#分组交换网中的时延概述" class="headerlink" title="分组交换网中的时延概述"></a>分组交换网中的时延概述</h4><p>这些时延最为重要的是 <strong>节点处理时延、排队时延、传输时延和传播时延</strong>，这些时延累加起来是节点总时延。</p>
<h5 id="时延的类型"><a href="#时延的类型" class="headerlink" title="时延的类型"></a>时延的类型</h5><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1058C181F75107A7FBF59ECA489D18BA.jpg" alt="img" style="zoom: 33%;"></p>
<p><strong>处理时延</strong></p>
<p>$d_{proc}$</p>
<p>检查分组首部和决定将该分组导向何处所需要的时间是 <strong>处理时延</strong>的一部分。处理时延也能够包括其他因素，如检查比特级别的差错所需要的时间。</p>
<h5 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h5><p>$d_{queue}$</p>
<p>在队列中，当分组在链路上等待传输时，他经受排队时延。</p>
<h5 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h5><p>$d_{trans}$</p>
<p>用L比特表示该分组的长度，用R bps表示从路由器A到路由器B的链路传输速率。传输时延时L/R。这是将所有分组的比特推向链路所需要的时间。</p>
<h5 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h5><p>$d_{prop}$</p>
<p>从该链路的起点到路由器B传播所需要的时间是传播时延。</p>
<h4 id="排队时延和丢包"><a href="#排队时延和丢包" class="headerlink" title="排队时延和丢包"></a>排队时延和丢包</h4><p>令a表示分组到达队列的平均速率(a的单位是分组/秒)。R是传输速率，即从队列中推出比特的速率。假定所有分组都是由L比特组成。则比特到达队列的平均速率是La bps。比率La/R被称为流量强度。</p>
<p><strong>设计系统时流量强度不能大于1</strong></p>
<h5 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h5><p>因为排队容量是有限的，随着流量强度接近1.排队时延并不是无穷大，相反，到达的分组将发现一个满的队列。由于没有地方存储，路由器将丢弃该分组。</p>
<h4 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h4><p>在任何时间瞬间的 <strong>瞬时吞吐量</strong>是主机B接受到该文件的速率。</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/A2575C7C209C53FDFD1B0EFCD5DBCE8D.jpg" alt="img" style="zoom: 33%;"></p>
<h3 id="协议层次及其服务模型"><a href="#协议层次及其服务模型" class="headerlink" title="协议层次及其服务模型"></a>协议层次及其服务模型</h3><h4 id="分层的体系结构"><a href="#分层的体系结构" class="headerlink" title="分层的体系结构"></a>分层的体系结构</h4><h5 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h5><p>各层的所有协议被称为 <strong>协议栈</strong>。因特网的协议栈由五个层次组成：物理层、链路层、网络层、传输层和应用层。</p>
<h6 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h6><p>HTTP：提供了Web文档的请求和传送。</p>
<p>SMTP：提供了电子邮件报文的传送。</p>
<p>FTP：提供两个端系统间的文件传送。</p>
<p><strong>报文</strong>：位于应用层的信息分组称为报文。</p>
<h6 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h6><p>TCP/UDP</p>
<p><strong>报文段</strong>：我们把运输层的分组称为报文段。</p>
<h6 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h6><p>因特网的网络层负责将称为 <strong>数据报</strong>的网络层分组从一台主机移动到另一台主机。</p>
<h6 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h6><p>为了将分组从一个节点移动到路径上的下一个节点，网络层必须依靠该链路层的服务。特别是在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。</p>
<p><strong>帧</strong>：链路层分组</p>
<h6 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h6><p>物理层的任务是将该帧中的一个个比特从一个节点传递到下一个节点。</p>
<h5 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h5><p>开放系统互联模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>一个应用层报文被传送给传输层，在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段。以此类推。我们可以看到，在每一层，一个分组具有两种类型的字段：首部字段和有效载荷字段。有效载荷字段通常来自上一层分组。</p>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p>计算机网络就是自治互联的计算机集合。</p>
<p>协议的三要素:语法、语义、同步/时序。</p>
<p>分组交换网络传输分组的基本工作方式是(存储-转发)。</p>
<p>计算机网络从结构上可以划分为网络核心，网络边缘和接入网。</p>
<p>OSI中应用层，表示层，会话层，传输层为端到端层。实现路由功能为网络层。</p>
<h2 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h2><h3 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h3><h4 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h4><p><strong>应用程序体系结构</strong>由应用程序研发者设计，规定了如何在各种端系统上组织应用程序。</p>
<p><strong>客户-服务器体系结构</strong>中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。</p>
<p>在这个体系中，客户之间不通信；并且服务器具有固定的周知的地址，称为IP地址。</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205142034282.png" alt="image-20211205142034282"></p>
<p><strong>P2P体系结构</strong>中，对于位于数据中心的专用服务器有最小的依赖。相反，应用程序在间断连接的主机对之间直接通信，这些主机被称为</p>
<p><em>对等方</em>。P2P具有自扩展性。</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205142049905.png" alt="image-20211205142049905"></p>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><h5 id="客户和服务器进程"><a href="#客户和服务器进程" class="headerlink" title="客户和服务器进程"></a>客户和服务器进程</h5><p>在一个P2P文件共享系统中，文件从一个对等方中的进程传输到另一个对等方的进程。通常将这两个进程之一标识为客户，另一个标识为服务器。在P2P共享文件中，一个进程既是客户又是服务器。</p>
<h5 id="进程与计算机网络之间的接口"><a href="#进程与计算机网络之间的接口" class="headerlink" title="进程与计算机网络之间的接口"></a>进程与计算机网络之间的接口</h5><p>进程通过一个称为套接字的软件接口向网络发送报文和从网络接收报文。套接字也称为应用程序和网络之间的应用程序编程接口。</p>
<p>应用程序开发者对于运输层的控制权限仅限于：选择运输层协议；也许能设定几个运输层参数。但是对于套接字的运输层段几乎没有控制权。</p>
<h5 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h5><p>为标识该接收进程，需定义：主机的地址；在目的主机中指定接收进程的标识符。</p>
<p>在因特网中，主机由I地址标识。</p>
<p>发送进程还必须指定运行在接收主机上的接收进程，目的地端口号用于这个目的，</p>
<p>Web服务器端口号：80</p>
<p>邮件服务器进程：25</p>
<p>FTP：21</p>
<h4 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h4><p>从四个方面分类：</p>
<h5 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h5><p>运输层协议能够潜在的向应用程序提供的一个重要服务是进程到进程的可靠数据传输。</p>
<h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5><p>具有吞吐量要求的应用程序被称为带宽敏感的应用。</p>
<p>弹性应用能够根据当时可用的带宽或多或少地利用可供使用的吞吐量。</p>
<h5 id="定时"><a href="#定时" class="headerlink" title="定时"></a>定时</h5><p>一个保证的例子：发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms。</p>
<h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>运输协议能够为应用程序提供一种或多种安全性服务。</p>
<h4 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h4><h5 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h5><p>包括面向连接服务和可靠数据传输服务。</p>
<p><strong>面向连接的服务</strong>：在应用处数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这就是握手，在握手阶段后，一个 <strong>TCP连接</strong>就在两个进程的套接字之间建立。</p>
<p><strong>可靠的数据传送服务</strong>：通信进程能够依靠TCP，无差错，按适当顺序交付所有发送的数据。</p>
<p>TCP协议还具有拥塞控制机制。</p>
<h5 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h5><p>仅提供最小服务。UDP是无连接的。提供不可靠数据传送服务。</p>
<p>没有拥塞控制机制。</p>
<h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><p>定义了运行在不同端系统上的应用程序进程如何相互传递报文。</p>
<p>特别是应用层协议定义了：</p>
<p>交换的报文类型；</p>
<p>各种报文类型的语法；</p>
<p>字段的语义；</p>
<p>确定一个进程何时以及如何发送报文，对报文进行响应的规则。</p>
<p>Web的应用层协议是HTTP。</p>
<p>电子邮件的主要应用层协议是SMTP。</p>
<h4 id="涉及的网络应用"><a href="#涉及的网络应用" class="headerlink" title="涉及的网络应用"></a>涉及的网络应用</h4><p>主要讨论：Web，文件传输，电子邮件，目录服务，流式视频和P2P。</p>
<h3 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h3><h4 id="HTTP概括"><a href="#HTTP概括" class="headerlink" title="HTTP概括"></a>HTTP概括</h4><p>应用层协议为：超文本传输协议(HyperText Transfer Protocol,HTTP).</p>
<p>HTTP由一个客户程序和一个服务器程序实现。</p>
<p><strong>WEB浏览器</strong>实现了HTTP的客户端。</p>
<p><strong>Web服务器</strong>实现了HTTP的服务器端，用于存储Web对象，每个对象由URL寻址。</p>
<p>HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的形式。</p>
<p>HTTP服务器并不保存关于客户的任何信息，所以我们说HTTP是一个 <strong>无状态协议</strong>。</p>
<h4 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h4><p>非持续连接：每一个请求/响应是经一个单独的TCP连接发送。</p>
<p>持续连接：所有请求及其响应经相同的TCP连接发送。</p>
<p><strong>往返时间</strong>(RTT):一个短分组从客户到服务器然后再返回客户所花费的时间。RTT包括分组传播时延，分组在中间路由器和交换机上的排队时延以及分组处理时延。</p>
<h4 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h4><h5 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h5><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/BB016A182C705757BBB0C742D87CCC86.jpg" alt="img" style="zoom: 33%;"></p>
<p>第一行叫请求行。有三个字段，方法字段，URL字段，HTTP版本字段。</p>
<p>之后的行叫做首部行。</p>
<p>第二行指明了对象所在的主机。</p>
<p>第三行该浏览器告诉服务器不要麻烦的使用持续连接，它要求服务器发送完之后就关闭该连接。</p>
<p>第四行指明用户代理，即向服务器发送请求的浏览器的类型。</p>
<p>第五行表示得到该对象的语言版本。</p>
<h5 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h5><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7F7DCE8DD167BF27491B5FD171EE6436.jpg" alt="img" style="zoom: 33%;"></p>
<p>一个初始状态行，六个首部行和实体体。</p>
<p>状态行有三个字段：协议版本字段，状态码，相应状态信息。</p>
<p>第二行告诉客户发送报文完后将关闭该TCP连接。</p>
<p>第三行DATE为服务器产生并发送该响应报文的日期和时间。这个时间是服务器从文件系统中检索到该对象，插入响应报文，并发送该响应报文的时间。</p>
<p>第四行指示该报文由什么服务器产生。</p>
<p>第五行指示了该对象创建或最后修改的时间和日期。</p>
<p>第六行指示了被发送对象中的字节数。</p>
<p>第七行指示了实体体对象是HTML文本。</p>
<p>一些常见的状态码：</p>
<p>200 OK：请求成功</p>
<p>301 Moved Permanently：请求的对象已经被永久转移。</p>
<p>400 Bad Request：一个通用差错码，指示该请求不能被服务器理解。</p>
<p>404 Not Found：被请求的文档不在服务器上。</p>
<p>505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP版本协议。</p>
<h4 id="用户与服务器的交互：cookie"><a href="#用户与服务器的交互：cookie" class="headerlink" title="用户与服务器的交互：cookie"></a>用户与服务器的交互：cookie</h4><p>cookie技术有四个组件：</p>
<p>在HTTP响应报文中的一个cookie首部行；</p>
<p>在HTTP请求报文中的一个cookie首部行；</p>
<p>在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理；</p>
<p>位于Web站点的一个后端数据库。</p>
<h4 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h4><p>也叫代理服务器。其既是客户又是服务器。</p>
<p><strong>内容分发网络</strong>CDN</p>
<h4 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h4><h3 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h3><p>因特网电子邮件系统由三个主要组成部分：用户代理；邮件服务器；简单邮件传输协议(SMTP)。</p>
<p>发送邮件的为SMTP的客户端。</p>
<h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p>SMTP一般不使用中间邮件服务器发送邮件。</p>
<h4 id="与HTTP对比"><a href="#与HTTP对比" class="headerlink" title="与HTTP对比"></a>与HTTP对比</h4><p>HTTP是一个拉协议，即在方便的时候，某些人在Web服务器上装载信息，用户使用HTTP从该服务器拉取这些信息。</p>
<p>SMTP基本上是一个推协议，即发送邮件服务器把文件推向接收邮件服务器。</p>
<p>SMTP要求每个报文采用7比特ASCLL码格式。若包含非7比特ASCLL字符，则该报文必须按照7比特ACLL进行编码。</p>
<p>对于一个既包含文本又包含图形的文档。HTTP把每个对象封装到自己的响应报文，而SMTP则把所有报文对象放在一个报文中。</p>
<h4 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h4><p>用户代理不能通过SMTP得到报文，因为取报文是一个拉操作，而SMTP为一个推操作。所以引入其他协议。</p>
<p><strong>POP3第三版的邮局协议</strong></p>
<p>随着TCP连接，POP3按照三个阶段进行工作：特许，事务处理以及更新。</p>
<p>特许阶段：用户代理发送(以明文形式)用户名和口令以鉴别用户。</p>
<p>事务处理阶段：用户代理取回报文。同时还可以做以下操作，对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息。</p>
<p>更新阶段：出现在客户发出quit命令后，目的是结束POP3会话，这时，邮件服务器删除那些标记为删除的报文。</p>
<h3 id="DNS-因特网的目录服务"><a href="#DNS-因特网的目录服务" class="headerlink" title="DNS:因特网的目录服务"></a>DNS:因特网的目录服务</h3><p>我们需要一种能进行主机名到IP地址转换的目录服务。这就是 <strong>域名系统DNS</strong>的主要任务。DNS是：</p>
<p>一个由分层的DNS服务器实现的分布式数据库；一个使得主机能够查询分布式数据库的应用层协议。</p>
<p>DNS运行在UDP之上，使用53号端口。</p>
<p>DNS其他一些重要服务：</p>
<p>主机别名；邮件服务器别名；负载分配。</p>
<h4 id="DNS工作机理概述"><a href="#DNS工作机理概述" class="headerlink" title="DNS工作机理概述"></a>DNS工作机理概述</h4><h5 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a>分布式、层次数据库</h5><p><strong>根DNS服务器</strong></p>
<p><strong>顶级域服务器</strong>：com,org,uk等</p>
<p><strong>权威DNS服务器</strong></p>
<p>另外有本地DNS服务器，但不属于该服务器层次结构。</p>
<h5 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h5><p>改善时延性能，减少在因特网上到处传输的DNS报文数量。</p>
<h4 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h4><p>共同实现DNS分布式数据库的所有DNS服务器存储了 <strong>资源记录</strong>（RR），RR提供了主机名到IP地址的映射。</p>
<p>资源记录是一个包含了下列字段的四元组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Name,Value,Type,TTL)</span><br></pre></td></tr></table></figure>
<p>TTL是该记录的生存时间，它记录了资源记录应当从缓存中删除的时间。NAME和VALUE的取值取决于TYPE：</p>
<p>若TYPE=A，则Name为主机名，Value为该主机名对应的IP地址。</p>
<p>若Type=NS,则Name是个域，而Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。</p>
<p>若Type=CNAME，则Value是别名为Name的主机对应的规范主机名。</p>
<p>若Type=MX，则Value是个别名为Name的邮件服务器的规范主机名。</p>
<h5 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h5><p>DNS只有查询和回答报文，并且有着相同的格式。</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/EFDFC6E3DB20E8F88B4B764C372E1F5A.jpg" alt="img" style="zoom:33%;"></p>
<h3 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h3><p><strong>分发时间</strong>是所有N个对等方得到该文件的副本所需要的时间。</p>
<p>BitTorrent是一种用于分发的流行P2P协议。参与一个特定文件分发的所有对等方的集合称为洪流。</p>
<p>在决定请求哪些块的过程中，采用 <strong>最稀缺优先</strong>的技术。针对他没有的块在他的邻居中决定最稀缺的块（最稀缺的块就是那些在他的邻居中副本数量最少的块）。</p>
<p>为决定响应哪个请求，他根据当前能够以最高速率向他提供数据的邻居，给出其优先权。每过10秒，重新计算，每过30秒，随机选择一个。</p>
<h3 id="附加-1"><a href="#附加-1" class="headerlink" title="附加"></a>附加</h3><p>网络应用体系结构主要包括C/S、纯P2P、混合模式三种类型。</p>
<p>流量控制关注的是接收端数据接收处理与缓存能力；拥塞控制关注的是网络传输能力。</p>
<p><strong>HTTP1.0与HTTP1.1的区别</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.0：非持续性，每个TCP连接最多允许一个传输对象，方法有GET,POST,HEAD</span><br><span class="line">1.1：持续性连接，每个TCP连接允许传输多个对象，方法增加PUT，DELETE</span><br></pre></td></tr></table></figure>
<p>HTTP无状态性：不记录用户信息</p>
<p><strong>WEB缓存</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缩短客户请求时间；减少机构/组织的流量；在大范围内实现有效的内容分发</span><br></pre></td></tr></table></figure>
<p><strong>递归查询与迭代查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">递归查询请求1次，迭代查询请求多次</span><br></pre></td></tr></table></figure>
<p>FTP客户和服务器传递FTP命令时，用的是（建立在TCP之上的控制连接）</p>
<p>典型的邮件接收协议：POP3,IMAP,HTTP</p>
<h2 id="运输层-1"><a href="#运输层-1" class="headerlink" title="运输层"></a>运输层</h2><h3 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h3><p>运输层协议为运行在不同主机上的应用程序之间提供了逻辑通信功能。</p>
<h4 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h4><p>网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信。</p>
<p>运输层协议只工作在端系统。</p>
<h4 id="因特网运输层概述"><a href="#因特网运输层概述" class="headerlink" title="因特网运输层概述"></a>因特网运输层概述</h4><p>UDP用户数据报协议</p>
<p>TCP传输控制协议</p>
<p>因特网网络层协议有一个名字叫IP，即网际协议。IP的服务模型是尽力而为交付服务，但并不做任何保证。故IP也被称为不可靠服务。</p>
<p>UDP和TCP最基本的责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。</p>
<p>将主机间交付扩展到进程间交付被称为 <strong>运输层的多路复用</strong>与 <strong>多路分解</strong>。</p>
<h3 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h3><p>将运输层报文段中的数据交付到正确的套接字的工作称为<strong>多路分解</strong>。</p>
<p>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将这些报文段传递到网络层，所有这些称为 <strong>多路复用</strong>。</p>
<p>运输层多路复用要求：套接字有唯一标识符；每个报文段有特殊字段来暗示该报文段要交付的套接字。</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/143F19CB931A13D23731D51D22A2F5D7.jpg" alt="img" style="zoom: 33%;"></p>
<p>如图，这些特殊字段是源端口号字段和目的端口号字段。端口号是一个16比特的数，大小在0-65535之间。0-1023范围的端口号称为周知端口号。</p>
<h4 id="无连接的多路复用与多路分解"><a href="#无连接的多路复用与多路分解" class="headerlink" title="无连接的多路复用与多路分解"></a>无连接的多路复用与多路分解</h4><p>一个UDP套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号。</p>
<p>如果两个UDP报文段有不同的源，但是具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的套接字被定向到相同的进程。</p>
<h4 id="面向连接的多路复用与多路分解"><a href="#面向连接的多路复用与多路分解" class="headerlink" title="面向连接的多路复用与多路分解"></a>面向连接的多路复用与多路分解</h4><p>TCP套接字由一个四元组（源IP地址，源端口号，目的IP地址，目的端口号）来标识的。</p>
<p>与UDP不同的是，两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字。</p>
<h4 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h4><p>DNS采用UDP。</p>
<p>采用UDP原因：</p>
<p>关于发送什么数据以及何时发送的应用层控制更为精细；</p>
<p>无需建立连接；</p>
<p>无连接状态；</p>
<p>分组首部开销小。</p>
<p>UDP用于承载网络管理数据(SNMP)。</p>
<p>需要注意的是，使用UDP的应用是可能实现可靠数据传输的。</p>
<h4 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h4><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/BB386DEE1B5745AB96A5BBAA6C284FED.jpg" alt="img" style="zoom:33%;"></p>
<p>UDP首部只有4个字段，每个字段由两个字节组成。长度字段指示了在UDP报文段中的字节数。接收方使用检验和来判断是否出差错。</p>
<h4 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h4><p>UDP提供检验和的原因是不能保证源和目的之间的所有链路能提供差错检验。在既无法确保逐链路的可靠性，又无法确保内存中的差错检验的情况下，如果端到端数据传输服务要提供差错检测，UDP就必须在端到端基础上在运输层提供差错检测。这是一个在系统设计中被称颂的 <strong>端到端原则</strong>的例子，该原则表述为因为某种功能必须基于端到端实现。</p>
<p>UDP对差错恢复无能为力。</p>
<h3 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h3><p>rdt 可靠数据传输</p>
<p>udt 不可靠数据传输</p>
<h4 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h4><h5 id="经完全可靠信道的可靠数据传输：rdt1-0"><a href="#经完全可靠信道的可靠数据传输：rdt1-0" class="headerlink" title="经完全可靠信道的可靠数据传输：rdt1.0"></a>经完全可靠信道的可靠数据传输：rdt1.0</h5><h5 id="经具有比特差错信道的可靠数据传输：rdt2-0"><a href="#经具有比特差错信道的可靠数据传输：rdt2-0" class="headerlink" title="经具有比特差错信道的可靠数据传输：rdt2.0"></a>经具有比特差错信道的可靠数据传输：rdt2.0</h5><p>基于肯定确认和否定确认重传机制的可靠数据传输协议称为 <strong>自动重传请求协议(ARQ)</strong></p>
<p>ARQ协议中还需要另外三种协议功能来处理存在比特差错的情况：</p>
<p>差错检测；接收方反馈(ACK,NAK)；重传</p>
<p><strong>停等</strong>：发送方将不会发送新数据，除非发送方确信接收方已正确接收当前分组。</p>
<p>考虑处理受损ACK和NAK时的三种可能：</p>
<p>（1）接收方复述其回答。</p>
<p>（2）增加足够的检验和比特。</p>
<p>（3）收到受损的ACK或NAK时，重传当前数据分组。但无法知道接收到的是新的还是重传。</p>
<p>解决这个问题的方法是在数据分组中添加一新字段，让发送方对其数据进行编号。</p>
<p><strong>rdt2.1</strong>使用了从接收方到发送方的肯定确认和否定确认。当接收到失序的分组时，接收方对所接受的分组发送一个肯定确认。如果收到受损的分组，则接收方将发送一个否定确认。如果不发送NAK，而是对上次正确接收分组的一个ACK，也能实现与NAK一样的效果。即接收冗余ACK.</p>
<p><strong>rdt2.2</strong>在有比特差错信道上实现的一个无NAK的可靠数据传输协议，</p>
<h5 id="经具有比特差错的丢包信道的可靠数据传输：rdt3-0"><a href="#经具有比特差错的丢包信道的可靠数据传输：rdt3-0" class="headerlink" title="经具有比特差错的丢包信道的可靠数据传输：rdt3.0"></a>经具有比特差错的丢包信道的可靠数据传输：rdt3.0</h5><p>基于时间重传，介入倒计时定时器。</p>
<p>rdt3.0又称为比特交替协议。</p>
<p>在数据传输中，检验和、序号、定时器、肯定和否定确定分组这些技术都起到了必不可少的作用。</p>
<h4 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h4><p>信道利用率：发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比。</p>
<p>引入流水线，对可靠数据传输协议带来以下影响：</p>
<p>增加序号范围，每个传输分组必须有唯一的序号；</p>
<p>协议的发送方和接收方不得不缓存多个分组；</p>
<p>解决流水线差错恢复有两种方法，<strong>回退N步</strong>和<strong>选择重传</strong>。</p>
<h4 id="回退N步"><a href="#回退N步" class="headerlink" title="回退N步"></a>回退N步</h4><p>GBN协议。</p>
<p>我们将基序号(base)定义为最早未确认分组的序号。下一个序号(nextseqnum)定义为最小的未使用序号（即下一个待发分组的序号），则将序号范围分成四段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0,base-1]已经发送被确认</span><br><span class="line">[base,nextseqnum-1]已发送但未被确认</span><br><span class="line">[nextseqnum,base+N-1]可用还未被发送</span><br><span class="line">最后 不可用</span><br></pre></td></tr></table></figure>
<p>N常被称为窗口长度。GBN也被称为滑动窗口协议。</p>
<p>采用累积确认，若超时，则重发所有已发送但还未被确认过的分组。</p>
<p>在GBN协议中，接收方丢弃所有失序分组。</p>
<h4 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h4><p>SR</p>
<p>SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存知道所有丢失分组皆被收到为止。</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/080960FFD5542FB89DBB28A2DB3154EC.jpg" alt="img" style="zoom:33%;"></p>
<p>窗口长度必须小于或等于序号空间大小的一半。</p>
<p>总结</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6DB68DCFFFDE66F29D794A2607A03373.jpg" alt="img" style="zoom:33%;"></p>
<h3 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h3><h4 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h4><p>TCP被称为是 <strong>面向连接的</strong>。中间路由器对TCP连接完全视而不见，他们看到的是数据报，而不是连接。</p>
<p>TCP连接提供的是<strong>全双工服务</strong>。TCP连接也总是点对点的。</p>
<p>三次握手中前两次不承载有效载荷，第三次可以承载有效载荷。</p>
<p>TCP可从缓存中取出并放入报文段中的数据数量受限于 <strong>最大报文段长度（MSS）</strong>。</p>
<p>MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的 <strong>最大传输单元</strong>MTU）来设置。</p>
<p>TCP为每块客户数据配上一个TCP首部，从而形成多个 <strong>TCP报文段</strong>。</p>
<h4 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h4><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DD4CF7C38D924B54C7925183D70902F1.jpg" alt="img" style="zoom:33%;"></p>
<p>与UDP一样，首部包含 <strong>源端口号</strong>， <strong>目的端口号</strong>，<strong>检验和字段</strong>。</p>
<p>TCP报文段首部还包含以下字段：</p>
<p>32比特的 <strong>序号字段</strong>和32比特的 <strong>确认号字段</strong>。用来实现可靠数据传输服务。</p>
<p>16比特的 <strong>接收窗口字段</strong>，用于流量控制。</p>
<p>4比特的 <strong>首部字段长度</strong>，通常选项字段为空，所以TCP首部的典型长度是20字节。</p>
<p>可选与变长的 <strong>选项字段</strong>，用于发送方与接收方协商最大报文段长度。</p>
<p>6比特的 <strong>标志字段</strong>。</p>
<h5 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h5><p>一个报文段的序号是该报文段首字节的字节流编号。</p>
<p>主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。</p>
<p>TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供 <strong>累积确认</strong>。</p>
<h4 id="可靠数据传输-1"><a href="#可靠数据传输-1" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h4><p>TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非冗余和按序的数据流。</p>
<h5 id="超时间隔加倍"><a href="#超时间隔加倍" class="headerlink" title="超时间隔加倍"></a>超时间隔加倍</h5><p>在这种修改中，每次TCP重传时都会将下一次的超时间隔设为先前值的两倍。</p>
<h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>一旦收到三个冗余ACK，就进行快速重传。</p>
<p>对TCP的一种修改意见是所谓的 <strong>选择重传</strong>。</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>TCP为它的应用程序提供了 <strong>流量控制服务</strong>以消除发送方使接收方缓存溢出的可能性。</p>
<p>TCP发送方也可能因为IP网络的拥塞而被遏制，这种形式的发送方的控制被称为<strong>拥塞控制</strong>。</p>
<p>TCP通过让发送方维护一个被称为 <strong>接收窗口</strong>的变量来提供流量控制。</p>
<p>当接收窗口等于0时，仍可发送一个较小的数据，以把窗口信息带回来。</p>
<h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/D93E5D5D739102092F48EB3F1A7E5CBF.jpg" alt="img" style="zoom:33%;"></p>
<p>确认y表明在y之前的所有字节都被正确接收。</p>
<h3 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h3><p>当一个分组沿一条路径被丢弃时，每个上游路由器由于转发该分组到丢弃该分组而使用的传输容量最终被浪费。</p>
<h4 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h4><p>端到端拥塞控制；</p>
<p>网络辅助的拥塞控制</p>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>指导原则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个丢失的报文段意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率。</span><br><span class="line">一个确认报文段指示该网络正在向接收方交付发送方的报文。</span><br><span class="line">带宽探测。</span><br></pre></td></tr></table></figure>
<h4 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h4><h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>cwnd（拥塞窗口）的值通常初始置为一个MSS的较小值。当传输的报文段首次被确认就增加一个MSS。成指数增长。</p>
<h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>当进入拥塞状态，cwnd值为上次拥塞的一半，然后线性增长。</p>
<h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h5><p>阈值前指数，阈值后线性。</p>
<h5 id="TCP拥塞控制-1"><a href="#TCP拥塞控制-1" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h5><p>加性増乘性减（丢包由三个冗余ACK）</p>
<h4 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h4><p>TCP具有公平性。</p>
<h3 id="附加-2"><a href="#附加-2" class="headerlink" title="附加"></a>附加</h3><p>典型的邮件接收协议有 POP，IMAP，HTTP。</p>
<p>实现文件分发应用时，采用P2P技术比典型的client/server技术更快。</p>
<p>发送窗口大小取决于min(rwnd,cwnd).</p>
<p>其中rwnd是接收缓存的空余大小，表示接收方还能接收多少。<br>cwnd就是我们常常画慢增长曲线，拥塞避免曲线等等分析的纵轴数值。</p>
<p>附一道题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/aodubi0638/article/details/102144555</span><br></pre></td></tr></table></figure>
<p>接收窗口 发送窗口 拥塞窗口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/ligupeng7929/article/details/79597423</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205152701158.png" alt="image-20211205152701158"></p>
<p>计算UDP校验和时，封装UDP报文段的IP数据报某些字段也会参与：源IP地址，目的IP地址，协议。</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205163248158.png" alt="image-20211205163248158" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205163258119.png" alt="image-20211205163258119" style="zoom:50%;"></p>
<h2 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h2><p>网络层能够被分为两个互相作用的平面：数据平面和控制平面。</p>
<h3 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h3><p>网络层的作用：即将分组从一台发送主机移到一台接收主机。为此，需要使用两种重要的网络层功能：</p>
<p><strong>转发</strong>：当一个分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路。</p>
<p><strong>路由选择</strong>：当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法被称为 <strong>路由选择算法</strong>。</p>
<p><strong>转发</strong>：将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地工作。</p>
<p><strong>路由选择</strong>：确定分组从源到目的地所采取的端到端路径的网络范围处理过程。</p>
<p>每台路由器中有一个关键元素是它的 <strong>转发表</strong>。</p>
<h4 id="网络层核心功能"><a href="#网络层核心功能" class="headerlink" title="网络层核心功能"></a>网络层核心功能</h4><h5 id="转发与路由"><a href="#转发与路由" class="headerlink" title="转发与路由"></a>转发与路由</h5><p>转发：将分组从路由器的输入端口到合适的输出端口。</p>
<p>路由：确定分组从源到目的经过的路径。</p>
<h5 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h5><p>某些网络的重要功能：ATM,X.25,帧中继</p>
<p>数据分组传输之前两端主机需要首先建立虚拟、逻辑连接</p>
<p>网络层连接是两个主机之间（路径上的路由器等网络设备参与其中），传输层连接为两个应用进程间（对中间网络设备透明）</p>
<h4 id="网络层服务模型"><a href="#网络层服务模型" class="headerlink" title="网络层服务模型"></a>网络层服务模型</h4><p>无连接服务(connection-less service)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">不事先为系列分组的传输确定传输路径；</span><br><span class="line"></span><br><span class="line">每个分组独立确定传输路径；</span><br><span class="line"></span><br><span class="line">不同分组可能传输路径不同；</span><br><span class="line"></span><br><span class="line">数据报网络。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>连接服务(connection service)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先Wie系列分组的传输确定从源到目的经过的路径；</span><br><span class="line">然后沿该路径（连接）传输系列分组；</span><br><span class="line">系列分组传输路径相同；</span><br><span class="line">传输结束后拆除连接</span><br><span class="line">虚电路网络</span><br></pre></td></tr></table></figure>
<h3 id="虚电路与数据报网络"><a href="#虚电路与数据报网络" class="headerlink" title="虚电路与数据报网络"></a>虚电路与数据报网络</h3><p><strong>虚电路</strong>：一条从源主机到目的主机，类似于电路的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分组交换</span><br><span class="line">每个分组的传输利用链路的全部带宽</span><br><span class="line">源到目的路径经过的网络层设备共同完成虚电路功能。</span><br></pre></td></tr></table></figure>
<p>通信过程：呼叫建立-&gt;数据传输-&gt;呼叫拆除</p>
<p>每个分组携带虚电路表示（VCID），而不是目的主机地址。</p>
<p>虚电路经过的每个网络设备，维护每条经过它的虚电路连接状态。</p>
<p>每条虚电路包括</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从源主机到目的主机的一条路径</span><br><span class="line">虚电路号，沿路每段链路一个编号(虚电路号会变化)</span><br><span class="line">沿路每个网络层设备，利用转发表记录经过的每条虚电路</span><br><span class="line">同一条VC，在每段链路的VCID不同</span><br></pre></td></tr></table></figure>
<p>虚电路信令协议：</p>
<p>用于VC的建立，维护拆除</p>
<p><strong>数据报网络</strong></p>
<p>网络层无连接；每个分组携带目的地址；路由器根据分组的目的地址转发分组。</p>
<p>路由算法确定通过网络的端到端路径；咋混发表确定在本路由器如何转发分组。</p>
<p>最长前缀匹配优先。</p>
<p>数据报网络简化网络，复杂边缘。</p>
<p>VC网络简化边缘，复杂网络。</p>
<h3 id="IPv4协议"><a href="#IPv4协议" class="headerlink" title="IPv4协议"></a>IPv4协议</h3><h4 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h4><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/77B4CDB215E21ACDFC543EF7F2428952.jpg" alt="img" style="zoom:25%;"></p>
<p>版本：4比特</p>
<p>首部长度：4比特（以4字节为单位）</p>
<p>服务类型：8比特，区分服务（只有在网络提供服务时才使用，通常取0）</p>
<p>长度：IP分组的总字节数，最大长度65535B</p>
<p>寿命：TTL，占8位，标识IP分组在网络中可以通过的路由器数。TTL=0，则丢弃该分组。</p>
<p>协议：8位，指示封装的是哪个协议。</p>
<p>首部校验和：16位，计算校验和时，置全0。逐跳计算</p>
<p>最大传输单元MTU-链路层数据帧可封装数据的上限。</p>
<p>不同链路的MTU不同。</p>
<h4 id="IP数据分片"><a href="#IP数据分片" class="headerlink" title="IP数据分片"></a>IP数据分片</h4><p>IP分片到达目的主机后进行重组。</p>
<p>标识字段占16位：标识一个IP分组。每产生IP分组+1.</p>
<p>标志位：3位。保留|DF|MF</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DF=1禁止分片</span><br><span class="line">DF=0允许分片</span><br><span class="line">MF=1非最后一片</span><br><span class="line">MF=0最后一片或未分片</span><br></pre></td></tr></table></figure>
<p>片偏移：13比特，相对偏移量。片偏移字段以8字节为单位。</p>
<p>分片时每个分片的标识复制原IP分组的标识。</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204104154990.png" alt="image-20211204104154990" style="zoom:50%;"></p>
<h4 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h4><p>32比特</p>
<p>IP地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">网络号-高位比特</span><br><span class="line">主机号-低位比特</span><br></pre></td></tr></table></figure>
<p>IP子网：IP地址具有相同网络号的设备接口</p>
<p>不跨越路由器可以彼此物理联通的接口。</p>
<h4 id="有类IP地址"><a href="#有类IP地址" class="headerlink" title="有类IP地址"></a>有类IP地址</h4><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211203200924251.png" alt="image-20211203200924251" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211203201114136.png" alt="image-20211203201114136" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211203201541925.png" alt="image-20211203201541925" style="zoom: 50%;"></p>
<h4 id="IP子网与子网划分"><a href="#IP子网与子网划分" class="headerlink" title="IP子网与子网划分"></a>IP子网与子网划分</h4><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211203203222147.png" alt="image-20211203203222147" style="zoom:50%;"></p>
<p>子网掩码：32比特</p>
<p>取值：NetID、SubID全取1</p>
<p>HostID全取0</p>
<p>将IP分组的目的IP地址与子网掩码按位与运算，提取子网地址。</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211203203919857.png" alt="image-20211203203919857" style="zoom:50%;"></p>
<p>主机路由：子网掩码 255.255.255.255</p>
<h3 id="CIDR与路由聚合"><a href="#CIDR与路由聚合" class="headerlink" title="CIDR与路由聚合"></a>CIDR与路由聚合</h3><p>无类域间路由CIDR</p>
<p>消除传统的ABC类地址界限。</p>
<p>无类地址格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.b.c.d/x x为前缀长度</span><br></pre></td></tr></table></figure>
<p>提高IPV4地址空间分配效率；</p>
<p>提高路由效率</p>
<h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><p>动态主机配置协议。</p>
<p>从服务器动态获取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IP地址</span><br><span class="line">子网掩码</span><br><span class="line">默认网关地址</span><br><span class="line">DNS服务器名称与IP地址</span><br></pre></td></tr></table></figure>
<p>默认网关：IP或数据报要离开时送到哪个接口</p>
<p>由于DHCP具有将主机连接进一个网络的网络相关方面的自动能力，故他又被称为 <strong>即插即用协议</strong>或 <strong>零配置</strong>。</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211203210949264.png" alt="image-20211203210949264" style="zoom:50%;"></p>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>网络地址转换。</p>
<p>所有离开本地网络去往Internet的数据报的源IP地址需替换为相同的NAT</p>
<p>动机：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">只需从ISP申请一个IP地址，IPV4地址耗尽。</span><br><span class="line">本地网络设备IP地址变更，无需告诉外界。</span><br><span class="line">变更ISP，无需修改内部网络设备IP地址。</span><br><span class="line">内部网络设备对外界网络不可见，即不可直接寻址。（安全)</span><br></pre></td></tr></table></figure>
<h3 id="互联网控制报文协议（ICMP）"><a href="#互联网控制报文协议（ICMP）" class="headerlink" title="互联网控制报文协议（ICMP）"></a>互联网控制报文协议（ICMP）</h3><p>支持路由器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">差错报告</span><br><span class="line">网络探寻</span><br></pre></td></tr></table></figure>
<p>两类ICMP报文：</p>
<p>差错报告报文（5种）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">目的不可达</span><br><span class="line">源抑制</span><br><span class="line">超时/超期</span><br><span class="line">参数问题</span><br><span class="line">重定向</span><br></pre></td></tr></table></figure>
<p>网络探寻报文（2组）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">回声请求与应答报文</span><br><span class="line">时间戳请求与应答报文</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204092543695.png" alt="image-20211204092543695" style="zoom:50%;"></p>
<h3 id="IPv6简介"><a href="#IPv6简介" class="headerlink" title="IPv6简介"></a>IPv6简介</h3><p>最初动机：32位IPV4地址分配完</p>
<p>其他动机：改进首部格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">快速转发/处理数据报</span><br><span class="line">支持QoS</span><br></pre></td></tr></table></figure>
<p>IPV6数据报格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">固定长度40字节基本首部</span><br><span class="line">不允许分片</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204093036564.png" alt="image-20211204093036564" style="zoom:50%;"></p>
<p>其他改变：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">检验和彻底移除，以减少每跳处理时间。</span><br><span class="line">选项：允许，但是从基本首部移除</span><br></pre></td></tr></table></figure>
<p>ICMPV6：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">附加报文类型</span><br><span class="line">多播组管理功能</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204093735301.png" alt="image-20211204093735301" style="zoom:50%;"></p>
<p>IPV6基本地址类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单播：一对一通信</span><br><span class="line">多播：一对多通信</span><br><span class="line">任意播：一对一组之一通信</span><br><span class="line">https://blog.csdn.net/weixin_40274679/article/details/106308577</span><br></pre></td></tr></table></figure>
<p>隧道：IPV6数据报作为IPV4数据报的载荷进行封装，穿越IPV4网络。</p>
<h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><h4 id="路由算法-1"><a href="#路由算法-1" class="headerlink" title="路由算法"></a>路由算法</h4><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204094231897.png" alt="image-20211204094231897" style="zoom:50%;"></p>
<h4 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h4><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204094325050.png" alt="image-20211204094325050" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204094606037.png" alt="image-20211204094606037" style="zoom:50%;">    </p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204094739283.png" alt="image-20211204094739283" style="zoom:50%;"></p>
<h4 id="距离向量路由算法"><a href="#距离向量路由算法" class="headerlink" title="距离向量路由算法"></a>距离向量路由算法</h4><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204100125061.png" alt="image-20211204100125061" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204100217247.png" alt="image-20211204100217247" style="zoom:50%;"></p>
<p>会带来无穷计数问题</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204100705477.png" alt="image-20211204100705477"></p>
<p>毒性逆转</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204100734803.png" alt="image-20211204100734803" style="zoom:50%;"></p>
<p>定义最大度量</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204100845755.png" alt="image-20211204100845755" style="zoom:50%;"></p>
<h4 id="层次化路由"><a href="#层次化路由" class="headerlink" title="层次化路由"></a>层次化路由</h4><p>管理自治：每个网络的管理可能都期望自主控制其网内的路由</p>
<p>聚合路由器为一个区域：自治系统AS</p>
<p>同一AS内的路由器运行相同的路由算法</p>
<p>网关路由器：位于AS边缘；通过链路连接其他AS的网关路由器</p>
<p>转发表由AS内部路由算法与AS间路由算法共同配置。</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204101931215.png" alt="image-20211204101931215"></p>
<h3 id="Internet路由"><a href="#Internet路由" class="headerlink" title="Internet路由"></a>Internet路由</h3><h4 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h4><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204102524132.png" alt="image-20211204102524132" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204102601078.png" alt="image-20211204102601078" style="zoom:50%;"></p>
<p>若180s没有收到通告，则邻居/链路失效</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204102654450.png" alt="image-20211204102654450" style="zoom:50%;"></p>
<h4 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h4><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204103218720.png" alt="image-20211204103218720" style="zoom:50%;"></p>
<p>优点（rip不具备）</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204103322151.png" alt="image-20211204103322151" style="zoom:50%;"></p>
<h4 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h4><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204103416370.png" alt="image-20211204103416370" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204114223787.png" alt="image-20211204114223787" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204114508159.png" alt="image-20211204114508159" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204114632956.png" alt="image-20211204114632956" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204115119242.png" alt="image-20211204115119242" style="zoom:50%;"></p>
<h3 id="附加-3"><a href="#附加-3" class="headerlink" title="附加"></a>附加</h3><p>拥塞丢失时发送抑制源站报文。</p>
<p>RIP为UDP协议传输报文。</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205192548473.png" alt="image-20211205192548473" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205201933225.png" alt="image-20211205201933225" style="zoom:50%;"></p>
<h2 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>节点</strong>：运行链路层协议的任何设备。包括主机，路由器，交换机和WiFi接入点。</p>
<h4 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">成帧</span><br><span class="line">链路接入。MAC媒体访问控制 协议规定了帧在链路上传输的规则</span><br><span class="line">可靠交付。链路层可靠交付目的是本地纠正一个差错，而不是通过运输层或应用层协议迫使进行端到端数据重传。</span><br><span class="line">差错检测和纠正。</span><br></pre></td></tr></table></figure>
<h4 id="链路层在何处实现"><a href="#链路层在何处实现" class="headerlink" title="链路层在何处实现"></a>链路层在何处实现</h4><p>链路层的主体部分是在 <strong>网络适配器</strong>中实现的，网络适配器有时也称 <strong>网络接口卡(NIC)</strong>。位于网络适配器核心的是链路层控制器。</p>
<h3 id="差错检测和纠正技术（EDC）"><a href="#差错检测和纠正技术（EDC）" class="headerlink" title="差错检测和纠正技术（EDC）"></a>差错检测和纠正技术（EDC）</h3><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>单个奇偶校验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送信息有d比特，增加一个附加比特，使得d+1个比特中1的总数为偶数。</span><br></pre></td></tr></table></figure>
<p>二维奇偶校验</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DEA818263830593A284962B85D4FCB4D.jpg" alt="img" style="zoom: 25%;"></p>
<p>接收方检测和纠正错误的能力被称为 <strong>前向纠错(FEC)</strong>。</p>
<h4 id="检验和方法"><a href="#检验和方法" class="headerlink" title="检验和方法"></a>检验和方法</h4><p>需要相对小的分组开销。</p>
<h4 id="循环冗余检测"><a href="#循环冗余检测" class="headerlink" title="循环冗余检测"></a>循环冗余检测</h4><p>CRC，也称多项式编码。</p>
<p>考虑d比特的数据D。发送方和接收方首先必须协商一个r+1比特模式，称为 <strong>生成多项式</strong>，将其表示为G。G的最高有效位比特是1.对于一个给定的数据段D，发送方要选择r个附加比特R，并将它们附加到D上，使得得到的d+r比特模式用模二运算恰好能被G整除。接收方用G去除接收到的d+r比特，若余数为非零，则出现差错。</p>
<p>$D*2^rXOR\ R=nG$</p>
<p>即$D*2^r=nG\ XOR\ R$</p>
<p>$R=remainder\ \frac{D*2^r}{G}$</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204135514798.png" alt="image-20211204135514798" style="zoom:25%;"></p>
<h3 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h3><p>多路访问控制MAC</p>
<p>MAC地址为链路层地址。</p>
<p><strong>点对点链路</strong>：由链路一端的单个发送方和链路另一端的单个接收方组成。eg:点对点协议(PPP)，高级数据链路控制(HDLC)。</p>
<p><strong>广播链路</strong>：让多个发送和接收节点都连接到相同的单一的，共享的广播信道上。</p>
<h4 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h4><p>时分多路复用TDM；频分多路复用FDM</p>
<p>TMD的缺陷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">节点被限制于R/Nbps的平均速率，即使他是唯一有分组要发送的节点。</span><br><span class="line">节点必须总是等待他的轮次。</span><br></pre></td></tr></table></figure>
<p>FDM将Rbps信道划分为不同的频段（每个频段具有R/N带宽）。同样也限制了带宽。</p>
<p>第三种信道划分协议是码分多址(CDMA)。</p>
<p>CDMA对每个节点分配一种不同的编码，然后每个节点用它唯一的编码来对它发送的数据进行编码。</p>
<h4 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h4><p>在随机接入协议中，一个传输节点总是以信道的全部速率进行发送。当有碰撞时，涉及碰撞的每个节点反复地重发它的帧，但是在重发之前会等待一个随机时延。</p>
<h5 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h5><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204143122814.png" alt="image-20211204143122814" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204143238161.png" alt="image-20211204143238161" style="zoom: 50%;"></p>
<h5 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h5><p>非时隙ALOHA：更加简单，无需同步。</p>
<p>当有新的帧生成时，立即发送。</p>
<h5 id="载波侦听多路访问CSMA"><a href="#载波侦听多路访问CSMA" class="headerlink" title="载波侦听多路访问CSMA"></a>载波侦听多路访问CSMA</h5><p>载波侦听：即一个节点在传输前先听信道，若来自另一个节点的帧正在向信道发送，节点则等待直到检测到一小段时间没有传输，然后开始传输。</p>
<p>P坚持CSMA：以概率P发送，一直侦听。</p>
<h5 id="具有碰撞检测的载波侦听多路访问-CSMA-CD"><a href="#具有碰撞检测的载波侦听多路访问-CSMA-CD" class="headerlink" title="具有碰撞检测的载波侦听多路访问(CSMA/CD)"></a>具有碰撞检测的载波侦听多路访问(CSMA/CD)</h5><p>碰撞检测：当一个传输节点在传输时一直在侦听此信道。如果它检测到另一个节点在传输干扰帧，他就停止传输，在重复“侦听-当空闲时传输”循环之前等待一段随机时间。</p>
<h5 id="CSMA-CD效率"><a href="#CSMA-CD效率" class="headerlink" title="CSMA/CD效率"></a>CSMA/CD效率</h5><p>定义为：当有大量的活跃节点，且每个节点有大量的帧要发送时，帧在信道中无碰撞地传输的那部分时间在长期运行时间中所占的份额。</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204145626654.png" alt="image-20211204145626654" style="zoom:50%;"></p>
<p>二进制指数后退算法</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/F572B4802749063215375D07DE109829.jpg" alt="img" style="zoom:50%;"></p>
<h4 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h4><p>轮询协议：要求节点之一被指定为主节点。主节点以循环的方式轮询每个节点。</p>
<p>缺点：引入轮询时间；若主节点有故障，则整个信道不可操作。</p>
<p>令牌传递协议：没有主节点，一个被称为令牌的小的特殊帧在节点之间以某种固定的次序进行交换。</p>
<h3 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h3><h4 id="链路层寻址和ARP"><a href="#链路层寻址和ARP" class="headerlink" title="链路层寻址和ARP"></a>链路层寻址和ARP</h4><h5 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h5><p>并不是主机或路由器具有链路层地址，而是它们的适配器（即网络接口）具有链路层地址。</p>
<p>链路层地址也叫LAN地址，物理地址或MAC地址。</p>
<p>对大多数局域网而言，MAC地址长度为6字节。没有两块适配器具有相同的地址。</p>
<p>对于使用六字节地址的局域网（以太网和802.11）来说，广播地址为48个连续的1.</p>
<h5 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议(ARP)"></a>地址解析协议(ARP)</h5><p>用于对网络层地址和链路层地址进行转换。</p>
<h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><p>以太网：物理拓扑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">总线：所有结点在同一冲突域</span><br><span class="line">星型：目前主流网络拓扑。每一个结点一个单独冲突域。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">无连接：发送帧的网卡与接收帧的网卡不握手</span><br><span class="line">不可靠，差错帧直接丢弃</span><br><span class="line">以太网MAC协议：采用二进制指数退避算法的CSMA/CD</span><br></pre></td></tr></table></figure>
<p>以太网CSMA/CD算法</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204155630443.png" alt="image-20211204155630443" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/937D97F0716ADB864BFCE5DE7C16A807.jpg" alt="img"></p>
<p>数据字段：46-1500字节。MTU为1500字节，不包含头部</p>
<p>目的地址：6字节。目的适配器的MAC地址。</p>
<p>源地址：6字节。传输该帧到局域网上的适配器的MAC地址。</p>
<p>类型字段：2字节，允许以太网复用多种网络层协议。</p>
<p>CRC：4字节，循环冗余检测</p>
<p>前同步码：8字节</p>
<h4 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h4><p>交换机自身对子网中的主机和路由器是透明的。</p>
<h5 id="交换机转发和过滤"><a href="#交换机转发和过滤" class="headerlink" title="交换机转发和过滤"></a>交换机转发和过滤</h5><p><strong>过滤</strong>：决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。</p>
<p><strong>转发</strong>：决定一个帧应该被导向哪个接口，并把帧移动到那些接口的交换机功能。</p>
<p>这两个功能借助于 <strong>交换机表</strong>。</p>
<p>表项包含</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个MAC地址；</span><br><span class="line">通向该MAC地址的交换机接口；</span><br><span class="line">表项放置在表中的时间</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6555DC610FAF264120FCF7D03DA40B67.jpg" alt="img" style="zoom: 33%;"></p>
<h5 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h5><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9F2AB3BE63BF7E455B67093F584A9DDF.jpg" alt="img" style="zoom: 33%;"></p>
<p>交换机是即插即用设备。</p>
<h5 id="链路层交换机的性质"><a href="#链路层交换机的性质" class="headerlink" title="链路层交换机的性质"></a>链路层交换机的性质</h5><p>消除碰撞；异质的链路；管理。</p>
<h5 id="交换机和路由器进行对比"><a href="#交换机和路由器进行对比" class="headerlink" title="交换机和路由器进行对比"></a>交换机和路由器进行对比</h5><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204163023218.png" alt="image-20211204163023218" style="zoom:33%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204163041260.png" alt="image-20211204163041260" style="zoom:50%;"></p>
<h4 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h4><p>VLAN</p>
<p>动态成员：端口可以动态分配给不同VLAN</p>
<p>在VLAN间转发：通过路由</p>
<p>多线缆连接</p>
<h3 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h3><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204165553120.png" alt="image-20211204165553120" style="zoom:33%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204165606380.png" alt="image-20211204165606380" style="zoom:33%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204165627410.png" alt="image-20211204165627410" style="zoom:33%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204170545298.png" alt="image-20211204170545298" style="zoom:33%;"></p>
<h3 id="附加-4"><a href="#附加-4" class="headerlink" title="附加"></a>附加</h3><p>MTU、IP MTU、TCP MSS设置上的区别及联系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.MTU是一个二层的概念，即最大传输单元（Maximum Transmission Unit，MTU）；以太网最大的mtu就是1500（它是不包含二层头部的，加上头部应该为1518 bytes，2bit的以太网类型+6bit的DMAC+6bit的SMAC+4bit的FCS），每个以太网帧都有最小的大小64bytes，最大不能超过1518bytes</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line"></span><br><span class="line">1）小于64Bytes的数据帧一般是由于以太网冲突产生的 “碎片”或者线路干扰或者坏的以太网接口产生的，对于大于1518Bytes的数据帧我们一般把它叫做Giant帧，这种一般是由于线路干扰或者坏的以太网口产生</span><br><span class="line"></span><br><span class="line">2）以太网EthernetII最大的数据帧是1518Bytes，最小为64bytes,是指包含以太网帧的帧头（DMAC目的MAC地址 48bit=6Bytes+SMAC源MAC地址48bit=6Bytes+Type域2bytes）14Bytes和帧尾CRC校验部分4Bytes （这个部份有时候大家也把它叫做FCS）</span><br><span class="line"></span><br><span class="line">2.IP MTU是一个三层概念，它包含了三层头部及所有载荷，根据下层为上层服务的，上层基于下层才能做进一步的扩展的原则，尽管IP MTU的变化范围很大（68-65535），但也不得不照顾以太网MTU的限制,说白了就是ip对以太网的妥协。</span><br><span class="line"></span><br><span class="line">网络层IP协议会检查每个从上层协议下来的数据包的大小，并根据本机MTU的大小决定是否作“分片”处理</span><br><span class="line"></span><br><span class="line">3.MSS是TCP里面的一个概念，它是TCP数据包每次能够传输的最大数据分段，不包含包头部分，它与IP MTU满足如下关系：</span><br><span class="line"></span><br><span class="line">IP MTU=MSS+20bytes（IP包头）+20bytes（TCP包头）</span><br><span class="line"></span><br><span class="line">当然，如果传输的时候还承载有其他协议，还要加些包头在前面。</span><br><span class="line"></span><br><span class="line">注：为了达到最佳的传输效能，TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU值代替（需要减去IP数据包报头的大小20Bytes和TCP数据段的包头20Bytes），所以往往MSS为1460。通讯双方会根据双方提供的MSS值得最小值确定为这次连接的最大MSS值。</span><br><span class="line"></span><br><span class="line">4.简言之，mtu就是总的最后发出去的报文大小，MSS就是需要发出去的数据大小，比如PPPoE，就是在以太网上承载PPP协议（点到点连接协议），它包括6bytes的PPPoE头部和2bytes的PPP协议ID号，此时，由于以太网的MTU值为1500，所以上层PPP负载数据不能超过1492字节，也就是相当于在PPPOE环境下的MTU是1492字节，MSS是1452字节（1492字节-20-20）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">重点：</span><br><span class="line"></span><br><span class="line">MTU 不包含 帧头（18byte） 指帧头后面的所有负载，与ip mtu的区别就是在帧头和ip头之间可能会有其他协议头（比如GRE头、pppoe头、MPLS标签，这些协议头都是在帧头后ip头前）</span><br><span class="line"></span><br><span class="line">ip MTU 包含 ip头（20byte） 指ip头本身及后面的所有负载，一个普通的以太网数据包mtu=ip mut，只有封装了其他协议头部时mtu=ip mut+其他协议头部+负载（tcp头+tcp-mss）</span><br><span class="line"></span><br><span class="line">TCP-MSS 不包含 tcp头（20byte） 指tcp头后面的所有负载</span><br><span class="line"></span><br><span class="line">IP MTU=tcp-MSS+20bytes（IP包头）+20bytes（TCP包头）</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204194239650.png" alt="image-20211204194239650"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205195424849.png" alt="image-20211205195424849" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205202022663.png" alt="image-20211205202022663" style="zoom:50%;"></p>
<h2 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h2><h3 id="数据通信基础"><a href="#数据通信基础" class="headerlink" title="数据通信基础"></a>数据通信基础</h3><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204201851500.png" alt="image-20211204201851500" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204202022742.png" alt="image-20211204202022742" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204202733890.png" alt="image-20211204202733890" style="zoom:50%;"></p>
<h3 id="物理介质"><a href="#物理介质" class="headerlink" title="物理介质"></a>物理介质</h3><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204202951972.png" alt="image-20211204202951972" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204203637959.png" alt="image-20211204203637959" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204203616661.png" alt="image-20211204203616661" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204203651460.png" alt="image-20211204203651460" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204203704180.png" alt="image-20211204203704180" style="zoom:50%;"></p>
<h3 id="信道与信道容量"><a href="#信道与信道容量" class="headerlink" title="信道与信道容量"></a>信道与信道容量</h3><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204203735096.png" alt="image-20211204203735096" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204203744847.png" alt="image-20211204203744847" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204203823712.png" alt="image-20211204203823712" style="zoom:50%;"></p>
<h3 id="基带传输基础"><a href="#基带传输基础" class="headerlink" title="基带传输基础"></a>基带传输基础</h3><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211204203916364.png" alt="image-20211204203916364" style="zoom:50%;"></p>
<h3 id="频带传输基础"><a href="#频带传输基础" class="headerlink" title="频带传输基础"></a>频带传输基础</h3><h4 id="典型数字基带信号码型"><a href="#典型数字基带信号码型" class="headerlink" title="典型数字基带信号码型"></a>典型数字基带信号码型</h4><p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205204044465.png" alt="image-20211205204044465" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205204526302.png" alt="image-20211205204526302" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205204553033.png" alt="image-20211205204553033" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205204657865.png" alt="image-20211205204657865" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205204718087.png" alt="image-20211205204718087" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205204743795.png" alt="image-20211205204743795" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205204811037.png" alt="image-20211205204811037" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205204844547.png" alt="image-20211205204844547" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205205637743.png" alt="image-20211205205637743" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205205848891.png" alt="image-20211205205848891" style="zoom:50%;"></p>
<ul>
<li>数据传输速率=波特率*log2(幅值相位组合)</li>
</ul>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205211421158.png" alt="image-20211205211421158" style="zoom:50%;"></p>
<h2 id="附加-5"><a href="#附加-5" class="headerlink" title="附加"></a>附加</h2><p>CDMA</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_43262059/article/details/106201119</span><br></pre></td></tr></table></figure>
<p>FTP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FTP协议运行在TCP连接上，保证了文件传输的可靠性。</span><br><span class="line">FTP使用了两个并行的TCP来传输文件：一个是控制连接（port:21），一个是数据连接(port:20)。控制连接用于在两个主机之间传输控制信息，如口令，用户标识，存放、获取文件等命令。数据连接用于实际发送一个文件,发送完文件之后数据连接会关闭。因为FTP协议使用一个独立的控制连接，所以，也称FTP的控制信息是带外（out-of-band）传送的。</span><br><span class="line">FTP支持两种方式的传输：文本（ASCII）方式和二进制（Binary）方式。</span><br></pre></td></tr></table></figure>
<p>在划分VLAN的以太网交换机的Trunk端口间传输的帧是802.1帧。</p>
<p>利用链路控制协议，大多数的产品通过协商可以省略标志符和地址字段，并且把协议字段由 2个字节减少到 1个字节。</p>
<p>二进制数字调制系统中，频带利用率最低的是2FSK。</p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205231152187.png" alt="image-20211205231152187" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205233856793.png" alt="image-20211205233856793" style="zoom:50%;"></p>
<p><img src="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211205234246885.png" alt="image-20211205234246885" style="zoom:50%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/24/SQL-SERVER/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/24/SQL-SERVER/" class="post-title-link" itemprop="url">SQL SERVER</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-24 22:27:21" itemprop="dateCreated datePublished" datetime="2021-11-24T22:27:21+08:00">2021-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-08 10:23:07" itemprop="dateModified" datetime="2021-12-08T10:23:07+08:00">2021-12-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><h3 id="Transact-SQL语言"><a href="#Transact-SQL语言" class="headerlink" title="Transact-SQL语言"></a>Transact-SQL语言</h3><h4 id="DCL数据控制语言（进行安全性管理）"><a href="#DCL数据控制语言（进行安全性管理）" class="headerlink" title="DCL数据控制语言（进行安全性管理）"></a>DCL数据控制语言（进行安全性管理）</h4><p>GRANT 授予权限</p>
<p>REVOKE 收回权限(不影响该用户从其他角色作为成员继承许可权限)</p>
<p>DENY 收回权限(禁止该用户从其他角色作为成员继承许可权限)</p>
<h4 id="DDL数据定义语言（执行数据库任务）"><a href="#DDL数据定义语言（执行数据库任务）" class="headerlink" title="DDL数据定义语言（执行数据库任务）"></a>DDL数据定义语言（执行数据库任务）</h4><p>CREATE 创建数据库或数据库对象</p>
<p>ALTER 修改——</p>
<p>DROP 删除——</p>
<h4 id="DML数据操作语言（操作数据库中各对象）"><a href="#DML数据操作语言（操作数据库中各对象）" class="headerlink" title="DML数据操作语言（操作数据库中各对象）"></a>DML数据操作语言（操作数据库中各对象）</h4><p>select 从表或试图中检索数据</p>
<p>insert ——插入数据</p>
<p>update ——修改</p>
<p>delete ——删除</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>包含三个基本文件</p>
<p>（1）基本数据文件：有且只有一个 .mdf</p>
<p>（2）辅助数据文件：自由选择，0,1,2  .ndf</p>
<p>（3）日志文件：由于恢复数据库所需要的事务日志信息，至少一个。 .ldf</p>
<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p><img src="/2021/11/24/SQL-SERVER/image-20211125152935936.png" alt="image-20211125152935936" style="zoom:50%;"></p>
<p><img src="/2021/11/24/SQL-SERVER/{}UQFN2@5NI@UMA3V@]KCK.png" alt="img" style="zoom: 33%;"></p>
<p>附一个源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">create database DB2</span><br><span class="line">on primary</span><br><span class="line">(</span><br><span class="line">name=&#x27;f1&#x27;,</span><br><span class="line">filename=&#x27;F:\sqlserve\sqlwj\f1.mdf&#x27;,</span><br><span class="line">size=3mb,</span><br><span class="line">maxsize=unlimited,</span><br><span class="line">filegrowth=3%</span><br><span class="line">),</span><br><span class="line">(</span><br><span class="line">name=&#x27;f2&#x27;,</span><br><span class="line">filename=&#x27;F:\sqlserve\sqlwj\f2.ndf&#x27;,</span><br><span class="line">size=10mb,</span><br><span class="line">maxsize=500mb,</span><br><span class="line">filegrowth=6mb</span><br><span class="line">)</span><br><span class="line">log on</span><br><span class="line">(</span><br><span class="line">name=&#x27;f3&#x27;,</span><br><span class="line">filename=&#x27;F:\sqlserve\sqlwj\f3.ldf&#x27;,</span><br><span class="line">size=1mb,</span><br><span class="line">maxsize=unlimited,</span><br><span class="line">filegrowth=2%</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改数据库名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--修改数据库的名字</span><br><span class="line">alter database DB2</span><br><span class="line">modify name=DB1</span><br></pre></td></tr></table></figure>
<p>添加辅助文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--在DB1中添加一个辅助文件日志文件</span><br><span class="line">alter database DB1</span><br><span class="line">add file</span><br><span class="line">(</span><br><span class="line">name=&#x27;f2a&#x27;,</span><br><span class="line">filename=&#x27;F:\sqlserver\sqlwj\f2a.ndf&#x27;,</span><br><span class="line">size=3mb,</span><br><span class="line">maxsize=unlimited,</span><br><span class="line">filegrowth=2mb</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>添加日志文件</p>
<p>add log file</p>
<p>删除数据库</p>
<p>drop database 数据库名</p>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="设计表"><a href="#设计表" class="headerlink" title="设计表"></a>设计表</h3><p>创建需要确定下列特征：</p>
<p>要包含的数据类型；</p>
<p>表中的列数，每一列中数据的类型和长度；</p>
<p>哪些列允许空值；</p>
<p>是否要使用以及何处使用约束；</p>
<p>哪些是主键，哪些为外键。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Bigint 大整型 8字节</p>
<p>int 常用的整型 4字节</p>
<p>smallint 小整型 2字节</p>
<p>tinyint 微整型 1字节</p>
<p>Bit 位类型 其取值只有0/1</p>
<p>decimal[(p[,s])]和numeric[(p[,s])] p总位数，s小数位 p默认为18，s默认为0</p>
<p>Money存储的货币值由八个字节，前四个代表整数，后四代表小数</p>
<h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><p>Datetime 长度8字节</p>
<p>1753.1.1-9999.12.31</p>
<p>Smalldatetime 四字节</p>
<p>1900.1.1-2079.12.31</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Char(n) n单位为字节，表示输入字符串的最大值，若超过则不存，小于则添加空格</p>
<p>varchar(n) 变动长度</p>
<h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>Nchar</p>
<p>Nvarchar</p>
<h4 id="二进制字符串"><a href="#二进制字符串" class="headerlink" title="二进制字符串"></a>二进制字符串</h4><p>Binary：binary(n)存储图像等数据</p>
<p>varbinary(n)</p>
<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>切换数据库名字 use 数据库名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--创建课程表（课程编号，课程名称，课程教师，上课时间）</span><br><span class="line">create table 课程表</span><br><span class="line">(</span><br><span class="line">课程编号 varchar(15) not null,</span><br><span class="line">课程名称 varchar(20) not null,</span><br><span class="line">任课教师 char(10) not null,</span><br><span class="line">上课时间 varchar(30) </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>添加列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 课程表</span><br><span class="line">add 上课教室 varchar(20) not null</span><br></pre></td></tr></table></figure>
<p>修改数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 课程表</span><br><span class="line">alter column 任课教师 varchar(10) not null</span><br></pre></td></tr></table></figure>
<p>删除列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 课程表</span><br><span class="line">drop column 任课教师 </span><br></pre></td></tr></table></figure>
<p>修改列名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_rename&#x27;表名.列名&#x27;,‘新列名&#x27;</span><br></pre></td></tr></table></figure>
<p>修改表名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_rename&#x27;原表名&#x27;,‘新表名&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>主键约束PRIMARY KEY</p>
<p>唯一确定表中每一按条记录的表示符</p>
<p>外键约束FOREIGN KEY</p>
<p>用于建立和加强两个表数据之间的连接</p>
<p>唯一约束UNIQUE</p>
<p>指定一个列或多个列的值具有唯一性，可为空</p>
<p>检查约束CHECK</p>
<p>限制输入值</p>
<p>默认约束DEFAULT</p>
<p>插入操作中没有提供输入值时系统会自动添加指定值</p>
<h5 id="创建约束"><a href="#创建约束" class="headerlink" title="创建约束"></a>创建约束</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名</span><br><span class="line">add constraint 约束名 约束类型 具体的约束说明</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-对表中的课程编号添加主键约束</span><br><span class="line">alter table 课程表 </span><br><span class="line">add constraint PK_课程编号 primary key (课程编号)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--对课程名称添加一个唯一约束unique</span><br><span class="line">alter table 课程表</span><br><span class="line">add constraint UN_课程名称 unique(课程名称)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--给上课教室添加默认约束</span><br><span class="line">alter table 课程表</span><br><span class="line">add constraint DF_教室 default &#x27;正兴&#x27; for 上课教室</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--给上课教室添加检查约束</span><br><span class="line">alter table 课程表</span><br><span class="line">add constraint CK_教室 check (上课教室=&#x27;正兴&#x27; or 上课教室=&#x27;诚意&#x27; or 上课教室=&#x27;致知&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/24/SQL-SERVER/image-20211125213841519.png" alt="image-20211125213841519"></p>
<p>外界约束前提，列中的数据类型必须保持一致。引用的列必须为主键约束或者唯一约束。两个表的列名尽量一致。</p>
<h4 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h4><p>alter table 表名</p>
<p>drop constraint 约束名</p>
<p>若被引用要先删除外界约束再删除主键约束</p>
<h4 id="在定义时约束"><a href="#在定义时约束" class="headerlink" title="在定义时约束"></a>在定义时约束</h4><p><img src="/2021/11/24/SQL-SERVER/image-20211126105437185.png" alt="image-20211126105437185"></p>
<h2 id="T-SQL语言"><a href="#T-SQL语言" class="headerlink" title="T-SQL语言"></a>T-SQL语言</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>标识符：数据库对象的名称</p>
<p>常规标识符与分隔标识符</p>
<h4 id="常规标识符规则"><a href="#常规标识符规则" class="headerlink" title="常规标识符规则"></a>常规标识符规则</h4><p>第一个字符必须是英文大小写字母；_;@;#</p>
<p>后续字符除了第一字符，还有十进制数字，美元符号($)</p>
<p>批处理：一次处理多条语句</p>
<h3 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h3><p>局部变量用DECLARE语句声明，作用范围仅在程序内部，局部变量的名称自己定义，以@开头。</p>
<p>声明语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @name datatype</span><br></pre></td></tr></table></figure>
<p>对局部变量赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET @NAME=expression</span><br><span class="line">SELECT @name=expression[,..n]</span><br></pre></td></tr></table></figure>
<p>SET只能对一个变量赋值</p>
<p>SELECT可以对多个赋值</p>
<p>PRINT输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--声明两个变量</span><br><span class="line">declare @name varchar(10),@age int</span><br><span class="line"></span><br><span class="line">--赋值</span><br><span class="line">set @name=&#x27;张三&#x27;</span><br><span class="line">set @age=18</span><br><span class="line"></span><br><span class="line">--select</span><br><span class="line">select @name=&#x27;李四&#x27;,@age=19</span><br><span class="line"></span><br><span class="line">print @name</span><br><span class="line">print @age</span><br></pre></td></tr></table></figure>
<p>全局变量是事先定义好的，不允许创建修改，以@@开头</p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>算数运算符</p>
<p>赋值运算符=</p>
<p>位运算符：两个整数类型表达式</p>
<p>比较运算符：除text,ntext.image数据类型外都可以用</p>
<p>逻辑运算符：</p>
<p>AND如果两个表达式都为true，则结果为true</p>
<p>BETWEEN如果操作数在某个范围，则结果为true</p>
<p>IN</p>
<p>LIKE</p>
<p>NOT</p>
<p>OR</p>
<p>一元运算符</p>
<h3 id="流控制语句"><a href="#流控制语句" class="headerlink" title="流控制语句"></a>流控制语句</h3><p>BEGIN…END用于将多个语句组合为一个逻辑块</p>
<p>IF…ELSE</p>
<p>WHILE</p>
<p>BREAK</p>
<p>CONTINUE</p>
<p>CASE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">case </span><br><span class="line">when ...then...</span><br><span class="line">when ...then...</span><br><span class="line">else </span><br></pre></td></tr></table></figure>
<p>WAITFOR延迟语句可以将它之后的语句在一个指定的时间间隔后执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Waitfor delay &#x27;time&#x27;|time&#x27;time&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">waitfor delay &#x27;00:00:03&#x27;</span><br><span class="line">print &#x27;傻瓜你好&#x27;</span><br><span class="line"></span><br><span class="line">waitfor time &#x27;17:34:59&#x27;</span><br><span class="line">print &#x27;傻瓜你好&#x27;</span><br></pre></td></tr></table></figure>
<p>GOTO</p>
<p>return无条件退出语句</p>
<h2 id="数据库操作实例"><a href="#数据库操作实例" class="headerlink" title="数据库操作实例"></a>数据库操作实例</h2><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--查询教师</span><br><span class="line">select 任课教师,上课时间 --列名</span><br><span class="line">from 课程表 --表名</span><br></pre></td></tr></table></figure>
<p>select *为查询所有列</p>
<h5 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h5><p>删除重复行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--去重复</span><br><span class="line">select distinct 任课教师</span><br><span class="line">from 课程表</span><br></pre></td></tr></table></figure>
<p>distinct后只能跟一个列</p>
<h5 id="TOP"><a href="#TOP" class="headerlink" title="TOP"></a>TOP</h5><p>用于规定要返回的查询结果的数目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--返回前3行所有数据</span><br><span class="line">select top 3 *</span><br><span class="line">from 课程表</span><br><span class="line"></span><br><span class="line">--返回前三行的任课教师和时间</span><br><span class="line">select top 3 任课教师,上课时间</span><br><span class="line">from 课程表</span><br></pre></td></tr></table></figure>
<p>去掉重复数据后，后面的数据往前补</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select distinct top 3 任课教师</span><br><span class="line">from 课程表</span><br></pre></td></tr></table></figure>
<h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--别名查询，方式一</span><br><span class="line">select 任课教师 &#x27;教师&#x27;, 上课时间 &#x27;时间&#x27;</span><br><span class="line">from 课程表</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方式二</span><br><span class="line">select &#x27;别名&#x27;=列名</span><br><span class="line">from 表名</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方式三</span><br><span class="line">select 列名 as &#x27;别名&#x27;</span><br><span class="line">from 表名</span><br></pre></td></tr></table></figure>
<h5 id="计算列"><a href="#计算列" class="headerlink" title="计算列"></a>计算列</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seclect &#x27;原始学号&#x27;=学号,&#x27;调整学号&#x27;=学号-10</span><br><span class="line">from 表名</span><br></pre></td></tr></table></figure>
<h4 id="选择查询"><a href="#选择查询" class="headerlink" title="选择查询"></a>选择查询</h4><p>基本语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT LIST</span><br><span class="line">FROM TABLE</span><br><span class="line">WHERE CONDITIONS</span><br></pre></td></tr></table></figure>
<h5 id="比较搜索条件"><a href="#比较搜索条件" class="headerlink" title="比较搜索条件"></a>比较搜索条件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;不等于</span><br><span class="line"></span><br><span class="line">!=不等于</span><br><span class="line">！&gt;不大于</span><br><span class="line">!&lt;不小于</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--查询任课教师为孙大烈的课程名称</span><br><span class="line">select 课程名称</span><br><span class="line">from 课程表</span><br><span class="line">where 任课教师=&#x27;孙大烈&#x27; 后可接逻辑运算符</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="范围搜索条件"><a href="#范围搜索条件" class="headerlink" title="范围搜索条件"></a>范围搜索条件</h5><p>包括范围</p>
<p>排他范围</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 课程编号</span><br><span class="line">from 课程表</span><br><span class="line">where 课程编号 (not) between 3 and 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="列表搜索条件"><a href="#列表搜索条件" class="headerlink" title="列表搜索条件"></a>列表搜索条件</h5><p>IN关键字使用户可以与列表中的任意值匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 课程编号</span><br><span class="line">from 课程表</span><br><span class="line">where 课程编号 in (&#x27;3&#x27;,&#x27;4&#x27;)</span><br></pre></td></tr></table></figure>
<h5 id="搜索条件中的字符匹配符"><a href="#搜索条件中的字符匹配符" class="headerlink" title="搜索条件中的字符匹配符"></a>搜索条件中的字符匹配符</h5><p>LIKE搜索匹配指定模式字符串</p>
<p>通配符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% 替代0/多个字符</span><br><span class="line">_ 替代一个字符</span><br><span class="line">[] 代表指定范围内的单个字符，[]中可以是单个字符([acef])，也可以为范围([a-f])</span><br><span class="line">[^] 代表不在范围内的单个字符[^]中可以是单个字符([^acef])，也可以为范围([^a-f])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询出姓王的老师</span><br><span class="line">select 任课教师</span><br><span class="line">from 课程表</span><br><span class="line">where 任课教师 like &#x27;王%&#x27;</span><br></pre></td></tr></table></figure>
<h5 id="涉及空置的查询"><a href="#涉及空置的查询" class="headerlink" title="涉及空置的查询"></a>涉及空置的查询</h5><p>NULL在数据库中表示不确定的值</p>
<p>判断为空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列名 is (not) null</span><br></pre></td></tr></table></figure>
<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>对一组值执行计算，并返回单个值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SUM([distinct]&lt;列名&gt;)</span><br><span class="line">AVG([distinct]&lt;列名&gt;)</span><br><span class="line">MAX([distinct]&lt;列名&gt;)</span><br><span class="line">MIN([distinct]&lt;列名&gt;)</span><br><span class="line">COUNT (*)统计元组个数</span><br><span class="line">COUNT ([distinct]&lt;列名&gt;)统计本列列值个数</span><br><span class="line">除count外，其他函数均计算NULL</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 聚合函数 from 表名</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select sum (grade) as &#x27;总成绩&#x27;</span><br><span class="line">from stu</span><br></pre></td></tr></table></figure>
<h4 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h4><p>group by根据一个或多个列对结果进行分组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 年级,SUM(人数) as &#x27;总人数&#x27;，</span><br><span class="line">COUNIT(班级编号) as &#x27;班级总量&#x27;</span><br><span class="line">from 班级信息</span><br><span class="line">group by 年纪</span><br></pre></td></tr></table></figure>
<p>having通常与group by子句一起使用。</p>
<p>后跟查询条件</p>
<p>having子句可以包含聚合函数，where不可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 学号,SUM(成绩) as &#x27;总成绩&#x27;</span><br><span class="line">from 成绩表</span><br><span class="line">group by 学号</span><br><span class="line">having SUM(成绩)&lt;100</span><br></pre></td></tr></table></figure>
<h4 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h4><p>用于对指定结果进行排序，默认升序</p>
<p>降序排序可以用DESC关键字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看成绩表</span><br><span class="line">select *</span><br><span class="line">from 成绩表</span><br><span class="line">order by 成绩</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from 成绩表</span><br><span class="line">order by 成绩 desc</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/24/SQL-SERVER/image-20211130204224089.png" alt="image-20211130204224089" style="zoom:50%;"></p>
<h4 id="表连接"><a href="#表连接" class="headerlink" title="表连接"></a>表连接</h4><p>从多个相关表中查询数据</p>
<h5 id="内部连接"><a href="#内部连接" class="headerlink" title="内部连接"></a>内部连接</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select list from 表名1，表名2</span><br><span class="line">where 表1.列=表2.列</span><br><span class="line">或</span><br><span class="line">select list from 表1 [inner] join 表2</span><br><span class="line">on 表1.列=表2.列</span><br></pre></td></tr></table></figure>
<p>查询学生的学号，姓名，性别，以及所在的班级名称和年级</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 学生信息.姓名,学生信息.学号,学生信息.性别,班级信息.班级名称,班级信息.年级</span><br><span class="line">from 学生信息,班级信息</span><br><span class="line">where 学生信息.班级编号=班级信息.班级编号</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 学生信息.姓名,学号,性别,//偷懒写法</span><br><span class="line">班级信息.班级名称,年级</span><br><span class="line">from 学生信息.inner join 班级信息</span><br><span class="line">on 学生信息.班级编号=班级信息.班级编号</span><br></pre></td></tr></table></figure>
<p>内部连接只有共同匹配到的结果才会有输出</p>
<h5 id="外部连接"><a href="#外部连接" class="headerlink" title="外部连接"></a>外部连接</h5><p>外部连接会返回from子句中提到的至少一个表的所有行。</p>
<p>分为左外部连接、右外部链接和全外部连接</p>
<p>左外部连接对连接条件中左边的表不加限制，其余同理。</p>
<p>先写为左表，后写为右表。</p>
<p>left outer join，若左表的某行在右表没有找到匹配的行，则结果集中的右表的相对应的位置为null</p>
<p>right outer join</p>
<p>full outer join</p>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>用来表示where子句的条件</p>
<p>子查询用圆括号括起来</p>
<p>嵌套子查询与相关子查询</p>
<h5 id="嵌套子查询"><a href="#嵌套子查询" class="headerlink" title="嵌套子查询"></a>嵌套子查询</h5><p>一个子查询可以包含另一个查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--查询计算机系学生选修了哪些课程</span><br><span class="line">select *</span><br><span class="line">from sc</span><br><span class="line">where sno in</span><br><span class="line">(select sno</span><br><span class="line">from student</span><br><span class="line">where sdept=&#x27;计算机系&#x27;)</span><br></pre></td></tr></table></figure>
<p>where子句后条件要什么，子查询就查什么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select sno,grade</span><br><span class="line">from sc</span><br><span class="line">where cno=&#x27;c02&#x27;</span><br><span class="line">and grade &gt;</span><br><span class="line">(select AVG(grade)</span><br><span class="line">from sc</span><br><span class="line">where cno=&#x27;c02&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="相关子查询（单值子查询）"><a href="#相关子查询（单值子查询）" class="headerlink" title="相关子查询（单值子查询）"></a>相关子查询（单值子查询）</h5><p>这样的子查询只返回一个值，然后将一列值与查询返回的值进行比较</p>
<h5 id="在查询基础上创建新表"><a href="#在查询基础上创建新表" class="headerlink" title="在查询基础上创建新表"></a>在查询基础上创建新表</h5><p>使用select …into语句可以在查询的基础上创建新表。</p>
<p>语法为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select list</span><br><span class="line">into新表名</span><br><span class="line">from表名</span><br></pre></td></tr></table></figure>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><h5 id="使用Insert和values插入"><a href="#使用Insert和values插入" class="headerlink" title="使用Insert和values插入"></a>使用Insert和values插入</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert[into] 表名[列名]</span><br><span class="line">values(...)</span><br></pre></td></tr></table></figure>
<h5 id="使用insert和select插入行"><a href="#使用insert和select插入行" class="headerlink" title="使用insert和select插入行"></a>使用insert和select插入行</h5><p>使用select子句将一个表或多个表的值添加到另一个表中。</p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>update修改表中数据语法形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 列名=表达式</span><br><span class="line">where//加条件</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update 成绩表</span><br><span class="line">set 学号=&#x27;3&#x27;</span><br><span class="line">where 成绩=&#x27;95&#x27;</span><br><span class="line">and 课程编号 between &#x27;1002&#x27; and &#x27;1003&#x27;</span><br></pre></td></tr></table></figure>
<p>如果条件不统一，更改的值也不一样，则分开来写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update 成绩表</span><br><span class="line">set 成绩=&#x27;89&#x27;</span><br><span class="line">where 课程编号=&#x27;1001&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名</span><br><span class="line">where 选择条件</span><br></pre></td></tr></table></figure>
<p>(删除行)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">删除固定行</span><br><span class="line">delete top (20) percent from 表名//删除前20%</span><br><span class="line">delete top (20) percent from 表名//删除前20行</span><br></pre></td></tr></table></figure>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是基于某个查询结果的虚表。</p>
<p>标准视图、索引视图、分区视图。</p>
<h4 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h4><p>着重于特定数据</p>
<p>简化数据操作</p>
<p>自定义数据</p>
<p>导出和导入数据</p>
<p>跨服务器组合分区数据</p>
<h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view [数据库名 ] 视图名</span><br><span class="line">AS</span><br><span class="line">select_statement</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view View_班级信息</span><br><span class="line">as</span><br><span class="line">select *from 班级信息</span><br></pre></td></tr></table></figure>
<h4 id="修改视图名字"><a href="#修改视图名字" class="headerlink" title="修改视图名字"></a>修改视图名字</h4><p>sp_rename修改视图名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_rename &#x27;view_班级信息&#x27;,&#x27;view_班级信息2&#x27;</span><br></pre></td></tr></table></figure>
<p>对于表的操作，视图同样可以使用。</p>
<h4 id="管理视图"><a href="#管理视图" class="headerlink" title="管理视图"></a>管理视图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inbseret into view_学生信息</span><br><span class="line">values(&#x27;7&#x27;,&#x27;13&#x27;,&#x27;aa&#x27;,&#x27;nv&#x27;,&#x27;beijing&#x27;)</span><br></pre></td></tr></table></figure>
<p>视图信息更改，原表信息也会更改。</p>
<p>alter既能修改数据内容，修改数据结构。</p>
<h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view 视图名1,视图名2</span><br></pre></td></tr></table></figure>
<p>有条件删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from 视图名</span><br><span class="line">where 条件</span><br></pre></td></tr></table></figure>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>对数据库表中一个或多个列的值进行排序的结构。用来定位。</p>
<p>作用</p>
<p>加快数据检索；保持数据一致性；实现表与表之间参照完整性。</p>
<h5 id="选择创建索引的数据列"><a href="#选择创建索引的数据列" class="headerlink" title="选择创建索引的数据列"></a>选择创建索引的数据列</h5><p>定义有主键和外键的列；在指定范围中快速或频繁查询的列；连接中频繁使用的列；需要按排序顺序快速或频繁检索的列</p>
<h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>聚集索引：</p>
<p>索引的顺序决定了表中行的存储顺序，因此每个表中只能有一个聚集索引。</p>
<p>非聚集索引：</p>
<p>索引中的逻辑顺序并不等同与表中行的物理顺序。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是作为单个逻辑单元执行的一系列操作。不可分割。</p>
<p>四大特性：</p>
<p>原子性；一致性；隔离性；永久性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin transaction</span><br><span class="line">rollback transaction//恢复</span><br><span class="line">commit transaction//提交</span><br></pre></td></tr></table></figure>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="系统存储过程"><a href="#系统存储过程" class="headerlink" title="系统存储过程"></a>系统存储过程</h3><h3 id><a href="#" class="headerlink" title></a><img src="/2021/11/24/SQL-SERVER/image-20211208074620892.png" alt="image-20211208074620892"></h3><p>exec执行</p>
<p>用户自定义存储过程</p>
<p>参数有输入和输出参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create proc[edure] 存储过程名</span><br><span class="line">@参数一 数据类型=默认值 output</span><br><span class="line">AS</span><br><span class="line">SQL语句</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>
<p>参数可以设置默认值</p>
<p><img src="/2021/11/24/SQL-SERVER/image-20211208081112318.png" alt="image-20211208081112318"></p>
<p><img src="/2021/11/24/SQL-SERVER/image-20211208102301639.png" alt="image-20211208102301639"></p>
<h2 id="数据库设计基础"><a href="#数据库设计基础" class="headerlink" title="数据库设计基础"></a>数据库设计基础</h2><h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><p><img src="/2021/11/24/SQL-SERVER/image-20211208081720924.png" alt="image-20211208081720924"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/21/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/21/MySQL/" class="post-title-link" itemprop="url">MySQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-21 10:52:34 / Modified: 23:57:28" itemprop="dateCreated datePublished" datetime="2021-11-21T10:52:34+08:00">2021-11-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><h3 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h3><p>DB :database数据库</p>
<p>DBMS :Database Management System数据库管理系统</p>
<p>SQL :Structure Query Language专门用来与数据库通信的语言</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型由数据结构，数据操作和完整性约束构成。</p>
<h4 id="常见的数据模型"><a href="#常见的数据模型" class="headerlink" title="常见的数据模型"></a>常见的数据模型</h4><p>层次模型：用树形结构表示实体类型及实体间的联系的数据模型称为层次模型。</p>
<p><img src="/2021/11/21/MySQL/0251C980E3935BE8B502DB12BF4E28AA.jpg" alt="img" style="zoom: 33%;"></p>
<p>网状模型：用有向图结构表示实体类型以及实体间联系的数据模型称为网状模型。用网状模型编写应用程序及其复杂，数据的独立性较差。</p>
<p><img src="/2021/11/21/MySQL/814994B32C68AB40E0CCAD787BDBAE45.jpg" alt="img" style="zoom:50%;"></p>
<p>关系模型：以二维表来描述数据。</p>
<p><img src="/2021/11/21/MySQL/52A9A70E94E089277537417FF9770065.jpg" alt="img" style="zoom: 33%;"></p>
<p><img src="/2021/11/21/MySQL/520D0BD20FC882EBF07D1707CA7EC95B.jpg" alt="img" style="zoom: 33%;"></p>
<h4 id="关系数据库的规范化"><a href="#关系数据库的规范化" class="headerlink" title="关系数据库的规范化"></a>关系数据库的规范化</h4><p>根据满足规范的条件不同，可以分为五个等级：第一范式（1NF）、…，第五范式（5NF）。一般情况下，只要把数据规范到第三范式标准就可以。</p>
<h5 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h5><p>在第一范式中，数据表的每一行只包含一个实体的信息，并且每一行的每一列只能存放实体的一个属性。</p>
<p><img src="/2021/11/21/MySQL/4223C3CA9AD1A5D76E8D9C0FD3C5020D.jpg" alt="img" style="zoom: 25%;"></p>
<h5 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h5><p>第二范式应该首先满足第一范式，第二范式要求数据库表中的每个实体必须可以被唯一的区分。为了实现区分各行记录，通常需要为表设置一个区分列，用以存储各个实体的唯一标识。</p>
<h5 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h5><p>第三范式要求一个关系表中不包含已在其他表中已包含的非关键字信息。</p>
<h4 id="关系数据库的设计原则"><a href="#关系数据库的设计原则" class="headerlink" title="关系数据库的设计原则"></a>关系数据库的设计原则</h4><p>○数据库内数据文件的数据组织应该获得最大限度的共享、最小的冗余度，消除数据及数据依赖关系中的冗余部分，是依赖于同一个数据模型的数据达到有效的分离。</p>
<p>○保证输入、修改数据时数据的一致性与正确性。</p>
<p>○保证数据与使用数据的应用程序之间的高度独立性。</p>
<h4 id="实体与关系"><a href="#实体与关系" class="headerlink" title="实体与关系"></a>实体与关系</h4><p>一对一关系</p>
<p>一对多关系</p>
<p>多对多关系</p>
<h3 id="数据库的体系结构"><a href="#数据库的体系结构" class="headerlink" title="数据库的体系结构"></a>数据库的体系结构</h3><h4 id="数据库三级模式结构"><a href="#数据库三级模式结构" class="headerlink" title="数据库三级模式结构"></a>数据库三级模式结构</h4><h5 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h5><p>也称逻辑模式或概念模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据拼图。一个数据库只有一个模式，模式处于三级结构中的中间层。</p>
<h5 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h5><p>也称用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。外模式是模式的子集，一个数据库可以有多个外模式。</p>
<p>外模式是保证数据安全性的一个有力措施。</p>
<h5 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h5><p>也称存储模式，一个数据库只有一个内模式。他是数据结构和存储方式的描述，是数据在数据库内部的表示方式。</p>
<h4 id="三级模式之间的映射"><a href="#三级模式之间的映射" class="headerlink" title="三级模式之间的映射"></a>三级模式之间的映射</h4><p>数据库管理系统在三级模式之间提供了两层映射，分别为</p>
<h5 id="外模式-模式映射"><a href="#外模式-模式映射" class="headerlink" title="外模式/模式映射"></a>外模式/模式映射</h5><p>对于同一个模式可以由多个外模式。对于每一个外模式，数据库系统都有一个外模式/模式映射。当模式改变时，由数据库管理员作出改变，保证数据与程序的逻辑独立性。</p>
<h5 id="模式-内模式映射"><a href="#模式-内模式映射" class="headerlink" title="模式/内模式映射"></a>模式/内模式映射</h5><p>唯一，定义了数据库的全局逻辑结构与存储之间的对应关系。当数据库的存储结构改变时，有数据库管理员对其作出改变。保证数据与程序的物理独立性。</p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">计算机组成原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-15 01:18:45" itemprop="dateCreated datePublished" datetime="2021-11-15T01:18:45+08:00">2021-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-19 20:18:31" itemprop="dateModified" datetime="2021-12-19T20:18:31+08:00">2021-12-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h2><p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7E98C321CA302366D429FA58F7F0F1B8.jpg" alt="img" style="zoom: 25%;"></p>
<h3 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h3><h4 id="冯诺依曼计算机的特点"><a href="#冯诺依曼计算机的特点" class="headerlink" title="冯诺依曼计算机的特点"></a>冯诺依曼计算机的特点</h4><p>（1）计算机由运算器，存储器，控制器，输入设备，输出设备五大部件组成。</p>
<p>（2）指令和数据以同等地位存放于存储器内，可按地址访问。</p>
<p>（3）指令和数据均用二进制数表示。</p>
<p>（4）指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置。</p>
<p>（5）指令在存储器内顺序存放。</p>
<p>（6）机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成。</p>
<h4 id="计算机的硬件框图"><a href="#计算机的硬件框图" class="headerlink" title="计算机的硬件框图"></a>计算机的硬件框图</h4><p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/94750150D2C1C873C26D2D9976705CDC.jpg" alt="img" style="zoom: 25%;"></p>
<p>通常把运算器与控制器统称为中央处理器，即CPU。把输入/输出设备成为I/O设备，也可称为外部设备。</p>
<p>CPU与主存储器合起来称为主存。</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/997ACEF4162CFC523F026283A2A12F41.jpg" alt="img" style="zoom:25%;"></p>
<p>控制元（CU）用来解释存储器中的指令，并发出各种操作命令来执行指令。</p>
<h3 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h3><p>机器字长；</p>
<p>存储容量：MAR位数反映的存储单元的个数，MDR的位数反映了存储字长；</p>
<p>运算速度：MIPS(百万条指令每秒)，CPI(执行一条指令所需的时钟周期)；</p>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p>指令字长=存储字长=机器字长（三者可以相等也可以不等）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">机器字长：CPU一次能处理的二进制数据的最大位数。通常与CPU内寄存器的位数有关。栗子：windows 64位/32位，这里的64位和32位指的就是该操作系统的机器字长。</span><br><span class="line">存储字长指一个存储单元可存放的二进制代码的位数，即存储器中的MDR的位数。</span><br><span class="line">指令字长是计算机指令字的位数，指令字是指用二进制表示的指令，</span><br><span class="line">数据字长指的是计算机数据字的位数，数据字是指用二进制表示的数据</span><br></pre></td></tr></table></figure>
<p>用以指定待执行指令所在地址的是程序计数器</p>
<p>磁盘驱动器具有输入及输出功能</p>
<p>完整的计算机系统应该包括配套的硬件设备和软件系统</p>
<p>计算机与日常使用的袖珍计算器的本质区别在于自动化程度的高低。</p>
<p>有些计算机将一部分软件永恒地存于只读存储器中，称为固件</p>
<p>计算机系统软件包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">标准程序库，如监控程序，用于监视计算机工作</span><br><span class="line">服务型程序，如连接、编辑、调试、诊断</span><br><span class="line">语言处理程序，如编译程序、汇编程序、解释程序，将各种语言转换成机器语言</span><br><span class="line">操作系统，用来控制和管理计算机</span><br><span class="line">数据库管理系统</span><br><span class="line">各种计算机网络软件</span><br></pre></td></tr></table></figure>
<p>存储元件（又称存储基元、存储元）用来存放一位二进制信息。存储单元由若干个存储元件组成，能存放多位二进制信息。每个存储单元中二进制代码的组合即为存储字，它可代表数值、指令、地址或逻辑。每个存储单元中二进制代码的位数就是存储字长。</p>
<h2 id="计算机系统量化分析基础"><a href="#计算机系统量化分析基础" class="headerlink" title="计算机系统量化分析基础"></a>计算机系统量化分析基础</h2><h3 id="计算机体系结构的概念"><a href="#计算机体系结构的概念" class="headerlink" title="计算机体系结构的概念"></a>计算机体系结构的概念</h3><h4 id="计算机体系结构概念的演变"><a href="#计算机体系结构概念的演变" class="headerlink" title="计算机体系结构概念的演变"></a>计算机体系结构概念的演变</h4><p>阿姆道尔首次明确计算机体系结构是程序员所看到的计算机的属性，即概念性结构与功能特性。</p>
<p>对于通用寄存器型机器，这些属性主要是指：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（1）数据表示：硬件能直接辨认和处理的数据类型</span><br><span class="line">（2）寻址规则：最小寻址单元、寻址方式及其表示</span><br><span class="line">（3）寄存器定义：寄存器的定义、数量和使用方式</span><br><span class="line">（4）指令系统：机器指令的操作类型和格式、指令间的排序和控制机构等</span><br><span class="line">（5）中断系统：中断的类型和中断响应硬件的功能等</span><br><span class="line">（6）机器工作状态的定义和切换：如管态和目态等</span><br><span class="line">（7）存储系统：程序员可用的最大存储容量</span><br><span class="line">（8）信息保护：信息保护方式和硬件的支持</span><br><span class="line">（9）I/O结构：I/O寻址方式、数据传送的方式等</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="计算机体系结构、组成和实现"><a href="#计算机体系结构、组成和实现" class="headerlink" title="计算机体系结构、组成和实现"></a>计算机体系结构、组成和实现</h4><p>体系结构包括以下三个方面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）计算机指令系统</span><br><span class="line">（2）计算机组成</span><br><span class="line">（3）计算机硬件实现</span><br></pre></td></tr></table></figure>
<p>系列机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种指令集结构可以有多种组成。同样，一种组成可以有多种物理实现。系列机就是指在一个厂家生产的具有相同的指令集结构，但具有不同组成和实现的一系列不同型号的机器。</span><br></pre></td></tr></table></figure>
<p>兼容性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">向上(下)兼容指的是按某档机器编制的程序，不加修改的就能运行于比它高(低)档的机器</span><br><span class="line">向前(后)兼容指的是按某个时期投入市场的某种型号机器编制的程序，不加修改地就能运行于在它之前(后)投入市场的机器</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214131042867.png" alt="image-20211214131042867" style="zoom: 50%;"></p>
<h3 id="计算机体系结构的发展"><a href="#计算机体系结构的发展" class="headerlink" title="计算机体系结构的发展"></a>计算机体系结构的发展</h3><p>并行性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机系统在同一时刻或者同一时间间隔内进行多种运算或操作。</span><br></pre></td></tr></table></figure>
<p>从执行程序的角度来看，并行性等级从低到高可分为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">指令内部并行：单条指令中各微操作之间的并行。</span><br><span class="line">指令级并行：并行执行两条或两条以上的指令。</span><br><span class="line">线程级并行：并行执行两个或两个以上的线程。</span><br><span class="line">      通常是以一个进程内派生的多个线程为调度单位。</span><br><span class="line">任务级或过程级并行：并行执行两个或两个以上的过程或任务（程序段）， 以子程序或进程为调度单元。</span><br><span class="line">作业或程序级并行：并行执行两个或两个以上的作业或程序。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从处理数据的角度来看，并行等级从低到高可分为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">字串位串：每次只对一个字的一位进行处理。</span><br><span class="line">     最基本的串行处理方式，不存在并行性。</span><br><span class="line">字串位并：同时对一个字的全部位进行处理，不</span><br><span class="line">       同字之间是串行的。</span><br><span class="line">   开始出现并行性。</span><br><span class="line">字并位串：同时对许多字的同一位（称为位片）</span><br><span class="line">       进行处理。</span><br><span class="line">    具有较高的并行性。</span><br><span class="line">全并行：同时对许多字的全部位或部分位进行处理。</span><br><span class="line">   最高一级的并行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按照指令和数据的关系，把计算机系统的结构分为4类。Flynn分类法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">单指令流单数据流SISD</span><br><span class="line">（Single Instruction stream Single Data stream）</span><br><span class="line">单指令流多数据流SIMD</span><br><span class="line">（Single Instruction stream Multiple Data stream）</span><br><span class="line">多指令流单数据流MISD</span><br><span class="line">（Multiple Instruction stream Single Data stream）</span><br><span class="line">多指令流多数据流MIMD</span><br><span class="line">（Multiple Instruction stream Multiple Data stream）</span><br></pre></td></tr></table></figure>
<p>提高并行性的技术途径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）时间重叠</span><br><span class="line">      引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度。</span><br><span class="line">（2）资源重复</span><br><span class="line">      引入空间因素，以数量取胜。通过重复设置硬件资源，大幅度地提高计算机系统的性能。</span><br><span class="line">（3）资源共享</span><br><span class="line">    这是一种软件方法，它使多个任务按一定时间顺序轮流使用 同一套硬件设备。    </span><br></pre></td></tr></table></figure>
<p>耦合度  反映多机系统中各机器之间物理连接的紧密程度和交互作用能力的强弱。</p>
<p>量化设计的基本原则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1．大概率事件优先原则</span><br><span class="line">追求全局的最优结果</span><br><span class="line"></span><br><span class="line">2．Amdahl定律</span><br><span class="line">系统性能加速比，受限于该部件在系统中所占的重要性</span><br><span class="line">可以定量计算</span><br><span class="line"></span><br><span class="line">3．程序的局部性原理</span><br><span class="line">程序执行时所访问存储器在时-空上是相对地簇聚</span><br><span class="line">这种簇聚包括指令和数据两部分</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具有高性能价格比的计算机系统是一个带宽平衡的系统，而不是看它使用的某些部件的性能</p>
<p>CPU性能公式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">执行一个程序所需的CPU时间</span><br><span class="line">   CPU时间 = 执行程序所需的时钟周期数×时钟周期时间</span><br><span class="line">   其中：时钟周期时间是系统时钟频率的倒数。</span><br><span class="line">每条指令执行的平均时钟周期数CPI</span><br><span class="line">   CPI = 执行程序所需的时钟周期数／IC</span><br><span class="line">   IC：所执行的指令条数</span><br><span class="line">程序执行的CPU时间可以写成</span><br><span class="line">   CPU时间 = IC ×CPI ×时钟周期时间 </span><br><span class="line">   时钟周期时间：取决于硬件实现技术和计算机组成</span><br><span class="line">   CPI：取决于计算机组成和指令系统的结构；</span><br><span class="line">   IC：取决于指令系统的结构和编译技术</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214135037288.png" alt="image-20211214135037288" style="zoom:67%;"></p>
<h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><h3 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h3><p>总线是连接多个部件的信息传输线，是各部件共享的传输介质。在某一时刻，只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接受相同的信息。</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214142344175.png" alt="image-20211214142344175" style="zoom: 50%;"></p>
<p>M总线：存储总线</p>
<p>I/O总线：输入输出总线</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214142357607.png" alt="image-20211214142357607" style="zoom:50%;"></p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214142444806.png" alt="image-20211214142444806" style="zoom:50%;"></p>
<h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><h4 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h4><p>芯片内部 的总线</p>
<h4 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h4><p>计算机各部件之间 的信息传输线</p>
<h5 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用来传输各功能部件之间的数据信息</span><br><span class="line">双向  与机器字长、存储字长有关</span><br></pre></td></tr></table></figure>
<h5 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用来指出数据总线上的源数据或目的数据在主存单元的地址或I/O设备的地址。</span><br><span class="line">单向  与存储地址、 I/O地址有关</span><br></pre></td></tr></table></figure>
<h5 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发出各种控制信号的传输线。</span><br><span class="line">中断请求，总线请求，存储器读，存储器写，总线允许，中断确认等</span><br></pre></td></tr></table></figure>
<h4 id="通信总线"><a href="#通信总线" class="headerlink" title="通信总线"></a>通信总线</h4><p> 用于 计算机系统之间 或 计算机系统与其他系统（如控制仪表、移动通信等）之间的通信</p>
<p>有串行通信和并行通信两种。</p>
<h3 id="总线特性及性能指标"><a href="#总线特性及性能指标" class="headerlink" title="总线特性及性能指标"></a>总线特性及性能指标</h3><h4 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h4><p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214143223473.png" alt="image-20211214143223473" style="zoom:50%;"></p>
<h4 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h4><p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214143356321.png" alt="image-20211214143356321" style="zoom: 50%;"></p>
<h3 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h3><p>单总线结构</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214143726811.png" alt="image-20211214143726811" style="zoom:50%;"></p>
<p>双总线结构</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214143750521.png" alt="image-20211214143750521" style="zoom:50%;"></p>
<p>三总线结构</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214143816307.png" alt="image-20211214143816307" style="zoom:50%;"></p>
<p>主存总线用于CPU与主存之间的传输；I/O总线供CPU与各类I/O设备之间传递信息；DMA总线用于高速I/O设备(磁盘，磁带等)与主存之间直接交换信息。</p>
<p>另一种三总线结构</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214144022838.png" alt="image-20211214144022838" style="zoom:50%;"></p>
<p>Cache可通过系统总线与主存传递信息；且I/O设备与主存之间的传输也不必通过CPU，还有一条扩展总线。</p>
<p>SCSI：小型计算机接口；MODEM：调制解调器</p>
<p>四总线结构</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214144314504.png" alt="image-20211214144314504" style="zoom:50%;"></p>
<p>高速总线上挂了一些告诉的I/O设备。</p>
<h3 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h3><h4 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h4><p>总线上所连接的各类设备，按其对总线有无控制功能可分为主设备（模块）和从设备（模块）两种。</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214144718951.png" alt="image-20211214144718951" style="zoom:50%;"></p>
<p>集中式判优控制将控制逻辑集中在一处，如CPU；后者将控制逻辑分散在与总线连接的各个部件或设备上。</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214145237060.png" alt="image-20211214145237060" style="zoom:50%;"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特点：只需要很少几根线就能按一定优先次序实现总线控制，并且很容易扩展设备，但对电路故障很敏感，且优先级别低的设备很难获得请求</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214145747620.png" alt="image-20211214145747620" style="zoom:50%;"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对电路故障不如链式查询方法敏感，但增加了控制线（设备地址)数,控制也较复杂。</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214145903975.png" alt="image-20211214145903975" style="zoom:50%;"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">响应速度快，优先次序控制灵活，但控制线数量多，总线控制更复杂。</span><br></pre></td></tr></table></figure>
<h4 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h4><p>目的：解决通信双方 协调配合 问题</p>
<p>总线传输周期（一次总线操作的时间）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">申请分配阶段 主模块申请，总线仲裁决定</span><br><span class="line">寻址阶段    模块向从模块 给出地址 和 命令</span><br><span class="line">传数阶段    主模块和从模块 交换数据</span><br><span class="line">结束阶段    主模块 撤消有关信息 </span><br></pre></td></tr></table></figure>
<p>总线通信的四种方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">同步通信 由统一时标 控制数据传送</span><br><span class="line">异步通信 采用 应答方式 ，没有公共时钟标准</span><br><span class="line">半同步通信 同步，异步结合</span><br><span class="line">分离式通信 充分挖掘系统总线每个瞬间的潜力</span><br></pre></td></tr></table></figure>
<p>同步式</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214150834077.png" alt="image-20211214150834077" style="zoom:50%;"></p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214150845552.png" alt="image-20211214150845552" style="zoom:50%;"></p>
<p>异步</p>
<p>应答方式又分为三种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不互锁方式：</span><br><span class="line">主模块发出请求后，不必等待接到从模块的回答信号，而是经过一段时间，确认从模块已收到请求信号后，便撤销其请求信号；从模块接到请求信号后，在条件允许时发出回答信号，并且经过一段时间（这段时间对不同设备不同）确认主模块已收到回答信号后，自动撤销回答信号。eg:CPU向主存写信息</span><br><span class="line">半互锁方式：</span><br><span class="line">主模块发出请求后，不许接到从模块的回答后再撤销；而从模块则不必，一方互锁，一方不互锁</span><br><span class="line">全互锁方式：双方互锁</span><br></pre></td></tr></table></figure>
<p>异步串行通信的数据传送速率用波特率来衡量。波特率是指单位时间内传送二进制数据的位数，单位用bps(位/s)，记作波特。</p>
<p>同步传送速度高于异步传送。</p>
<p>半同步</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同步   发送方 用系统 时钟前沿 发信号，接收方 用系统 时钟后沿 判断、识别</span><br><span class="line">异步   允许不同速度的模块和谐工作，增加一条  “等待”响应信号</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214152257639.png" alt="image-20211214152257639" style="zoom:50%;"></p>
<p>适用于系统工作速度不高但又包含了由许多工作速度差异较大的各类设备组成的简单系统。半同步通信比异步通信简单，可靠性高。缺点是对系统时钟频率不能要求太高，故从整体看，系统工作速度还不是很高。</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211214152647243.png" alt="image-20211214152647243" style="zoom:50%;"></p>
<p>分离式通信</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个总线传输周期</span><br><span class="line">子周期1 主模块 申请 占用总线，使用完后即 放弃总线 的使用权</span><br><span class="line">子周期2 从模块 申请 占用总线，将各种信息送至总线上</span><br></pre></td></tr></table></figure>
<p>特点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 各模块有权申请占用总线</span><br><span class="line">2. 采用同步方式通信，不等对方回答</span><br><span class="line">3. 各模块准备数据时，不占用总线</span><br><span class="line">4. 总线被占用时，无空闲</span><br><span class="line">充分提高了总线的有效占用</span><br></pre></td></tr></table></figure>
<h3 id="附加-1"><a href="#附加-1" class="headerlink" title="附加"></a>附加</h3><p>影响总线带宽的因素：总线宽度，传输距离，总线发送和接受电路工作频率的限制以及数据传输形式。</p>
<p>PCI总线是一个与处理器时钟频率无关的告诉外部总线。</p>
<p>AGP总线是显卡专用的局部总线。</p>
<p>计算机之间的远距离通信除了直接由网卡经网线传输外，还可用RS-232总线通过载波电话线传输。</p>
<p>总线管理主要包括判优控制和通信控制。</p>
<p>在高档PC机中，系统总线主要连接CPU和存储器；PCI总线主要连接多媒体卡，高速局域网适配器，高性能图形版等高速部件；ISA或EISA总线连接图文传真机、调制解调器，打印机等低速部件。系统总线和PCI通过PCI桥路相连，PCI总线又通过标准总线控制器与IS和EIS总线相连。     </p>
<h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h3 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h3><p>每一趟机器语言的语句称为机器指令，又将全部机器指令的集合称为机器的指令系统。</p>
<p>指令由地址码和操作码构成。操作码可固定可不固定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">扩展操作码技术：操作码的位数随地址数的减少而增加</span><br></pre></td></tr></table></figure>
<p>四地址指令：<img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211215114537872.png" alt="image-20211215114537872" style="zoom:50%;"></p>
<p>需进行四次访存，取指令一次，取两个操作数两次，存放结果一次</p>
<p>三地址指令：<img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211215114740842.png" alt="image-20211215114740842" style="zoom:50%;"></p>
<p>下条指令地址隐藏在程序计数器PC中，同样也需要进行四次访存。</p>
<p>二地址指令：<img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211215114937575.png" alt="image-20211215114937575" style="zoom:50%;"></p>
<p>一地址指令：<img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211215115213639.png" alt="image-20211215115213639" style="zoom:50%;"></p>
<p>零地址指令：无地址码</p>
<p>早起计算机指令字长、机器字长和存储字长均相等。</p>
<h3 id="操作数类型和操作类型"><a href="#操作数类型和操作类型" class="headerlink" title="操作数类型和操作类型"></a>操作数类型和操作类型</h3><p>操作类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数据传送；</span><br><span class="line">算术逻辑操作；</span><br><span class="line">移位；</span><br><span class="line">转移；</span><br><span class="line">输入输出；</span><br><span class="line">其他：等待，停机，空等指令</span><br></pre></td></tr></table></figure>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>分为数据寻址与指令寻址</p>
<h4 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h4><p>分为顺序寻址和跳跃寻址。</p>
<h4 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h4><p>指令地址码字段称为形式地址，记为A；而操作数的真实地址称为有效地址，记为EA。</p>
<p><strong>立即寻址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">形式地址A就是操作数</span><br><span class="line">指令执行阶段不访存</span><br><span class="line">A 的位数限制了立即数的范围</span><br></pre></td></tr></table></figure>
<p><strong>直接寻址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A=EA</span><br><span class="line">执行阶段访问一次存储器</span><br><span class="line">A 的位数决定了该指令操作数的寻址范围</span><br><span class="line">操作数的地址不易修改（必须修改A）</span><br></pre></td></tr></table></figure>
<p><strong>隐含寻址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数地址隐含在操作码中</span><br></pre></td></tr></table></figure>
<p><strong>间接寻址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有效地址由形式地址间接提供</span><br><span class="line">会多次访存</span><br><span class="line">可扩大寻址范围，便于编制程序</span><br></pre></td></tr></table></figure>
<p><strong>寄存器寻址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EA=R_i</span><br><span class="line">有效地址即为寄存器编号</span><br><span class="line">执行阶段不访存，只访问寄存器，执行速度快</span><br><span class="line">寄存器个数有限，可缩短指令字长</span><br></pre></td></tr></table></figure>
<p><strong>寄存器间接寻址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EA=(R_i)有效地址在寄存器中</span><br><span class="line">操作数在存储器中，执行阶段访存</span><br></pre></td></tr></table></figure>
<p><strong>基址寻址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）采用专用寄存器作基址寄存器</span><br><span class="line">EA = ( BR ) + A </span><br><span class="line">BR 为基址寄存器</span><br><span class="line">可扩大寻址范围，有利于多道程序，BR内容由操作系统或管理程序确定，在程序的执行过程中BR内容不变，形式地址A可变</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(2) 采用通用寄存器作基址寄存器 R0 作基址寄存器</span><br><span class="line">由用户指定哪个通用寄存器作为基址寄存器</span><br><span class="line">基址寄存器的内容由操作系统确定</span><br><span class="line">在程序的执行过程中 R0  内容不变，形式地址 A 可变</span><br></pre></td></tr></table></figure>
<p><strong>变址寻址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EA = ( IX ) +A IX 为变址寄存器（专用）</span><br><span class="line">通用寄存器也可以作为变址寄存器</span><br><span class="line">可扩大寻址范围，IX的内容由用户给定，在程序的执行过程中IX可变，形式地址A不变，便于处理数组问题</span><br></pre></td></tr></table></figure>
<p><strong>相对寻址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EA = ( PC ) + A</span><br><span class="line">A 是相对于当前指令的位移量</span><br><span class="line">A的位数决定操作数的寻址范围，程序浮动，广泛用于转移指令</span><br></pre></td></tr></table></figure>
<p><strong>堆栈寻址</strong></p>
<p>多个寄存器可构成硬堆栈，指定的存储空间构成软堆栈。</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211215125935774.png" alt="image-20211215125935774" style="zoom:50%;"></p>
<h3 id="指令系统结构的分类"><a href="#指令系统结构的分类" class="headerlink" title="指令系统结构的分类"></a>指令系统结构的分类</h3><p>CPU中用来存储操作数的存储单元主要有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">堆栈，累加器，一组寄存器</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211215131719796.png" alt="image-20211215131719796" style="zoom:50%;"></p>
<p>寄存器-寄存器型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：指令字长固定，指令结构简洁，是一种简单的代码生成模型，各种指令的执行时钟周期数相近。</span><br><span class="line">缺点：与指令中含存储器操作数的指令系统结构相比，指令条数多，目标代码不够紧凑，因而程序占用的空间比较大。</span><br></pre></td></tr></table></figure>
<p>寄存器-存储器型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：可以在ALU指令中直接对存储器操作数进行引用，而不必先用load指令进行加载，容易对指令进行编码，目标代码比较紧凑。</span><br><span class="line">缺点：由于有一个操作数的内容将被破坏，所以指令中的两个操作数不对称。在一条指令中同时对寄存器操作数和存储器操作数进行编码，有可能限制指令所能够表示的寄存器个数。指令的执行时钟周期因操作数的来源（寄存器或存储器）的不同而差别比较大。</span><br></pre></td></tr></table></figure>
<p>存储器-存储器型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：目标代码最紧凑，不需要设置存储器来保存变量。</span><br><span class="line">缺点：指令字长变换很大，特别是3个操作数指令。而且每条指令完成的工作也差别很大。对存储器的频率访问会使存储器成为瓶颈。这种类型的指令系统现在已经不用了。</span><br></pre></td></tr></table></figure>
<h3 id="指令系统的设计和优化"><a href="#指令系统的设计和优化" class="headerlink" title="指令系统的设计和优化"></a>指令系统的设计和优化</h3><h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p>包括指令的功能设计和指令格式的设计</p>
<p>在确定哪些基本功能用硬件来实现时，主要考虑3个因素：速度，成本，灵活性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">硬件实现：速度快，成本高。灵活性差</span><br><span class="line">软件实现：速度慢，价格便宜，灵活性好</span><br></pre></td></tr></table></figure>
<p>对指令系统的基本要求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">完整性，规整性，正交性，高效率，兼容性</span><br><span class="line">完整性：在一个有限可用的存储空间内，对于任何可解的问题，编制计算程序时，指令系统所提供的指令足够使用。</span><br><span class="line">规整性：主要包括对称性和均匀性。</span><br><span class="line">正交性：在指令中各个不同含义的字段，如操作类型、数据类型、寻址方式字段等，在编码时应互不相关、相互独立。 </span><br><span class="line">高效率：指指令的执行速度快、使用频度高。</span><br><span class="line">兼容性：主要是要实现向后兼容，指令系统可以增加新指令，但不能删除指令或更改指令的功能。</span><br></pre></td></tr></table></figure>
<h4 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h4><p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211215133256789.png" alt="image-20211215133256789" style="zoom:50%;"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“调用者保存”（caller saving）方法：如果采用调用者保存策略，那么在一个调用者调用别的过程时，必须保存调用者所要保存的寄存器，以备调用结束返回后，能够再次访问调用者。</span><br><span class="line">“被调用者保存”（callee saving）方法：如果采用被调用者保存策略，那么被调用的过程必须保存它要用的寄存器，保证不会破坏过程调用者的程序执行环境，并在过程调用结束返回时，恢复这些寄存器的内容。</span><br></pre></td></tr></table></figure>
<h4 id="指令操作码的优化"><a href="#指令操作码的优化" class="headerlink" title="指令操作码的优化"></a>指令操作码的优化</h4><p>等长扩展码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">便于分级译码</span><br></pre></td></tr></table></figure>
<p>定长操作码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">固定长度的操作码：所有指令的操作码都是同一的长度。</span><br><span class="line">保证操作码的译码速度、减少译码的复杂度。</span><br><span class="line">以程序的存储空间为代价来换取硬件实现上的好处。</span><br></pre></td></tr></table></figure>
<h3 id="指令系统的发展和改进"><a href="#指令系统的发展和改进" class="headerlink" title="指令系统的发展和改进"></a>指令系统的发展和改进</h3><p>一个方向是强化指令功能，实现软件功能向硬件功能转移，基于这种指令集结构而设计实现的计算机系统称为复杂指令集计算机（CISC）。<br>八十年代发展起来的精简指令集计算机（RISC），其目的是尽可能地降低指令集结构的复杂性，以达到简化实现，提高性能的目的。</p>
<p>面向目标程序增强指令功能<br>提高运算型指令功能；<br>提高传送指令功能；<br>增加程序控制指令功能。<br>面向高级语言和编译程序改进指令系统<br>增加对高级语言和编译系统支持的指令功能；<br>高级语言计算机指令系统。</p>
<h3 id="附加-2"><a href="#附加-2" class="headerlink" title="附加"></a>附加</h3><p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/054D743EE7F6A66C0E88E9C8CCDD883D.jpg" alt="img" style="zoom: 25%;"></p>
<p>零操作数来自栈顶和次栈顶。</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/CDD93D766203697644D6DD8DCB3BBBCF.jpg" alt="img" style="zoom: 25%;"></p>
<p>寄存器间址有利于编制循坏程序。</p>
<p>在非立即寻址的一地址格式指令中，其中一个操作数通过指令的地址字段安排在寄存器或存储器中。</p>
<p>一个较完善的指令系统应该包括数据传送，算术逻辑运算，程序控制，输入输出，其他。</p>
<p>变址寻址只要用于处理数组程序；基址寻址支持多道程序的应用。</p>
<p>RR型指令，执行指令时不访问存储器。</p>
<p>RS型指令，执行指令时需访问存储器，且通过变址运算，时间最长。</p>
<h2 id="CPU设计与实现"><a href="#CPU设计与实现" class="headerlink" title="CPU设计与实现"></a>CPU设计与实现</h2><h3 id="CPU的结构"><a href="#CPU的结构" class="headerlink" title="CPU的结构"></a>CPU的结构</h3><h4 id="CPU的寄存器"><a href="#CPU的寄存器" class="headerlink" title="CPU的寄存器"></a>CPU的寄存器</h4><p>用户可见寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1) 通用寄存器</span><br><span class="line">存放操作数 可作 某种寻址方式所需的 专用寄存器</span><br><span class="line">(2) 数据寄存器</span><br><span class="line">存放操作数（满足各种数据类型） 两个寄存器拼接存放双倍字长数据</span><br><span class="line">(3) 地址寄存器</span><br><span class="line">存放地址，其位数应满足最大的地址范围 用于特殊的寻址方式    段基值    栈指针</span><br><span class="line">(4) 条件码寄存器 存放条件码，可作程序分支的依据 如 正、负、零、溢出、进位等</span><br></pre></td></tr></table></figure>
<p>控制寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其中 MAR、MDR、IR            用户不可见</span><br><span class="line">PC 用户可见</span><br></pre></td></tr></table></figure>
<p>状态寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSW寄存器 存放程序状态字</span><br></pre></td></tr></table></figure>
<h3 id="运算方法与ALU"><a href="#运算方法与ALU" class="headerlink" title="运算方法与ALU"></a>运算方法与ALU</h3><h4 id="算数移位运算"><a href="#算数移位运算" class="headerlink" title="算数移位运算"></a>算数移位运算</h4><p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211216135626230.png" alt="image-20211216135626230" style="zoom:50%;"></p>
<p>有符号数移位称为算数移位，无符号数移位称为逻辑移位。</p>
<p>单符号位判断溢出与双符号位判断溢出。</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211216142115187.png" alt="image-20211216142115187" style="zoom:50%;"></p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211216142130087.png" alt="image-20211216142130087" style="zoom:50%;"></p>
<h4 id="浮点四则运算"><a href="#浮点四则运算" class="headerlink" title="浮点四则运算"></a>浮点四则运算</h4><p>浮点加减法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对阶：求阶差，小阶向大阶对其</span><br><span class="line">尾数求和</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211216143446776.png" alt="image-20211216143446776" style="zoom:50%;"></p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211216143528988.png" alt="image-20211216143528988" style="zoom:50%;"></p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211216143806564.png" alt="image-20211216143806564" style="zoom:50%;"></p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211216144000786.png" alt="image-20211216144000786" style="zoom:50%;"></p>
<h3 id="多级时序系统"><a href="#多级时序系统" class="headerlink" title="多级时序系统"></a>多级时序系统</h3><h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><p>取出并执行一条指令所需的全部时间</p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211216144414073.png" alt="image-20211216144414073" style="zoom:50%;"></p>
<p>微指令分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">取指阶段：</span><br><span class="line">PC-&gt;MAR 1-&gt;R (MAR)-&gt;MDR MDR-&gt;IR OP(IR)-&gt;CU (PC)+1-&gt;PC</span><br><span class="line">间址周期：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211216145209138.png" alt="image-20211216145209138" style="zoom:50%;"></p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211216145229814.png" alt="image-20211216145229814" style="zoom:50%;"></p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211216145259482.png" alt="image-20211216145259482" style="zoom:50%;"></p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211216145315443.png" alt="image-20211216145315443" style="zoom:50%;"></p>
<p>在机器周期所含时钟周期数 相同 的前提下，<br>两机 平均指令执行速度之比  等于 两机主频之比</p>
<p>一个指令周期包含若干个机器周期</p>
<p>一个机器周期包含若干个时钟周期</p>
<h3 id="附加-3"><a href="#附加-3" class="headerlink" title="附加"></a>附加</h3><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>流水线特点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">流水过程由多个相关的子过程组成，这些子过程称为流水线的“级”或“段”。段的数目称为流水线的“深度”。</span><br><span class="line">每个子过程由专用的功能段实现。</span><br><span class="line">各功能段的时间应基本相等，通常为1个时钟周期（1拍）。</span><br><span class="line">流水线需要经过一定的通过时间才能稳定。</span><br><span class="line">流水技术适合于大量重复的时序过程。</span><br></pre></td></tr></table></figure>
<p>分类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单功能流水线和多功能流水线</span><br><span class="line">按流水线所完成的功能分类</span><br><span class="line">单功能流水线，是指只能完成一种固定功能的流水线。</span><br><span class="line">	例如：功能单元流水线</span><br><span class="line">多功能流水线，是指各段可以进行不同的连接，从而完成不同的功能。</span><br><span class="line">	例如：TI ASC多功能流水线</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">静态流水线和动态流水线</span><br><span class="line">按同一时间内流水段的连接方式划分</span><br><span class="line">静态流水线，是指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。</span><br><span class="line">	例如：TI ASC的流水线</span><br><span class="line">	适合于处理一串相同的运算操作</span><br><span class="line">动态流水线，是指在同一时间内，当某些段正在实现某种运算时，另一些段却在实现另一种运算，会使流水线的控制变得很复杂</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">部件级、处理机级及处理机间流水线 </span><br><span class="line">按流水的级别划分</span><br><span class="line">部件级流水线，又叫运算操作流水线，是把处理机的算术逻辑部件分段，使得各种数据类型的操作能够进行流水。</span><br><span class="line">处理机级流水线，又叫指令流水线，是把解释指令的过程按照流水方式处理。</span><br><span class="line">处理机间流水线，又叫宏流水线，是由两个以上的处理机串行地对同一数据流进行处理，每个处理机完成一项任务。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">标量流水处理机和向量流水处理机</span><br><span class="line">按照数据表示来进行分类</span><br><span class="line">标量流水处理机，是指处理机不具有向量数据表示，仅对标量数据进行流水处理。</span><br><span class="line">	例如：IBM 360/91，Amdahl 470V/6等 </span><br><span class="line">向量流水处理机，是指处理机具有向量数据表示，并通过向量指令对向量的各元素进行处理。</span><br><span class="line">	例如：TI ASC、STAR-100、CYBER-205、CRAY-1、YH-1等</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线性流水线和非线性流水线</span><br><span class="line">按照是否有反馈回路来进行分类</span><br><span class="line">线性流水线是指流水线的各段串行连接，没有反馈回路。</span><br><span class="line">非线性流水线是指流水线中除有串行连接的通路外，还有反馈回路。</span><br><span class="line">	存在流水线调度问题。</span><br><span class="line">	确定什么时候向流水线引进新的输入，从而使新输入的数据和先前操作的反馈数据在流水线中不产生冲突，此即所谓流水线调度问题。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="基本流水线"><a href="#基本流水线" class="headerlink" title="基本流水线"></a>基本流水线</h3><p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211219111100347.png" alt="image-20211219111100347"></p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211219111939127.png" alt="image-20211219111939127" style="zoom:67%;"></p>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211219111951893.png" alt="image-20211219111951893" style="zoom:67%;"></p>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>吞吐率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">吞吐率是指单位时间内流水线所完成的任务数或输出结果的数量。</span><br><span class="line">最大吞吐率TPmax是指流水线在达到稳定状态后所得到的吞吐率。</span><br><span class="line">设流水线由m段组成，完成n个任务的吞吐率称为实际吞吐率，记作TP。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">最大吞吐率取决于流水线中最慢一段所需的时间，该段成为流水线的瓶颈</span><br><span class="line">消除瓶颈的方法</span><br><span class="line">细分瓶颈段</span><br><span class="line">重复设置瓶颈段</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211219123308211.png" alt="image-20211219123308211" style="zoom: 50%;"></p>
<p>加速比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">流水线速度与等功能的非流水线速度之比</span><br></pre></td></tr></table></figure>
<p>效率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">流水线的设备利用率</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20211219123457264.png" alt="image-20211219123457264" style="zoom:50%;"></p>
<p>效率是实际加速比S与最大加速比m之比。</p>
<p>当△t0不变时，流水线的效率与吞吐率呈正比。为提高效率而采取的措施，也有助于提高吞吐率。</p>
<p>注</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">流水线并不能减少（而且一般是增加）单条指令的执行时间，但能够提高吞吐率</span><br><span class="line">增加流水线的深度可以提高流水线性能</span><br><span class="line">流水线深度受限于流水线的延迟和额外开销</span><br><span class="line">需要用高速锁存器作为流水线寄存器</span><br><span class="line">Earle锁存器</span><br><span class="line">指令之间存在的相关，产生了流水线的冲突，进而限制了流水线的性能</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="流水线冲突"><a href="#流水线冲突" class="headerlink" title="流水线冲突"></a>流水线冲突</h3><p>流水线冲突是指相邻或相近的两条指令因存在某种关联，后一条指令不能在原先指定的时钟周期开始执行。</p>
<p>三种不同类型的冲突</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结构冲突（Structural Hazard）：当指令在重叠执行过程中，硬件资源满足不了指令重叠执行的要求而发生的冲突。</span><br><span class="line">数据冲突（Data Hazard）：因一条指令需要用到前面指令的结果，而无法与产生结果的指令重叠执行时发生的冲突。</span><br><span class="line">控制冲突（Control Hazard）：当流水线遇到分支指令和其它会改变PC值的指令所引起的冲突。</span><br></pre></td></tr></table></figure>
<p>导致结构冲突的常见原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">功能部件不是全流水</span><br><span class="line">重复设置的资源数量不足</span><br></pre></td></tr></table></figure>
<p> 避免结构冲突的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所有功能单元完全流水化</span><br><span class="line">设置足够多的硬件资源</span><br><span class="line">但是，硬件代价很大！</span><br></pre></td></tr></table></figure>
<p>有些设计方案允许结构冲突存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">降低成本</span><br><span class="line">减少功能单元的延迟</span><br></pre></td></tr></table></figure>
<p>数据冲突</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">产生原因：当指令在流水线中重叠执行时，流水线有可能改变指令读/写操作数的顺序，使之不同于它们在非流水实现时的顺序，这将导致数据冲突。</span><br><span class="line">	消除方法：向流水线中插入暂停周期</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过定向技术减少数据冲突带来的暂停</span><br><span class="line">进一步推广：一个结果不仅可以从某一功能单元的输出定向到其自身的输入，而且还可以定向到其它功能单元的输入。	(举例)</span><br><span class="line">在MIPS中，任何流水寄存器到任何功能单元的输入都可能需要定向路径，将形成复杂的旁路网络。</span><br><span class="line">两条指令访问同一存储单元，也可能引起数据冲突，例如访问数据Cache失效时。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译调度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译器可以通过重新排列代码的顺序来消除这种暂停，这种技术就是“流水线调度”或“指令调度”</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令发射(Issue)：指令从流水线的译码段进入执行段的过程称为指令发射。</span><br><span class="line">检测数据冲突</span><br><span class="line">ID段可以检测所有数据冲突</span><br><span class="line">也可以在使用一个操作数的时钟周期的开始(EX和MEM段的开始)检测相关，并确定必需的定向</span><br><span class="line">流水线相关硬件可以检测到的各种冲突情况</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h2><p>记分牌的性能受限于以下几个方面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">程序代码中可开发的并行性，即是否存在可以并行执行的不相关的指令。</span><br><span class="line">记分牌的容量。</span><br><span class="line">记分牌的容量决定了流水线能在多大范围内寻找不相关指令。流水线中可以同时容纳的指令数量称为指令窗口。</span><br><span class="line">功能部件的数目和种类。</span><br><span class="line">功能部件的总数决定了结构冲突的严重程度。</span><br><span class="line">反相关和输出相关。</span><br><span class="line">它们引起计分牌中更多的WAR和WAW冲突 。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Tomasulo算法的优点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">分布式硬件冲突检测。</span><br><span class="line">利用寄存器换名，彻底消除WAW和WAR这两种名相关</span><br><span class="line">如果多个保留站等待同一个操作数，当操作数在CDB上广播时，他们可以同时获得所需的数据</span><br><span class="line">对于存储器访问，动态存储器地址判别技术可解决RAW冲突（取操作数时判断）、WAR和WAW冲突（存操作数时判断）。</span><br><span class="line">能够达到很高的性能。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>缺点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">高复杂性：需要大量硬件</span><br><span class="line">存在瓶颈：单个公共数据总线（CDB）引发竞争</span><br><span class="line">额外的CDB：在每个保留站上需要为每条CDB设置重复的硬件接口</span><br><span class="line">为了保证正确的异常行为，对指令的执行有一个限制：一旦有一条分支指令还没有执行完，其后的指令是不允许进入执行段</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">最简单的分支预测策略</span><br><span class="line">BPB也被称为BHT（Branch History Table，BHT）</span><br><span class="line">分支预测缓冲是一个小的存储器阵列</span><br><span class="line">每个单元最小可以只有1位，记录最近一次分支是否成功的信息</span><br><span class="line">预测位为1时，表示预测分支成功，并从目标位置开始取指令</span><br><span class="line">在预测错误时，要作废已经预取和分析的指令，恢复现场，并从另一条分支路径重新取指令。</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
