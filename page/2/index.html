<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/" class="post-title-link" itemprop="url">地址映射与共享</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-12 14:37:08 / Modified: 20:59:59" itemprop="dateCreated datePublished" datetime="2022-06-12T14:37:08+08:00">2022-06-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="地址映射与共享"><a href="#地址映射与共享" class="headerlink" title="地址映射与共享"></a>地址映射与共享</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ul>
<li>用 <code>Bochs</code> 调试工具跟踪 <code>Linux 0.11</code> 的地址翻译（地址映射）过程，了解 <code>IA-32</code> 和 <code>Linux 0.11</code> 的内存管理机制；</li>
<li>在 <code>Ubuntu</code> 上编写多进程的生产者-消费者程序，用共享内存做缓冲区；</li>
<li>在信号量实验的基础上，为 <code>Linux 0.11</code> 增加共享内存功能，并将生产者-消费者程序移植到 <code>Linux 0.11</code> 。</li>
</ul>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="创建test-c"><a href="#创建test-c" class="headerlink" title="创建test.c"></a>创建test.c</h3><p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612154248888.png" alt="image-20220612154248888"></p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612154259966.png" alt="image-20220612154259966"></p>
<h3 id="寻找物理地址"><a href="#寻找物理地址" class="headerlink" title="寻找物理地址"></a>寻找物理地址</h3><p>首先进入Linux-0.11目录内make编译系统，然后运行系统，编译运行test.c文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c</span><br><span class="line">./test</span><br></pre></td></tr></table></figure>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612154459443.png" alt="image-20220612154459443"></p>
<p>此时会进入在test.c内的while死循环，然后ctrl+c暂停bochs。<br>此时需要让Linux-0.11的test跳出死循环，所以需要找到逻辑地址ds:0X00003004对应的物理地址，将它的内容更改为0。<br>在终端中输入sreg，得到gdtr的基址值为0x00005cb8,ldtr为0x0068即0000 0000 0110 1000 b，可知索引为1101b即13，TI位为0，即GDT中的第13项为LDT的段描述符。</p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612162319691.png" alt="image-20220612162319691"></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xp /2w 0x00005cb8+13*8</span><br></pre></td></tr></table></figure>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612162954016.png" alt="image-20220612162954016"></p>
<p>可以得到LDT的基址为0x00fe92d0</p>
<p>ds段选择子为0x0017 =&gt; 0000 0000 0001 0111 b，可知索引为10b即2，TI位为1，即LDT中的第2项为ds的段描述符</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xp/2w 0x00fe92d0+2*8</span><br></pre></td></tr></table></figure>
<p>得到ds段描述符</p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612163210299.png" alt="image-20220612163210299"></p>
<p>可以知道ds的基址为0x10000000，所以0x3004对应的线性地址为0x10000000+0x3004=0x10003004</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xp /w 64*4</span><br></pre></td></tr></table></figure>
<p>获取页目录项</p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612164505087.png" alt="image-20220612164505087"></p>
<p>表所在的物理页框号为<code>0x00fa7</code>，即页表在物理内存为<code>0x00fa7000</code>处，从该位置开始查找<code>3</code>号页表项</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xp /w 0x00fa7000 + 3*4</span><br></pre></td></tr></table></figure>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612164837721.png" alt="image-20220612164837721"></p>
<p>线性地址<code>0x10003004</code>对应的物理页框号为<code>0x00fa6</code>，和页内偏移<code>0x004</code>接到一起，得到<code>0x00fa6004</code>，这就是变量i的物理地址</p>
<p>用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xp /w 0x00fa6004</span><br></pre></td></tr></table></figure>
<p>验证</p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612165035955.png" alt="image-20220612165035955"></p>
<p>修改物理地址，使其变量i为0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setpmem 0x00fa6004 4 0</span><br></pre></td></tr></table></figure>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612165143590.png" alt="image-20220612165143590"></p>
<p>输入c，可以看到，会在bochs中顺利退出</p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612165212346.png" alt="image-20220612165212346"></p>
<h3 id="添加系统调用"><a href="#添加系统调用" class="headerlink" title="添加系统调用"></a>添加系统调用</h3><p>在unistd.h中增加下面的代码</p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612155524270.png" alt="image-20220612155524270"></p>
<p>再添加系统调用</p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612155644251.png" alt="image-20220612155644251"></p>
<p><strong>注意</strong>：要在挂载下再修改一次</p>
<h3 id="修改sys-h文件"><a href="#修改sys-h文件" class="headerlink" title="修改sys.h文件"></a>修改sys.h文件</h3><p>增加函数声明</p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612155826510.png" alt="image-20220612155826510"></p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612155924786.png" alt="image-20220612155924786"></p>
<p>在system_call.s中把nr_system_calls改为78</p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612165738290.png" alt="image-20220612165738290"></p>
<h3 id="增加shm-c"><a href="#增加shm-c" class="headerlink" title="增加shm.c"></a>增加shm.c</h3><p>在kernel目录下</p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612165927254.png" alt="image-20220612165927254"></p>
<p>然后修改kernel下的Makefile</p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612170053415.png" alt="image-20220612170053415"></p>
<h3 id="编写消费者和生产者程序"><a href="#编写消费者和生产者程序" class="headerlink" title="编写消费者和生产者程序"></a>编写消费者和生产者程序</h3><p>producer.c</p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612203642964.png" alt="image-20220612203642964"></p>
<p>consumer.c</p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612203703637.png" alt="image-20220612203703637"></p>
<h3 id="运行验证"><a href="#运行验证" class="headerlink" title="运行验证"></a>运行验证</h3><p>编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o pro producer.c</span><br><span class="line">gcc -o con consumer.c</span><br></pre></td></tr></table></figure>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612202823323.png" alt="image-20220612202823323"></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pro &gt; proOutput &amp;</span><br><span class="line">con &gt; conOutput &amp;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612202905073.png" alt="image-20220612202905073"></p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612203010281.png" alt="image-20220612203010281"></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sync</span><br></pre></td></tr></table></figure>
<p>关闭linux-0.11回到ubunt终端，输入sudo less hdc/usr/root/conOutput查看结果如下</p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612203138227.png" alt="image-20220612203138227"></p>
<h2 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h2><p><strong>对于地址映射实验部分(第一部分)，列出你认为最重要的几步(不超过四步)，并给出你获得的实际数据。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入命令u/7反汇编，查看变量i对应的逻辑地址</span><br><span class="line">逻辑地址找虚拟地址要通过段表，也就是IDT表，然后IDT表要根据LDTR寄存器和GDT表，对应的命令就是sreg</span><br><span class="line">根据ds(代码段)寄存器查找IDT表，得到基址，然后通过基址 + 逻辑地址 = 虚拟地址</span><br><span class="line">根据虚拟地址找到物理地址，核心就是查找页表</span><br></pre></td></tr></table></figure>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612154459443.png" alt="image-20220612154459443"></p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612162319691.png" alt="image-20220612162319691"></p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612162954016.png" alt="image-20220612162954016"></p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612163210299.png" alt="image-20220612163210299"></p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612164505087.png" alt="image-20220612164505087"></p>
<p><img src="/2022/06/12/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/image-20220612164837721.png" alt="image-20220612164837721"></p>
<p><strong><code>test.c</code>退出后，如果马上再运行一次程序，并再进行地址跟踪，你会发现哪些异同？为什么？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">再运行一次程序，等同于重来，变量i重新被赋非0值，所以仍然会死循环。</span><br><span class="line">继续进行地址跟踪，根据虚拟地址找到物理地址，发现物理地址和第一次运行时的不一样了，因为在这个进程没有被运行时，内存是会被释放的，所以其他进程是可以利用这个内存的，虽然还是这个虚拟地址，但是重新分配内存的时候，物理地址并不一定还是那个地址。</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/" class="post-title-link" itemprop="url">六级作文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 21:53:24 / Modified: 22:14:36" itemprop="dateCreated datePublished" datetime="2022-06-07T21:53:24+08:00">2022-06-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>六级作文共分为现象解释类，谚语类，图画类，观点选择类，问题解决类，所有类别只有第一段书写不同。</p>
<h2 id="第一段"><a href="#第一段" class="headerlink" title="第一段"></a>第一段</h2><h3 id="现象解释类"><a href="#现象解释类" class="headerlink" title="现象解释类"></a>现象解释类</h3><p><img src="/2022/06/07/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/image-20220607220842008.png" alt="image-20220607220842008"></p>
<h3 id="图表类"><a href="#图表类" class="headerlink" title="图表类"></a>图表类</h3><p><img src="/2022/06/07/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/image-20220607220921980.png" alt="image-20220607220921980"></p>
<h3 id="谚语类"><a href="#谚语类" class="headerlink" title="谚语类"></a>谚语类</h3><p><img src="/2022/06/07/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/image-20220607220945787.png" alt="image-20220607220945787"></p>
<h3 id="观点选择"><a href="#观点选择" class="headerlink" title="观点选择"></a>观点选择</h3><p>低级版本：</p>
<p><img src="/2022/06/07/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/image-20220607221025117.png" alt="image-20220607221025117"></p>
<p>高级版本：</p>
<p><img src="/2022/06/07/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/image-20220607221040330.png" alt="image-20220607221040330"></p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p><img src="/2022/06/07/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/image-20220607221107224.png" alt="image-20220607221107224"></p>
<h2 id="第二段"><a href="#第二段" class="headerlink" title="第二段"></a>第二段</h2><p><img src="/2022/06/07/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/image-20220607220727437.png" alt="image-20220607220727437"></p>
<p><img src="/2022/06/07/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/image-20220607220736545.png" alt="image-20220607220736545"></p>
<p><img src="/2022/06/07/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/image-20220607220800935.png" alt="image-20220607220800935"></p>
<h2 id="第三段"><a href="#第三段" class="headerlink" title="第三段"></a>第三段</h2><p><img src="/2022/06/07/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/image-20220607220811838.png" alt="image-20220607220811838"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">信号量的实现和应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-26 19:14:55" itemprop="dateCreated datePublished" datetime="2022-05-26T19:14:55+08:00">2022-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-12 14:27:59" itemprop="dateModified" datetime="2022-06-12T14:27:59+08:00">2022-06-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="信号量的实现与应用"><a href="#信号量的实现与应用" class="headerlink" title="信号量的实现与应用"></a>信号量的实现与应用</h1><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>在消费者与生产者实现时，需要进行文件读写，实验指导书中提到，可通过借助标准C库函数来实现，或者直接通过对应的系统调用。</p>
<p><img src="/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/image-20220526193310932.png" alt="image-20220526193310932"></p>
<p>这里列出关于文件读写的三个函数说明</p>
<p><strong>fseek()</strong></p>
<p>C 库函数 <strong>int fseek(FILE *stream, long int offset, int whence)</strong> 设置流 <strong>stream</strong> 的文件位置为给定的偏移 <strong>offset</strong>，参数 offset 意味着从给定的 <strong>whence</strong> 位置查找的字节数。</p>
<p>声明如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int fseek(FILE *stream, long int offset, int whence)</span><br><span class="line">如fseek( fp, 5, SEEK_SET )就是把文件指针fp移动到距离文件开头5个字节处。</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</span><br><span class="line">offset -- 这是相对 whence 的偏移量，以字节为单位。</span><br><span class="line">whence -- 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SEEK_SET</td>
<td>文件的开头</td>
</tr>
<tr>
<td>SEEK_CUR</td>
<td>文件指针的当前位置</td>
</tr>
<tr>
<td>SEEK_END</td>
<td>文件的末尾</td>
</tr>
</tbody>
</table>
</div>
<p>返回值：如果成功，则该函数返回0，否则返回非零值。</p>
<p><strong>fread()</strong></p>
<p>C 库函数 <strong>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</strong> 从给定流 <strong>stream</strong> 读取数据到 <strong>ptr</strong> 所指向的数组中。</p>
<p>声明如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</span><br><span class="line">如fread(&amp;productid,sizeof(int),1,fp) 就是从fp指向的文件中，读取一个int长度的元素</span><br></pre></td></tr></table></figure>
<p>参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptr -- 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针。</span><br><span class="line">size -- 这是要读取的每个元素的大小，以字节为单位。</span><br><span class="line">nmemb -- 这是元素的个数，每个元素的大小为 size 字节。</span><br><span class="line">stream -- 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流</span><br></pre></td></tr></table></figure>
<p>返回值：成功读取的元素总数会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾。</p>
<p><strong>fwrite()</strong></p>
<p>C 库函数 <strong>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</strong> 把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中。</p>
<p>声明如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</span><br><span class="line">如fwrite(&amp;Outpos,sizeof(int),1,fp)是向fp指向的文件中写入1个int长度的Outpos变量中的内容</span><br></pre></td></tr></table></figure>
<p>参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptr -- 这是指向要被写入的元素数组的指针。</span><br><span class="line">size -- 这是要被写入的每个元素的大小，以字节为单位。</span><br><span class="line">nmemb -- 这是元素的个数，每个元素的大小为 size 字节。</span><br><span class="line">stream -- 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。</span><br></pre></td></tr></table></figure>
<p>返回值：如果成功，该函数返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="实现信号量"><a href="#实现信号量" class="headerlink" title="实现信号量"></a>实现信号量</h3><h4 id="新建sem头文件sem-h"><a href="#新建sem头文件sem-h" class="headerlink" title="新建sem头文件sem.h"></a>新建sem头文件sem.h</h4><p>在linux-0.11/include/linux目录下新建sem.h，定义信号量的数据结构。</p>
<p><img src="/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/image-20220612134551189.png" alt="image-20220612134551189"></p>
<h4 id="sem-c"><a href="#sem-c" class="headerlink" title="sem.c"></a>sem.c</h4><p>在linux-0.11/kernel目录下，新建实现信号量函数的源代码文件sem.c。</p>
<p><img src="/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/image-20220612134734941.png" alt="image-20220612134734941"></p>
<h4 id="修改unistd-h"><a href="#修改unistd-h" class="headerlink" title="修改unistd.h"></a>修改unistd.h</h4><p>在其中增加对于信号量的系统调用编号，类似于之前的操作</p>
<p><img src="/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/image-20220612135224839.png" alt="image-20220612135224839"></p>
<h4 id="修改system-call-s"><a href="#修改system-call-s" class="headerlink" title="修改system_call.s"></a>修改system_call.s</h4><p>因为增加了四个sem系统调用函数，在system_call.s文件中找到nr_system_calls并将其值更改为76</p>
<p><img src="/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/image-20220612135344070.png" alt="image-20220612135344070"></p>
<h4 id="修改sys-h"><a href="#修改sys-h" class="headerlink" title="修改sys.h"></a>修改sys.h</h4><p><img src="/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/image-20220612140948110.png" alt="image-20220612140948110"></p>
<p><img src="/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/image-20220612141013642.png" alt="image-20220612141013642"></p>
<h4 id="修改Makefile"><a href="#修改Makefile" class="headerlink" title="修改Makefile"></a>修改Makefile</h4><p><img src="/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/image-20220612141105182.png" alt="image-20220612141105182"></p>
<p><img src="/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/image-20220612141116701.png" alt="image-20220612141116701"></p>
<h4 id="准备文件"><a href="#准备文件" class="headerlink" title="准备文件"></a>准备文件</h4><p>在oslab根目录下执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./mount-hdc</span><br></pre></td></tr></table></figure>
<p>使用cp命令将unistd.h复制到usr/include下，将sem.h复制到usr/include/linux下</p>
<h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><h4 id="新建pc-c"><a href="#新建pc-c" class="headerlink" title="新建pc.c"></a>新建pc.c</h4><p><img src="/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/image-20220612141444002.png" alt="image-20220612141444002"></p>
<p>进行挂载，再，利用cp命令将其移动到usr/root目录下</p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>运行linux-0.11之后，首先编译pc.c，使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o pc pc.c</span><br></pre></td></tr></table></figure>
<p>随后运行pc，使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pc &gt; sem_output</span><br></pre></td></tr></table></figure>
<p>最终在虚拟环境内输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sync</span><br></pre></td></tr></table></figure>
<p>把修改的数据写入磁盘。</p>
<h4 id="查看sem-output"><a href="#查看sem-output" class="headerlink" title="查看sem_output"></a>查看sem_output</h4><p>首先挂载hdc，然后进入usr/root目录并在终端内执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo less sem_output</span><br></pre></td></tr></table></figure>
<p>命令，可看到下图结果：</p>
<p><img src="/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/image-20220612141711137.png" alt="image-20220612141711137"></p>
<h2 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h2><p>如果去掉所有与信号量有关的代码，编译运行程序之后可以发现输出的数字顺序完全混乱。<br>信号量不存在的情况下，进程之间无法同步或者协作，造成此种情况的有如下原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 一种情况是缓冲区满了，生产者还在写入数据，会造覆盖掉部分数据。</span><br><span class="line">- 一种是缓冲区为空，消费者尝试读取数据，读到的数据是已输出的数据。</span><br><span class="line">- 多个进程对文件缓冲区同时访问，造成了程序崩溃。</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/" class="post-title-link" itemprop="url">进程运行轨迹的跟踪与统计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-24 23:36:46" itemprop="dateCreated datePublished" datetime="2022-05-24T23:36:46+08:00">2022-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-29 21:38:58" itemprop="dateModified" datetime="2022-05-29T21:38:58+08:00">2022-05-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进程运行轨迹的跟踪与统计"><a href="#进程运行轨迹的跟踪与统计" class="headerlink" title="进程运行轨迹的跟踪与统计"></a>进程运行轨迹的跟踪与统计</h1><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="1-修改init-main-c文件。"><a href="#1-修改init-main-c文件。" class="headerlink" title="1.修改init/main.c文件。"></a>1.修改init/main.c文件。</h3><p>由于新改版的实验环境，打印进程 <code>0</code> 的相关内容会产生bug，可能是虚拟机或是其他原因引起的。 因此，后续所有的打印输出都是从进程 <code>1</code> 开始，所以对于init/main.c文件，将在进程1的关联代码后边补充打开log文件的代码。</p>
<p>修改如下：</p>
<p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220525233305349.png" alt="image-20220525233305349"></p>
<p>如果要是按照之前版本进行修改，则进入linux0.11后，会一直在task[0]进行空转，血的教训，浪费了半天时间。</p>
<h3 id="2-在-kernel-printk-c-中增加写文件函数fprintk-。"><a href="#2-在-kernel-printk-c-中增加写文件函数fprintk-。" class="headerlink" title="2.在 kernel/printk.c 中增加写文件函数fprintk() 。"></a>2.在 kernel/printk.c 中增加写文件函数fprintk() 。</h3><p>这个使用实验指导书给出的即可。注意对于</p>
<p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220524234054542.png" alt="image-20220524234054542"></p>
<p>需要进行修改。</p>
<p>若是不进行修改，则程序可进行，但是无法写入process.log，又一个不好好看指导书的教训。</p>
<h3 id="3-在进程的状态改变时，向log文件中写入记录。"><a href="#3-在进程的状态改变时，向log文件中写入记录。" class="headerlink" title="3.在进程的状态改变时，向log文件中写入记录。"></a>3.在进程的状态改变时，向log文件中写入记录。</h3><p>由于进程的状态会在它创建、调度和销毁的时候发生改变，所以需要修改这三个过程对应的内核文件fork.c 、sched.c 和 exit.c ，在其中控制进程状态改变的代码后面加上一段向log文件写入记录的代码。</p>
<h4 id="3-1-修改fork-c"><a href="#3-1-修改fork-c" class="headerlink" title="3.1 修改fork.c"></a>3.1 修改fork.c</h4><p>真正实现进程创建的函数是 copy_process()，它定义在 kernel/fork.c 中，以下的一段代码设置了指向结构体变量的指针p的一系列属性之后，把start_time置成了jiffies，即相当于完成了进程的创建，所以在这行代码之后加上一条写log的代码，就可以记录进程新建的时刻。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">p = (struct task_struct *) get_free_page();</span><br><span class="line">if (!p)</span><br><span class="line">    return -EAGAIN;</span><br><span class="line">task[nr] = p;</span><br><span class="line">*p = *current;  /* NOTE! this doesn&#x27;t copy the supervisor stack */</span><br><span class="line">p-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">p-&gt;pid = last_pid;</span><br><span class="line">p-&gt;father = current-&gt;pid;</span><br><span class="line">p-&gt;counter = p-&gt;priority;</span><br><span class="line">p-&gt;signal = 0;</span><br><span class="line">p-&gt;alarm = 0;</span><br><span class="line">p-&gt;leader = 0;      /* process leadership doesn&#x27;t inherit */</span><br><span class="line">p-&gt;utime = p-&gt;stime = 0;</span><br><span class="line">p-&gt;cutime = p-&gt;cstime = 0;</span><br><span class="line">p-&gt;start_time = jiffies;</span><br></pre></td></tr></table></figure>
<p>修改这两处地方</p>
<p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220524234424811.png" alt="image-20220524234424811"></p>
<p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220524234436584.png" alt="image-20220524234436584"></p>
<h4 id="3-2-修改kernel-sched-c"><a href="#3-2-修改kernel-sched-c" class="headerlink" title="3.2 修改kernel/sched.c"></a>3.2 修改kernel/sched.c</h4><p>以下的修改的原理类似，即在进程状态改变的时候添加fprintk()指令写log文件。</p>
<h5 id="3-2-1修改schedule"><a href="#3-2-1修改schedule" class="headerlink" title="3.2.1修改schedule()"></a>3.2.1修改schedule()</h5><p>对原始代码新增fprintk后如下，实验中给出了提示：schedule() 找到的 next 进程是接下来要运行的进程（注意，一定要分析清楚 next 是什么）。如果 next 恰好是当前正处于运行态的进程，swith_to(next) 也会被调用。这种情况下相当于当前进程的状态没变。</p>
<p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220524234613727.png" alt="image-20220524234613727"></p>
<p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220524234623625.png" alt="image-20220524234623625"></p>
<h5 id="3-2-2修改sys-pause"><a href="#3-2-2修改sys-pause" class="headerlink" title="3.2.2修改sys_pause()"></a>3.2.2修改sys_pause()</h5><p>系统无事可做的时候，进程 0 会不停地调用 sys_pause()，以激活调度算法。此时它的状态可以是等待态，等待有其它可运行的进程；也可以叫运行态，因为它是唯一一个在 CPU 上运行的进程，只不过运行的效果是等待。</p>
<p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220524234648246.png" alt="image-20220524234648246"></p>
<h5 id="3-2-3修改sleep-on"><a href="#3-2-3修改sleep-on" class="headerlink" title="3.2.3修改sleep_on()"></a>3.2.3修改sleep_on()</h5><p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220524234713922.png" alt="image-20220524234713922"></p>
<h5 id="3-2-4修改interruptible-sleep-on"><a href="#3-2-4修改interruptible-sleep-on" class="headerlink" title="3.2.4修改interruptible_sleep_on()"></a>3.2.4修改interruptible_sleep_on()</h5><p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220524234737161.png" alt="image-20220524234737161"></p>
<h5 id="3-2-5修改wake-up"><a href="#3-2-5修改wake-up" class="headerlink" title="3.2.5修改wake_up()"></a>3.2.5修改wake_up()</h5><p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220524234753974.png" alt="image-20220524234753974"></p>
<h4 id="3-3修改kernel-exit-c"><a href="#3-3修改kernel-exit-c" class="headerlink" title="3.3修改kernel/exit.c"></a>3.3修改kernel/exit.c</h4><h5 id="3-3-1修改do-exit"><a href="#3-3-1修改do-exit" class="headerlink" title="3.3.1修改do_exit"></a>3.3.1修改do_exit</h5><p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220524234908049.png" alt="image-20220524234908049"></p>
<h5 id="3-3-2修改sys-waitpid"><a href="#3-3-2修改sys-waitpid" class="headerlink" title="3.3.2修改sys_waitpid"></a>3.3.2修改sys_waitpid</h5><p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220524234925762.png" alt="image-20220524234925762"></p>
<h3 id="4-最终编写一个process-c程序，用它创建多个进程来进行测试。"><a href="#4-最终编写一个process-c程序，用它创建多个进程来进行测试。" class="headerlink" title="4.最终编写一个process.c程序，用它创建多个进程来进行测试。"></a>4.最终编写一个process.c程序，用它创建多个进程来进行测试。</h3><p>该文件的目的是创建几个进程用来测试，注意用到fork()和wait()两个函数。</p>
<p>fork()函数，简单说该函数的作用就是创建一个子进程，开辟一条与父进程平行的时间线，即创建了一个分叉路口。在调用fork的时候就产生这个分叉路口了，fork之前与之后的代码都会被分岔路口之后的父进程和子进程执行。 </p>
<p>fork它在父进程和子进程里的返回值是不同的：父进程中返回子进程的ID，子进程中返回0（。 那么如果我想让一条语句在子进程中执行而不在父进程中执行，那么就可以判断fork()的返回值是不是等于0，如果等于0就执行这条语句。</p>
<p>wait()函数，当调用该函数时（如果没有参数），意思就是判断当前进程的子进程有没有结束，如果有任意一个子进程结束了，那么当前进程就可以结束了，否则就处于阻塞状态；如果当前进程已经没有子进程了，那么就不会发生什么事，不会阻塞，只是wait的返回值发生变化。也就是说，如果当前进程有三个子进程，如果我要让这三个子进程先结束，让当前进程最后结束，那么就连用三个wait()，才能确保当前进程在三个子进程都结束后再结束。</p>
<p><strong>注</strong>：关于这部分知识可参考CSAPP，有详细介绍过。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;sys/times.h&gt; </span><br><span class="line">#include &lt;sys/wait.h&gt; </span><br><span class="line">#include &lt;sys/types.h&gt; </span><br><span class="line">#define HZ    100</span><br><span class="line"></span><br><span class="line">void cpuio_bound(int last, int cpu_time, int io_time);</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">       pid_t Pid1;</span><br><span class="line">       pid_t Pid2;</span><br><span class="line">       pid_t Pid3;</span><br><span class="line"></span><br><span class="line">       Pid1 = fork(); </span><br><span class="line">       if (Pid1 &lt; 0) printf(&quot;error in fork!&quot;); </span><br><span class="line">       else if (Pid1 == 0) </span><br><span class="line">            &#123;</span><br><span class="line">                 printf(&quot;child process 1:\n&quot;);</span><br><span class="line">                 cpuio_bound(5, 2, 2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">       Pid2 = fork();</span><br><span class="line">       if (Pid2 &lt; 0) printf(&quot;error in fork!&quot;); </span><br><span class="line">       else if (Pid2 == 0) </span><br><span class="line">            &#123;</span><br><span class="line">                 printf(&quot;child process 2:\n&quot;);</span><br><span class="line">                 cpuio_bound(5, 4, 0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">       Pid3 = fork();</span><br><span class="line">       if (Pid3 &lt; 0) printf(&quot;error in fork!&quot;); </span><br><span class="line">       else if (Pid3 == 0) </span><br><span class="line">            &#123;</span><br><span class="line">                 printf(&quot;child process 3:\n&quot;);</span><br><span class="line">                 cpuio_bound(5, 0, 4);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">       printf(&quot;This process&#x27;s Pid is %d\n&quot;, getpid());</span><br><span class="line">       printf(&quot;Pid of child process 1 is %d\n&quot;, Pid1);</span><br><span class="line">       printf(&quot;Pid of child process 2 is %d\n&quot;, Pid2);</span><br><span class="line">       printf(&quot;Pid of child process 3 is %d\n&quot;, Pid3);</span><br><span class="line">       wait(NULL);</span><br><span class="line">       wait(NULL);</span><br><span class="line">       wait(NULL);</span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 此函数按照参数占用CPU和I/O时间</span><br><span class="line"> * last: 函数实际占用CPU和I/O的总时间，必须&gt;=0,同时不含在就绪队列中的时间</span><br><span class="line"> * cpu_time: 一次连续占用CPU的时间，必须&gt;=0</span><br><span class="line"> * io_time: 一次I/O消耗的时间，必须&gt;=0</span><br><span class="line"> * 如果last &gt; cpu_time + io_time，则往复多次占用CPU和I/O </span><br><span class="line"> */</span><br><span class="line">void cpuio_bound(int last, int cpu_time, int io_time)</span><br><span class="line">&#123;</span><br><span class="line">    struct tms start_time, current_time;</span><br><span class="line">    clock_t utime, stime;</span><br><span class="line">    int sleep_time;</span><br><span class="line"></span><br><span class="line">    while (last &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        /* CPU Burst */</span><br><span class="line">        times(&amp;start_time);</span><br><span class="line">        /* 其实只有t.tms_utime才是真正的CPU时间。但由于模拟的是一个</span><br><span class="line">         * 只在用户状态运行的CPU大户，就像“for(;;);”。所以把t.tms_stime</span><br><span class="line">         * 加上很合理。*/</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            times(&amp;current_time);</span><br><span class="line">            utime = current_time.tms_utime - start_time.tms_utime;</span><br><span class="line">            stime = current_time.tms_stime - start_time.tms_stime;</span><br><span class="line">        &#125; while ( ( (utime + stime) / HZ )  &lt; cpu_time );</span><br><span class="line">        last -= cpu_time;</span><br><span class="line"></span><br><span class="line">        if (last &lt;= 0 )</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        /* IO Burst */</span><br><span class="line">        /* 用sleep(1)模拟1秒钟的I/O操作 */</span><br><span class="line">        sleep_time=0;</span><br><span class="line">        while (sleep_time &lt; io_time)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(1);</span><br><span class="line">            sleep_time++;</span><br><span class="line">        &#125;</span><br><span class="line">        last -= sleep_time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo ./mount-hdc</span><br><span class="line">cp ./process.c ./hdc/usr/root/</span><br><span class="line">./run</span><br><span class="line">gcc -o process process.c</span><br><span class="line">./process</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220525122913097.png" alt="image-20220525122913097" style="zoom:80%;"></p>
<p>运行<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=sync&amp;spm=1001.2101.3001.7020">sync</a>指令进行同步，将缓冲区信息加载到硬盘。然后关闭模拟器，再次挂载hdc后，进入查看hdc/var/process.log。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sync</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220524235601959.png" alt="image-20220524235601959"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp ./hdc/var/process.log ./</span><br><span class="line">sudo chmod +x ./stat_log.py</span><br><span class="line">./stat_log.py process.log 7 8 9 10 11 12 13 14 -g</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220525232721464.png" alt="image-20220525232721464"></p>
<p><strong>注</strong>：由于修改了实验环境，所以从进程一开始打印，所以对应的stat_log.py也需要修改，主要修改如下</p>
<p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220525232924032.png" alt="image-20220525232924032"></p>
<p>在这里额外补充进程1的新建和运行。</p>
<p>因为对于本次实验，我们是在进程1运行后才开始写入的，所以没有进程0与进程1的创建，而我们对应的py程序又会将其检测为一个error，报nonew的异常，所以需要手动补充。</p>
<p><strong>修改时间片</strong></p>
<p>nux0.11采用的调度算法是一种综合考虑进程优先级并能动态反馈调整时间片的轮转调度算法。 它为每个进程分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程；如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。</p>
<p>综合考虑进程优先级：一个进程在阻塞队列中停留的时间越长，它的优先级就越大，下次就会被分配更大的时间片。</p>
<p>进程之间的切换是需要时间的，如果时间片设定得太小的话，就会发生频繁的进程切换，因此会浪费大量时间在进程切换上，影响效率；如果时间片设定得足够大的话，就不会浪费时间在进程切换上，利用率会更高，但是用户交互性会受到影响，在这里老师上课讲的银行的例子就可以拿过来。</p>
<p>时间片的初始值是进程0的priority，是在linux-0.11/include/linux/sched.h的宏 INIT_TASK 中定义的，如下：我们只需要修改宏中的第三个值即可，该值即时间片的初始值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define INIT_TASK \</span><br><span class="line">    &#123; 0,15,15, </span><br><span class="line">// 上述三个值分别对应 state、counter 和 priority;</span><br></pre></td></tr></table></figure>
<p>我修改了三个值，结果分别如下</p>
<p>其中Average值发生了变化，throughout变化为小数点后发生的变化。</p>
<p>当时间片为10时：</p>
<p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220525234224119.png" alt="image-20220525234224119"></p>
<p>当时间片为15时：</p>
<p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220525234651300.png" alt="image-20220525234651300"></p>
<p>当时间片为20时：</p>
<p><img src="/2022/05/24/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/image-20220525234458649.png" alt="image-20220525234458649"></p>
<h2 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h2><p><strong>问题1：单进程编程和多进程编程的区别？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.执行方式：单进程编程是一个进程从上到下顺序进行；多进程编程可以通过并发执行，即多个进程之间交替执行，如某一个进程正在I/O输入输出而不占用CPU时，可以让CPU去执行另外一个进程，这需要采取某种调度算法。</span><br><span class="line"></span><br><span class="line">2.数据是否同步：单进程的数据是同步的，因为单进程只有一个进程，在进程中改变数据的话，是会影响这个进程的；多进程的数据是异步的，因为子进程数据是父进程数据在内存另一个位置的拷贝，因此改变其中一个进程的数据，是不会影响到另一个进程的。</span><br><span class="line"></span><br><span class="line">3.CPU利用率：单进程编程的CPU利用率低，因为单进程在等待I/O时，CPU是空闲的；多进程编程的CPU利用率高，因为当某一进程等待I/O时，CPU会去执行另一个进程，因此CPU的利用率高。</span><br><span class="line"></span><br><span class="line">4.多进程用途更广泛。</span><br></pre></td></tr></table></figure>
<p><strong>问题2：你是如何修改时间片的？仅针对样本程序建立的进程，在修改时间片前后， <code>log</code> 文件的统计结果（不包括Graphic）都是什么样？结合你的修改分析一下为什么会这样变化，或者为什么没变化？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将时间片变小，进程调度次数变多，系统会使得该进程等待时间变长。</span><br><span class="line">将时间片增大，进程因中断/睡眠而产生的调度次数也增多，等待时间也会变长。</span><br><span class="line">总结：时间片要设置合理，不能过大或者过小。</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">系统调用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-23 18:15:36 / Modified: 21:08:28" itemprop="dateCreated datePublished" datetime="2022-05-23T18:15:36+08:00">2022-05-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p><strong>应用程序如何调用系统调用</strong></p>
<p>在通常情况下，调用系统调用和调用一个普通的自定义函数在代码上并没有什么区别，但调用后发生的事情有很大不同。</p>
<p>调用自定义函数是通过 call 指令直接跳转到该函数的地址，继续运行。</p>
<p>而调用系统调用，是调用系统库中为该系统调用编写的一个接口函数，叫 API（Application Programming Interface）。API 并不能完成系统调用的真正功能，它要做的是去调用真正的系统调用，过程是：</p>
<p>把系统调用的编号存入 EAX；<br>把函数参数存入其它通用寄存器；<br>触发 0x80 号中断（int 0x80）。<br>linux-0.11 的 lib 目录下有一些已经实现的 API。Linus 编写它们的原因是在内核加载完毕后，会切换到用户模式下，做一些初始化工作，然后启动 shell。而用户模式下的很多工作需要依赖一些系统调用才能完成，因此在内核中实现了这些系统调用的 API。<br><strong>为什么要有内核态和用户态两种状态？</strong></p>
<p>因为有些操作很危险，比如清空内存，I/O等，不能随便一个程序就能进行这样的操作。所以区分出内核态与用户态，用户态可以执行一些不危险的操作，当需要执行危险操作时，需要通过系统调用等方法进入内核态执行。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p><strong>1.修改linux-0.11/include/linux/sys.h</strong></p>
<p>需要把 <code>iam()</code> 与 <code>whoami()</code> 两个函数声明为全局变量，并添加到中断函数表中，当中断被调用的时候，先查找中断向量表，找到相应的函数名，调用其函数。</p>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523192718134.png" alt="image-20220523192718134"></p>
<p><strong>2.修改系统调用数</strong></p>
<p><code>system_call.s</code> 在 <code>linux-0.11/kernel</code> 中<br>需要把<code>nr_system_calls</code> 由72改为 74 表示了中断函数的个数。</p>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523192844373.png" alt="image-20220523192844373"></p>
<p><strong>3.新增系统调用号</strong></p>
<p>需要在<code>unistd.h</code> 中修改，但是实验后发现行不通，查阅后发现需要在linux系统中修改。</p>
<p>运行 <code>sudo ./mount-hdc</code> 可以把虚拟机硬盘挂载在 <code>oslab/hdc</code> 目录下。<br>在 <code>hdc/usr/include</code> 目录下修改 <code>unistd.h</code></p>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523193158462.png" alt="image-20220523193158462"></p>
<p><strong>4.新增 who.c 文件，实现系统调用的函数</strong></p>
<p>将完成的who.c文件放入linux-0.01/kernel 目录下</p>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523210811801.png" alt="image-20220523210811801"></p>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523210825948.png" alt="image-20220523210825948"></p>
<p><strong>5.修改makefile</strong></p>
<p>共有两处</p>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523193418730.png" alt="image-20220523193418730"></p>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523193435486.png" alt="image-20220523193435486"></p>
<p><strong>6.新增 iam.c 和 whoami.c 文件以测试系统调用是否添加成功</strong></p>
<p>iam.c</p>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523193643654.png" alt="image-20220523193643654"></p>
<p>whoami.c</p>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523193550834.png" alt="image-20220523193550834"></p>
<p>同理需要在linux0.11下编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./mount-hdc </span><br><span class="line">cp ./iam.c hdc/usr/root</span><br><span class="line">cp ./whoami.c hdc/usr/root</span><br></pre></td></tr></table></figure>
<p>然后./run</p>
<p><strong>7.编译 iam.c 跟 whoami.c</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o iam iam.c </span><br><span class="line">gcc -o whoami whoami.c </span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523203159191.png" alt="image-20220523203159191"></p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523192418659.png" alt="image-20220523192418659"></p>
<p>以及两个测试结果</p>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523193847193.png" alt="image-20220523193847193"></p>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523193923766.png" alt="image-20220523193923766"></p>
<h2 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h2><p><strong>一、</strong></p>
<ul>
<li>从 <code>Linux 0.11</code> 现在的机制看，它的系统调用最多能传递几个参数？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux-0.11的系统调用通过寄存器ebx、ecx、edx传递参数，最多能传递3个参数。</span><br></pre></td></tr></table></figure>
<p><strong>二、</strong></p>
<ul>
<li>你能想出办法来扩大这个限制吗？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.增加传参所用的寄存器</span><br><span class="line">2.通过定义结构体，在结构体中存入很多参数，然而只把结构体入口地址作为参数进行传递；</span><br><span class="line">3.或者就利用这三个寄存器，重复传值</span><br><span class="line">4.或者将寄存器进行拆分，根据需要不同位传值</span><br></pre></td></tr></table></figure>
<p><strong>三、</strong></p>
<ul>
<li>用文字简要描述向 <code>Linux 0.11</code> 添加一个系统调用 <code>foo()</code> 的步骤。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.在include/unistd.h中定义宏__NR_foo，并添加供用户调用的函数声明void foo()；</span><br><span class="line">2.修改kernel/system_call.s中的nr_system_calls，使其增加1；</span><br><span class="line">3.在include/linux/sys.h中添加函数声明extern void sys_foo()，在系统调用入口表fn_ptr末端添加元素sys_foo；</span><br><span class="line">4.添加kernel/foo.c文件，实现sys_foo()函数；</span><br><span class="line">5.修改kernel/Makefile，在OBJS中加入foo.o，并添加生成foo.s、foo.o的依赖规则。</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>记录一个只有自己遇到的问题，当我对于Linux0.11文件进行make时，发现会报错，具体错误如下，</p>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523205611785.png" alt="image-20220523205611785"></p>
<p>当我调试后发现，问题出自linux/kernel/chr_drv处</p>
<p>当我用一个新的该文件，只在chr_drv下make时，会出现</p>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523205822630.png" alt="image-20220523205822630"></p>
<p>于是我make clean，再进行make，会出现下面的错误make</p>
<p><img src="/2022/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20220523205901514.png" alt="image-20220523205901514"></p>
<p>这两个问题分别对应于上面提到的那两个问题。</p>
<p>目前我没有找出这个问题的原因，我所采用的解决办法是，在其他机子上先对chr_drv文件进行编译，然后进行替换，则可以解决问题。困惑…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/20/DBMS%E8%80%83%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/20/DBMS%E8%80%83%E7%82%B9/" class="post-title-link" itemprop="url">DBMS考点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-20 15:29:10" itemprop="dateCreated datePublished" datetime="2022-05-20T15:29:10+08:00">2022-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-21 09:32:31" itemprop="dateModified" datetime="2022-05-21T09:32:31+08:00">2022-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DBMS考点"><a href="#DBMS考点" class="headerlink" title="DBMS考点"></a>DBMS考点</h1><p>对的要求再复习一次</p>
<p>域再看一下，函数依赖再看一下，关系模式分解</p>
<p>1-3部分：选择，填空，查询 30</p>
<p>4-6部分：选择，填空，证明，设计 35</p>
<p>7-12部分：选择，填空，算法，分析 35</p>
<h2 id="考前看的"><a href="#考前看的" class="headerlink" title="考前看的"></a>考前看的</h2><p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520205944497.png" alt="image-20220520205944497" style="zoom:50%;"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520205958323.png" alt="image-20220520205958323" style="zoom:50%;"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520212508933.png" alt="image-20220520212508933" style="zoom:50%;"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520224447692.png" alt="image-20220520224447692" style="zoom:50%;"></p>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p><strong>数据库</strong>：有组织的、共享的、持久存储的数据集合。</p>
<p><strong>数据库管理系统</strong>：<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520153555464.png" alt="image-20220520153555464" style="zoom:50%;"></p>
<p><strong>数据库用户</strong>：<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520153623316.png" alt="image-20220520153623316" style="zoom:50%;"></p>
<p><strong>数据库系统</strong>：由数据库、数据库管理系统、应用程序和数据库用户在一起构成的系统。</p>
<p><strong>数据库语言</strong>：数据定义语言；数据操作语言</p>
<p><strong>数据模型</strong>：<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520153847947.png" alt="image-20220520153847947" style="zoom:50%;"></p>
<p><strong>数据库模式</strong>：<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520154032246.png" alt="image-20220520154032246" style="zoom:50%;"></p>
<p><strong>数据库实例</strong>：<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520154059712.png" alt="image-20220520154059712" style="zoom:50%;"></p>
<p><strong>数据库三层模式结构</strong>：数据库模式通常分三个层次定义，从低到高分别是:内模式/存储模式；概念模式；外模式/视图</p>
<p><strong>内模式/存储模式</strong>：描述数据库的物理存储结构和存取方式；数据库只有一个内模式；定义内模式时通常使用物理数据模型提供的概念</p>
<p><strong>概念模式</strong>：为全体数据库用户描述整个数据库的结构和约束；数据库只有一个概念模式；定义概念模式时使用实现数据模型提供的概念</p>
<p><strong>外模式/视图</strong>：从不同类别用户的视角描述数据库结构；可以有多个外模式；定义外模式时也可以使用实现数据模型提供的概念</p>
<p><strong>数据独立性</strong>：逻辑数据独立性；物理数据独立性</p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520154405650.png" alt="image-20220520154405650" style="zoom:50%;"></p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p><strong>超键</strong>：可以唯一标识每个元组的属性。</p>
<p><strong>候选键</strong>：任意真子集都不是超键的超键。即极小的超键。</p>
<p><strong>域</strong>：<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520155141463.png" alt="image-20220520155141463" style="zoom:50%;"></p>
<p><strong>主属性</strong>：候选键中的属性。</p>
<h3 id="关系完整性约束"><a href="#关系完整性约束" class="headerlink" title="关系完整性约束"></a>关系完整性约束</h3><p>完整性约束的类型：实体完整性、参照完整性、用户定义完整性。</p>
<p>实体完整性约束规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主键值唯一且非空。</span><br></pre></td></tr></table></figure>
<p>参照完整性约束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于外键的约束，外键值为空或不为空则必须在S存在。</span><br></pre></td></tr></table></figure>
<p>用户定义完整性约束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据需求定义。</span><br></pre></td></tr></table></figure>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>投影<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520155612344.png" alt="image-20220520155612344" style="zoom:50%;"></p>
<p>并、差、交<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520155641699.png" alt="image-20220520155641699" style="zoom: 67%;"></p>
<p>重命名<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520155743424.png" alt="image-20220520155743424" style="zoom:50%;"></p>
<p>$\theta$连接<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520155859015.png" alt="image-20220520155859015" style="zoom:50%;"></p>
<p>等值连接：连接条件仅涉及相等比较的连接称作等值连接。</p>
<p>除<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520160538221.png" alt="image-20220520160538221" style="zoom:50%;"></p>
<p>分组操作<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520160612769.png" alt="image-20220520160612769" style="zoom: 67%;"></p>
<h3 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h3><p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520160959188.png" alt="image-20220520160959188"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520161142076.png" alt="image-20220520161142076"></p>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="非嵌套查询"><a href="#非嵌套查询" class="headerlink" title="非嵌套查询"></a>非嵌套查询</h3><p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520161425477.png" alt="image-20220520161425477" style="zoom: 100%;"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520161503774.png" alt="image-20220520161503774" style="zoom: 50%;"></p>
<p><strong>注意</strong>：空值判断，应用 is null,不可以用 =或者！=</p>
<p>查询结果排序<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520161558258.png" alt="image-20220520161558258"></p>
<p>聚集查询<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520161649142.png" alt="image-20220520161649142" style="zoom:67%;"></p>
<p><strong>注</strong>：聚集函数不能出现在where子句中</p>
<p>分组查询<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520161924541.png" alt="image-20220520161924541"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520161945409.png" alt="image-20220520161945409"></p>
<p>连接<img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520162037491.png" alt="image-20220520162037491"></p>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520162335425.png" alt="image-20220520162335425"></p>
<p>使用exists关键字进行查询的时候，首先，我们先查询的不是子查询的内容，而是查我们的主查询的表，然后，根据表的每一条记录，依次去判断where后面的条件是否成立。</p>
<p>in在查询的时候，首先查询子查询的表，然后将内表和外表做一个笛卡尔积，然后按照条件进行筛选。所以相对内表比较小的时候，in的速度较快。</p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520162543845.png" alt="image-20220520162543845" style="zoom:50%;"></p>
<h3 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h3><p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520162635401.png" alt="image-20220520162635401"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520162642179.png" alt="image-20220520162642179"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520162649518.png" alt="image-20220520162649518"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520162658892.png" alt="image-20220520162658892"></p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520162844795.png" alt="image-20220520162844795"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520162906353.png" alt="image-20220520162906353"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520162914871.png" alt="image-20220520162914871"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520162930131.png" alt="image-20220520162930131" style="zoom:50%;"></p>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="数据库设计的基本过程"><a href="#数据库设计的基本过程" class="headerlink" title="数据库设计的基本过程"></a>数据库设计的基本过程</h3><p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520163234585.png" alt="image-20220520163234585"></p>
<h3 id="实体-联系模型"><a href="#实体-联系模型" class="headerlink" title="实体-联系模型"></a>实体-联系模型</h3><h4 id="与实体相关的概念"><a href="#与实体相关的概念" class="headerlink" title="与实体相关的概念"></a>与实体相关的概念</h4><p><strong>实体</strong>：数据库中表示的现实世界中的具体对象或事物。</p>
<p><strong>属性</strong>：用于刻画实体的特性。</p>
<p><strong>属性的类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">简单属性</span><br><span class="line">复合属性</span><br><span class="line">多值属性</span><br><span class="line">派生属性</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520163910020.png" alt="image-20220520163910020"></p>
<h5 id="实体型的ER图表示"><a href="#实体型的ER图表示" class="headerlink" title="实体型的ER图表示"></a>实体型的ER图表示</h5><p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520163916662.png" alt="image-20220520163916662" style="zoom:50%;"></p>
<p><strong>弱实体型</strong>：没有键属性的实体型。</p>
<p><strong>标识实体型、属主实体型</strong>：由于弱实体型没有键属性，需要依赖于其他实体型进行区分。</p>
<p><strong>标识联系型</strong>：弱实体型与其标识实体型通过标识联系型关联。</p>
<p><strong>部分键</strong>：用于区分和同一标识实体相关联的弱实体的属性集合。</p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520163925574.png" alt="image-20220520163925574" style="zoom:50%;"></p>
<h4 id="与联系相关的概念"><a href="#与联系相关的概念" class="headerlink" title="与联系相关的概念"></a>与联系相关的概念</h4><p><strong>联系</strong>：一个联系表示多个实体之间有意义的关联关系。</p>
<p><strong>联系型</strong>：同一类联系共同具有的类型。</p>
<p><strong>联系型的度</strong>：参与到一个联系型中的实体型的个数。</p>
<p><strong>联系集</strong>：数据库中当前存储的联系型的实例的集合。</p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520163949288.png" alt="image-20220520163949288" style="zoom:50%;"></p>
<p><strong>基数比</strong><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520164015974.png" alt="image-20220520164015974" style="zoom:50%;"></p>
<p><strong>参与度</strong></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520164105233.png" alt="image-20220520164105233" style="zoom:50%;"></p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="概念数据模型转换为关系数据库模型"><a href="#概念数据模型转换为关系数据库模型" class="headerlink" title="概念数据模型转换为关系数据库模型"></a>概念数据模型转换为关系数据库模型</h3><p><strong>实体型的转换</strong></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520164330211.png" alt="image-20220520164330211" style="zoom:50%;"></p>
<p><strong>复合属性的转换</strong></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520164401070.png" alt="image-20220520164401070" style="zoom:50%;"></p>
<p><strong>多值属性的转换</strong></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520164446039.png" alt="image-20220520164446039" style="zoom:50%;"></p>
<p><strong>弱实体型转换</strong></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520164516972.png" alt="image-20220520164516972" style="zoom:50%;"></p>
<p><strong>M:N二元联系型的转换</strong></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520164634209.png" alt="image-20220520164634209" style="zoom:50%;"></p>
<p><strong>N:1二元联系型的转换</strong></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520164726502.png" alt="image-20220520164726502" style="zoom:50%;"></p>
<p><strong>1:1二元联系型的转换</strong></p>
<p>与N:1相同</p>
<h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p><strong>定义</strong></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520164850113.png" alt="image-20220520164850113" style="zoom:50%;"></p>
<p><strong>平凡函数依赖</strong><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520164953833.png" alt="image-20220520164953833"></p>
<p><strong>完全函数依赖</strong><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520165020624.png" alt="image-20220520165020624" style="zoom:50%;"></p>
<p><strong>部分函数依赖</strong><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520165056729.png" alt="image-20220520165056729" style="zoom:50%;"></p>
<p><strong>传递函数依赖</strong><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520165125143.png" alt="image-20220520165125143" style="zoom:50%;"></p>
<p><strong>逻辑蕴含</strong><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520165211147.png" alt="image-20220520165211147" style="zoom:50%;"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520165702247.png" alt="image-20220520165702247" style="zoom:50%;"></p>
<p><strong>属性集闭包</strong><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520165402241.png" alt="image-20220520165402241" style="zoom:50%;"></p>
<p><strong>等价函数依赖集</strong><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520165508652.png" alt="image-20220520165508652" style="zoom:50%;"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520165515069.png" alt="image-20220520165515069" style="zoom:50%;"></p>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>若关系模式R的每个属性都是不可分的，则称R为第一范式关系模式。</p>
<p>问题原因：非主属性部分函数依赖于候选键</p>
<p><strong>第二范式</strong></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520165753008.png" alt="image-20220520165753008"></p>
<p>问题原因：非主属性传递函数依赖于候选键</p>
<p><strong>第三范式</strong></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520165821598.png" alt="image-20220520165821598"></p>
<p>问题原因：主属性部分依赖于候选键</p>
<p><strong>BCNF</strong></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520165852993.png" alt="image-20220520165852993" style="zoom:50%;"></p>
<p>消除主属性间的传递依赖。</p>
<p>判断方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_43865875/article/details/115659734</span><br></pre></td></tr></table></figure>
<h3 id="关系模式分解"><a href="#关系模式分解" class="headerlink" title="关系模式分解"></a>关系模式分解</h3><p>分解准则1：无损连接性</p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520170550893.png" alt="image-20220520170550893" style="zoom:50%;"></p>
<p>分解准则2：函数依赖保持性</p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520170647628.png" alt="image-20220520170647628" style="zoom:50%;"></p>
<p>无损连接性判定</p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520170717706.png" alt="image-20220520170717706" style="zoom:50%;"></p>
<p>BCNF分解算法</p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520170838645.png" alt="image-20220520170838645" style="zoom:50%;"></p>
<p>3NF分解算法</p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520170855147.png" alt="image-20220520170855147" style="zoom:50%;"></p>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h3><p>根据数据文件中的元组是否按索引键值排序，分为聚簇索引与非聚簇索引。</p>
<p><strong>聚簇索引</strong></p>
<p>文件中的元组按索引键排序的，则索引为聚簇索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">聚簇索引的索引键通常为关系主键；</span><br><span class="line">一个关系通常只有一个聚簇索引</span><br></pre></td></tr></table></figure>
<p><strong>非聚簇索引</strong></p>
<p>文件中的元组不按索引键排序的，则索引为非聚簇索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个关系上可以有多个非聚簇索引</span><br></pre></td></tr></table></figure>
<p>根据索引键是否为关系的主键，可将有序索引分为两类：主索引，二级索引</p>
<p>主索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引键为主键；一个关系只有一个</span><br></pre></td></tr></table></figure>
<p>二级索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">索引键不是主键：</span><br><span class="line">通常为非聚簇索引，一个关系可以有多个</span><br></pre></td></tr></table></figure>
<p>根据关系中每个元组在索引中是否都有一个对应索引项，可将有序索引分为两类：稠密索引、稀疏索引</p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520175937252.png" alt="image-20220520175937252" style="zoom: 67%;"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520175956860.png" alt="image-20220520175956860"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520180242647.png" alt="image-20220520180242647" style="zoom:67%;"></p>
<h3 id="关系模式的优化"><a href="#关系模式的优化" class="headerlink" title="关系模式的优化"></a>关系模式的优化</h3><p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520180448573.png" alt="image-20220520180448573"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520180514823.png" alt="image-20220520180514823" style="zoom:50%;"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520180528762.png" alt="image-20220520180528762" style="zoom:50%;"></p>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h3 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h3><p>按CPU访问存储介质的方式，可将存储器分为三类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主存储器</span><br><span class="line">二级存储器</span><br><span class="line">三级存储器</span><br></pre></td></tr></table></figure>
<p>主存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">包括：寄存器、高速缓存、内存</span><br><span class="line">主存特点：按字节寻址、可使用load/store指令直接访问</span><br></pre></td></tr></table></figure>
<p>二级存储器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">包括：磁盘/机械硬盘、闪存/固态硬盘</span><br><span class="line">特点：按块寻址、联机使用 CPU无法直接访问，需用read、write将数据先复制到主存</span><br></pre></td></tr></table></figure>
<p>三级存储器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">包括：磁带、光盘、网络存储</span><br><span class="line">脱机使用、按块存储、需先将数据复制到二级存储</span><br></pre></td></tr></table></figure>
<p>按存储介质的易失性/持久性，可分为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">易失性存储器：计算机重启后，易失性存储器的数据会丢失</span><br><span class="line">菲易失性存储器</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520180639352.png" alt="image-20220520180639352"></p>
<h3 id="基于磁盘的数据库存储结构"><a href="#基于磁盘的数据库存储结构" class="headerlink" title="基于磁盘的数据库存储结构"></a>基于磁盘的数据库存储结构</h3><p>元组表示</p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520180900446.png" alt="image-20220520180900446" style="zoom:50%;"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520180909316.png" alt="image-20220520180909316" style="zoom:50%;"></p>
<p>页布局</p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520180936480.png" alt="image-20220520180936480" style="zoom:50%;"></p>
<p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520180943648.png" alt="image-20220520180943648" style="zoom:50%;"></p>
<p>其余和原本内容一致，查看DBMS的文档。</p>
<h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p>可扩展哈希表</p>
<p>线性哈希表</p>
<p>B+树</p>
<h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><p><img src="/2022/05/20/DBMS%E8%80%83%E7%82%B9/image-20220520181353631.png" alt="image-20220520181353631"></p>
<h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">编译原理总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-18 23:36:48" itemprop="dateCreated datePublished" datetime="2022-05-18T23:36:48+08:00">2022-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-19 11:21:13" itemprop="dateModified" datetime="2022-05-19T11:21:13+08:00">2022-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h2><h3 id="杂乱"><a href="#杂乱" class="headerlink" title="杂乱"></a>杂乱</h3><h4 id="消除左递归的方法"><a href="#消除左递归的方法" class="headerlink" title="消除左递归的方法"></a>消除左递归的方法</h4><p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220512192836269.png" alt="image-20220512192836269" style="zoom:50%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220512192935922.png" alt="image-20220512192935922" style="zoom:50%;"></p>
<h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p><strong>句柄</strong>：句型的最左直接短语</p>
<h4 id="LL文法判断"><a href="#LL文法判断" class="headerlink" title="LL文法判断"></a>LL文法判断</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当且仅当G的任意两个具有相同左部的产生式A → α | β 满足下面的条件：</span><br><span class="line">不存在终结符a使得α 和β都能够推导出以a开头的串</span><br><span class="line">α 和β至多有一个能推导出ε </span><br><span class="line">如果 β -&gt;* ε，则FIRST (α)∩FOLLOW(A) =Φ；</span><br><span class="line">如果 α -&gt;* ε，则FIRST (β)∩FOLLOW(A) =Φ；</span><br></pre></td></tr></table></figure>
<h4 id="LR四种文法的判断"><a href="#LR四种文法的判断" class="headerlink" title="LR四种文法的判断"></a>LR四种文法的判断</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关系：LR(0)&lt;SLR(1)&lt;LALR(1)&lt;LR(1)</span><br></pre></td></tr></table></figure>
<p>1.判断LR(0)文法：<br>看项目中是否有归约-归约和移进-归约冲突。<br>如果无冲突则是LR(0)文法（如果是LR(0)文法则四种都是）；如果有冲突则不是LR(0)文法。（就要向下判断）</p>
<p>2.判断SLR(1)文法：<br>a:DFA中存在冲突项目（归约-归约，归约-移进）<br>b:{a1,a2,…,an},FOLLOW(B1),FOLLOW(B2)两两互不相交，（交集=空集）时是SLR(1)项目。<br>【也就是说，同时满足两个条件才是SLR（1）文法】</p>
<p>若不是再向下判断。</p>
<p>3.判断LR(1)文法：<br>构造带向前搜索符的DFA，无归约-归约冲突则是LR(1)文法。</p>
<p>【此处意思是如果有向前搜索符还有冲突的话就不是LR（1）文法，就要再向下判断】</p>
<p>4.判断LALR(1)文法：<br>合并同心集后无（归约-归约）冲突（在之前的基础上）<br>（核相同，向前搜索符不同）</p>
<p>（B-&gt;a,a<br>B-&gt;a,a|b<br>同心集）</p>
<p><strong>LR即指LR(1)</strong></p>
<h4 id="四元式知识点"><a href="#四元式知识点" class="headerlink" title="四元式知识点"></a>四元式知识点</h4><p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220518170348404.png" alt="image-20220518170348404" style="zoom:50%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220518170539086.png" alt="image-20220518170539086" style="zoom:50%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220518170614471.png" alt="image-20220518170614471" style="zoom:50%;"></p>
<h4 id="一些函数"><a href="#一些函数" class="headerlink" title="一些函数"></a>一些函数</h4><p>赋值语句的翻译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newtemp( )：生成一个新的临时变量t，返回t的地址</span><br><span class="line">gen(code)：生成三地址指令code</span><br><span class="line">lookup(name)：查询符号表返回name 对应的记录</span><br></pre></td></tr></table></figure>
<p>数组引用的翻译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L的综合属性</span><br><span class="line">L.type：L生成的数组元素的类型</span><br><span class="line">L.offset：指示一个临时变量，该临时变量用于累加公式中的ij × wj项，从而计算数组元素的偏移量</span><br><span class="line">L.array：数组名在符号表的入口地址</span><br></pre></td></tr></table></figure>
<p>控制语句的翻译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">继承属性</span><br><span class="line">B.true：是一个地址，该地址用来存放当B为真时控制流转向的指令的标号</span><br><span class="line">B.false：是一个地址，该地址用来存放当B为假时控制流转向的指令的标号</span><br><span class="line">S.next：是一个地址，该地址用来存放紧跟在S代码之后执行的指令(S的后继指令)的标号</span><br></pre></td></tr></table></figure>
<p><strong>回填</strong></p>
<p>非终结符B的综合属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.truelist：指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是当B为真时控制流应该转向的指令的标号</span><br><span class="line">B.falselist：指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是当B为假时控制流应该转向的指令的标号</span><br></pre></td></tr></table></figure>
<p>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">makelist( i )</span><br><span class="line">创建一个只包含i的列表，i是跳转指令的标号，函数返回指向新创建的列表的指针</span><br><span class="line">merge( p1, p2 )</span><br><span class="line">将 p1 和 p2 指向的列表进行合并，返回指向合并后的列表的指针</span><br><span class="line">backpatch( p, i )</span><br><span class="line">将 i 作为目标标号插入到 p所指列表中的各指令中</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextquad：即将生成的下一条指令的标号</span><br></pre></td></tr></table></figure>
<h4 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h4><p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220517011523873.png" alt="image-20220517011523873" style="zoom: 25%;"></p>
<h4 id="NFA到DFA的转换"><a href="#NFA到DFA的转换" class="headerlink" title="NFA到DFA的转换"></a>NFA到DFA的转换</h4><p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220114100302890.png" alt="image-20220114100302890" style="zoom: 25%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220114100719876.png" alt="image-20220114100719876" style="zoom: 25%;"></p>
<h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>词法分析阶段可检测错误的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单词拼写错误</span><br><span class="line">非法字符</span><br></pre></td></tr></table></figure>
<h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>最左规约称为规范规约，而最右推导相应的称为规范推导。</p>
<p>LL错误恢复：恐慌模式</p>
<p>LR错误恢复：恐慌模式错误恢复；短语层次错误恢复</p>
<h4 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h4><p>这两种情况下，SDT可在语法分析过程中实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本文法可以使用LR分析技术，且SDD是S属性的</span><br><span class="line">基本文法可以使用LL分析技术，且SDD是L属性的</span><br></pre></td></tr></table></figure>
<p>给定一个以LL文法为基础的L-SDD，可以修改这个文法，并在LR语法分析过程中计算这个新文法之上的SDD</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个以LL文法为基础的L-属性定义，可以修改这个文法，并在LR语法分析过程中计算这个新文法之上的SDD</span><br><span class="line">首先构造SDT，在各个非终结符之前放置语义动作来计算它的继承属性， 并在产生式后端放置语义动作计算综合属性</span><br><span class="line">对每个内嵌的语义动作，向文法中引入一个标记非终结符来替换它。每个这样的位置都有一个不同的标记，并且对于任意一个标记M都有一个产生式M→ε</span><br><span class="line">如果标记非终结符M在某个产生式A→α&#123;a&#125;β中替换了语义动作a，对a进行修改得到a&#x27; ，并且将a&#x27;关联到M→ε 上。动作a&#x27;</span><br><span class="line">(a) 将动作a需要的A或α中符号的任何属性作为M的继承属性进行复制</span><br><span class="line">(b) 按照a中的方法计算各个属性，但是将计算得到的这些属性作为M的综合属性</span><br></pre></td></tr></table></figure>
<h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><h4 id="类型表达式"><a href="#类型表达式" class="headerlink" title="类型表达式"></a>类型表达式</h4><p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220514095400390.png" alt="image-20220514095400390" style="zoom: 25%;"></p>
<h4 id="控制流语句SDT编写要点"><a href="#控制流语句SDT编写要点" class="headerlink" title="控制流语句SDT编写要点"></a>控制流语句SDT编写要点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分析每一个非终结符之前</span><br><span class="line">先计算继承属性</span><br><span class="line">再观察代码结构图中该非终结符对应的方框顶部是否有导入箭头。如果有，调用label( )函数</span><br><span class="line">上一个代码框执行完不顺序执行下一个代码框时，生成一条显式跳转指令</span><br><span class="line">有自下而上的箭头时，设置begin属性。且定义后直接调用label( )函数绑定地址</span><br></pre></td></tr></table></figure>
<h3 id="运行存储分配"><a href="#运行存储分配" class="headerlink" title="运行存储分配"></a>运行存储分配</h3><h4 id="活动记录的一般形式"><a href="#活动记录的一般形式" class="headerlink" title="活动记录的一般形式"></a>活动记录的一般形式</h4><p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220514194518053.png" alt="image-20220514194518053" style="zoom:25%;"></p>
<h4 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h4><p>顺序分配法<img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220514195326335.png" alt="image-20220514195326335" style="zoom:25%;"></p>
<p>层次分配法<img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220514195613542.png" alt="image-20220514195613542" style="zoom:25%;"></p>
<h4 id="栈式存储分配"><a href="#栈式存储分配" class="headerlink" title="栈式存储分配"></a>栈式存储分配</h4><p>活动树</p>
<p>调用序列与返回序列</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220514203627726.png" alt="image-20220514203627726" style="zoom:25%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220514203641791.png" alt="image-20220514203641791" style="zoom:25%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220514203739336.png" alt="image-20220514203739336" style="zoom:25%;"></p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>如果表达式x op y先前已被计算过，并且从先前的计算到现在，x op y中变量的值没有改变，那么x op y的这次出现就称为<strong>公共子表达式</strong></p>
<p> <strong>复制传播</strong>：在复制语句x = y之后尽可能地用y代替x</p>
<p>对于一个变量x ，如果存在一个正的或负的常数c使得每次x被赋值时它的值总增加c ，那么x就称为<strong>归纳变量</strong></p>
<h4 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h4><p>数组元素赋值<img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220515144738742.png" alt="image-20220515144738742" style="zoom:25%;"></p>
<h4 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h4><p><strong>到达定值分析</strong></p>
<p>正常</p>
<p>作用：</p>
<p>循环不变计算的检测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果循环中含有赋值x=y+z ，而y和z所有可能的定值都在循环外面(包括y或z是常数的特殊情况) ，那么y+z就是循环不变计算</span><br></pre></td></tr></table></figure>
<p>常量合并</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果对变量x的某次使用只有一个定值可以到达，并且该定值把一个常量赋给x ，那么可以简单地把x替换为该常量</span><br></pre></td></tr></table></figure>
<p>ud链<img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220515160301603.png" alt="image-20220515160301603" style="zoom:25%;"></p>
<p><strong>活跃变量分析</strong></p>
<p><strong>活跃变量</strong>：对于变量x和程序点p，如果在流图中沿着从p开始的某条路径会引用变量x在p点的值，则称变量x在点p是活跃(live)的，否则称变量x在点p不活跃(dead)</p>
<p>逆向分析</p>
<p>用途：</p>
<p>删除无用赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无用赋值：如果x在点p的定值在基本块内所有后继点都不被引用，且x在基本块出口之后又是不活跃的，那么x在点p的定值就是无用的</span><br></pre></td></tr></table></figure>
<p>为基本块分配寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果所有寄存器都被占用，并且还需要申请一个寄存器，则应该考虑使用已经存放了死亡值的寄存器，因为这个值不需要保存到内存</span><br><span class="line"> 如果一个值在基本块结尾处是死的就不必在结尾处保存这个值</span><br></pre></td></tr></table></figure>
<p>du链<img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220515173505087.png" alt="image-20220515173505087" style="zoom:25%;"></p>
<p><strong>可用表达式分析</strong></p>
<p>概念：如果从流图的首节点到达程序点 p的每条路径都对表达式x op y进行计算，并且从最后一个这样的计算到点p之间没有再次对x或y定值，那么表达式x op y在点 p是可用的</p>
<p>初始化时出enter外每个out都是全集</p>
<p>用途：</p>
<p>消除全局公共子表达式</p>
<p>进行复制传播</p>
<h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>主要任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令选择</span><br><span class="line">寄存器分配（allocation）和指派（assignment）</span><br><span class="line">指令排序</span><br></pre></td></tr></table></figure>
<h2 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h2><p>词素分析</p>
<p>符号表</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519095250393.png" alt="image-20220519095250393" style="zoom:50%;"></p>
<p>递归的预测分析</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519090315865.png" alt="image-20220519090315865" style="zoom:50%;"></p>
<p>非递归的预测分析</p>
<p>设计SDD</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519090831495.png" alt="image-20220519090831495" style="zoom:50%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519090857805.png" alt="image-20220519090857805" style="zoom: 50%;"></p>
<p>改写SDT</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519091009554.png" alt="image-20220519091009554" style="zoom:50%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519091020128.png" alt="image-20220519091020128" style="zoom:50%;"></p>
<p>递归的翻译</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519091117371.png" alt="image-20220519091117371" style="zoom:50%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519091125843.png" alt="image-20220519091125843" style="zoom:50%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519091136618.png" alt="image-20220519091136618" style="zoom: 50%;"></p>
<p>非递归的翻译</p>
<p>活动记录</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519095215951.png" alt="image-20220519095215951" style="zoom:50%;"></p>
<p>嵌套深度</p>
<p>找自然循坏</p>
<p>全局优化</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519112045378.png" alt="image-20220519112045378" style="zoom:50%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519112057244.png" alt="image-20220519112057244" style="zoom:50%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519112108281.png" alt="image-20220519112108281" style="zoom:50%;"></p>
<p>句柄</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519090345663.png" alt="image-20220519090345663" style="zoom:50%;"></p>
<p>注释语法分析树</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519090524677.png" alt="image-20220519090524677" style="zoom:50%;"></p>
<p>翻译赋值语句</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519091438811.png" alt="image-20220519091438811" style="zoom:50%;"></p>
<p>控制流翻译</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519091926010.png" alt="image-20220519091926010" style="zoom:50%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519091945017.png" alt="image-20220519091945017" style="zoom:50%;"></p>
<p>四元式序列</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519091908986.png" alt="image-20220519091908986" style="zoom:50%;"></p>
<p>翻译方案</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519093013272.png" alt="image-20220519093013272" style="zoom:50%;"></p>
<p>13.5 难</p>
<p>13.6</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519093318108.png" alt="image-20220519093318108" style="zoom:50%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519093414326.png" alt="image-20220519093414326" style="zoom:50%;"></p>
<p>14.4</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519094046078.png" alt="image-20220519094046078" style="zoom:50%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519094815904.png" alt="image-20220519094815904" style="zoom:50%;"></p>
<p>求trulist</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519093827461.png" alt="image-20220519093827461" style="zoom:50%;"></p>
<p>活动树</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519095147977.png" alt="image-20220519095147977" style="zoom:50%;"></p>
<p>DAG</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519095524644.png" alt="image-20220519095524644" style="zoom:50%;"></p>
<p>数值分析</p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519095710086.png" alt="image-20220519095710086" style="zoom:50%;"></p>
<p><img src="/2022/05/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20220519095720862.png" alt="image-20220519095720862" style="zoom:50%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/12/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/12/test/" class="post-title-link" itemprop="url">test</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-12 19:59:27 / Modified: 20:33:35" itemprop="dateCreated datePublished" datetime="2022-05-12T19:59:27+08:00">2022-05-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p><img src="/2022/05/12/test/QQ图片20220512202816.png" alt="QQ图片20220512202816"></p>
<p>现象如图所示，会一直打印A。</p>
<p>在执行时，追踪IDT表，发现表中每一项第四位的值发生了变化。</p>
<p><img src="/2022/05/12/test/QQ图片20220512203227.png" alt="QQ图片20220512203227"></p>
<p>在IDT表初始化后，其所有描述表的第四位的值均为ignore_int首第四位值，即0x114。</p>
<p>在修改的程序后，每次eax都会多执行一条+2的指令。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-08 19:58:05" itemprop="dateCreated datePublished" datetime="2022-05-08T19:58:05+08:00">2022-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-09 01:48:08" itemprop="dateModified" datetime="2023-03-09T01:48:08+08:00">2023-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统的引导"><a href="#操作系统的引导" class="headerlink" title="操作系统的引导"></a>操作系统的引导</h1><h2 id="完成-bootsect-s-的屏幕输出功能"><a href="#完成-bootsect-s-的屏幕输出功能" class="headerlink" title="完成 bootsect.s 的屏幕输出功能"></a>完成 bootsect.s 的屏幕输出功能</h2><p>关键代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">! 文件：bootsect.s</span><br><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#25</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg1</span><br><span class="line">    mov ax,#0x07c0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">inf_loop:</span><br><span class="line">    jmp inf_loop</span><br><span class="line">msg1:</span><br><span class="line">    .byte   13,10</span><br><span class="line">    .ascii &quot;LKJos is running...&quot;</span><br><span class="line">    .byte   13,10,13,10</span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">    .word   0xAA55</span><br></pre></td></tr></table></figure>
<p>我们修改的字符为19个，再加上前后一共3个回车加换行，所以总共25个字符。</p>
<p>将 .org 508 修改为 .org 510，是因为这里不需要 root_dev: .word ROOT_DEV，为了保证 boot_flag 一定在最后两个字节，所以要修改 .org。</p>
<p>执行下面两个命令编译和链接 bootsect.s</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ as86 -0 -a -o bootsect.o bootsect.s</span><br><span class="line">$ ld86 -0 -s -o bootsect bootsect.o</span><br></pre></td></tr></table></figure>
<p>需要留意的文件是 <code>bootsect</code> 的文件大小是 <code>544</code> 字节，而引导程序必须要正好占用一个磁盘扇区，即 <code>512</code> 个字节。 造成多了 <code>32</code> 个字节的原因是 <code>ld86</code> 产生的是 <code>Minix</code> 可执行文件格式， 这样的可执行文件处理文本段、数据段等部分以外，还包括一个 <code>Minix</code> 可执行文件头部。</p>
<p>去掉32字节的头部文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd bs=1 if=bootsect of=Image skip=32</span><br></pre></td></tr></table></figure>
<p>接下来进行拷贝，并且run</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 当前的工作路径为 /common/linux-0.11/boot/</span><br><span class="line"># 将刚刚生成的 Image 复制到 linux-0.11 目录下</span><br><span class="line">$ cp ./Image ../Image</span><br><span class="line"># 执行run 脚本</span><br><span class="line">$ ../../run</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：由于我执行run的时候有些许问题，所以我对于目录结构进行了修改。</p>
<p>效果如下图</p>
<p><img src="/2022/05/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/image-20220508200758526.png" alt="image-20220508200758526"></p>
<h2 id="bootsect-s-读入-setup-s"><a href="#bootsect-s-读入-setup-s" class="headerlink" title="bootsect.s 读入 setup.s"></a>bootsect.s 读入 setup.s</h2><p>首先编写一个 setup.s，该 setup.s 可以就直接拷贝前面的 bootsect.s，然后将其中的显示的信息改为：“Now we are in SETUP”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">	mov ah,#0x03</span><br><span class="line">	xor bh,bh</span><br><span class="line">	int 0x10</span><br><span class="line">	mov cx,#25</span><br><span class="line">	mov bx,#0x0007</span><br><span class="line">	mov bp,#msg2</span><br><span class="line">	mov ax,cs				! 这里的cs其实就是这段代码的段地址</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov ax,#0x1301</span><br><span class="line">	int 0x10</span><br><span class="line">inf_loop:</span><br><span class="line">	jmp inf_loop</span><br><span class="line">msg2:</span><br><span class="line">	.byte	13,10</span><br><span class="line">	.ascii	&quot;Now we are in SETUP&quot;</span><br><span class="line">	.byte	13,10,13,10</span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">	.word	0xAA55</span><br></pre></td></tr></table></figure>
<p>接下来需要编写 <code>bootsect.s</code> 中载入 <code>setup.s</code> 的关键代码,注意去掉无限循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">SETUPLEN=2              ! 读入的扇区数</span><br><span class="line">SETUPSEG=0x07e0         ! setup代码的段地址</span><br><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">    mov ah,#0x03        ! 设置功能号</span><br><span class="line">    xor bh,bh           ! 将bh置0</span><br><span class="line">    int 0x10            ! 返回行号和列号，供显示串用</span><br><span class="line">    mov cx,#25          ！要显示的字符串长度</span><br><span class="line">    mov bx,#0x0007      ! bh=0,bl=07(正常的黑底白字)</span><br><span class="line">    mov bp,#msg1        ! es:bp 要显示的字符串物理地址</span><br><span class="line">    mov ax,#0x07c0      ! 将es段寄存器置为#0x07c0</span><br><span class="line">    mov es,ax           </span><br><span class="line">    mov ax,#0x1301      ! ah=13(设置功能号),al=01(目标字符串仅仅包含字符，属性在BL中包含，光标停在字符串结尾处)</span><br><span class="line">    int 0x10            ! 显示字符串</span><br><span class="line"></span><br><span class="line">! 将setup模块从磁盘的第二个扇区开始读到0x7e00</span><br><span class="line">load_setup:</span><br><span class="line">    mov dx,#0x0000                  ! 磁头=0；驱动器号=0</span><br><span class="line">    mov cx,#0x0002                  ! 磁道=0；扇区=2</span><br><span class="line">    mov bx,#0x0200                  ! 偏移地址</span><br><span class="line">    mov ax,#0x0200+SETUPLEN         ! 设置功能号；需要读出的扇区数量</span><br><span class="line">    int 0x13                        ! 读磁盘扇区到内存</span><br><span class="line">    jnc ok_load_setup               ! CF=0(读入成功)跳转到ok_load_setup  </span><br><span class="line">    mov dx,#0x0000                  ! 如果读入失败，使用功能号ah=0x00————磁盘系统复位</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    int 0x13</span><br><span class="line">    jmp load_setup                  ! 尝试重新读入</span><br><span class="line"></span><br><span class="line">ok_load_setup:</span><br><span class="line">    jmpi    0,SETUPSEG              ! 段间跳转指令，跳转到setup模块处(0x07e0:0000)</span><br><span class="line"></span><br><span class="line">! 字符串信息</span><br><span class="line">msg1:</span><br><span class="line">    .byte   13,10           ! 换行+回车</span><br><span class="line">    .ascii  &quot;LKJos is running...&quot;</span><br><span class="line">    .byte   13,10,13,10     ! 换行+回车</span><br><span class="line"></span><br><span class="line">! 将</span><br><span class="line">.org 510</span><br><span class="line"></span><br><span class="line">! 启动盘具有有效引导扇区的标志。仅供BIOS中的程序加载引导扇区时识别使用。它必须位于引导扇区的最后两个字节中</span><br><span class="line">boot_flag:</span><br><span class="line">    .word   0xAA55</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果如下图</p>
<p><img src="/2022/05/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/image-20220508210219587.png" alt="image-20220508210219587"></p>
<p>需要修改build.c，并且删除同目录下的 <code>hdc-0.11.img.lock</code> 即可。</p>
<h2 id="setup-s-获取基本硬件参数"><a href="#setup-s-获取基本硬件参数" class="headerlink" title="setup.s 获取基本硬件参数"></a>setup.s 获取基本硬件参数</h2><p><code>setup.s</code> 将获得硬件参数放在内存的 <code>0x90000</code> 处。原版 <code>setup.s</code> 中已经完成了光标位置、内存大小、显存大小、显卡参数、第一和第二硬盘参数的保存。</p>
<p>用 <code>ah=#0x03</code> 调用 <code>0x10</code> 中断可以读出光标的位置，用 <code>ah=#0x88</code> 调用 <code>0x15</code> 中断可以读出内存的大小。 有些硬件参数的获取要稍微复杂一些，如磁盘参数表。在 <code>PC</code> 机中 <code>BIOS</code> 设定的中断向量表中 <code>int 0x41</code> 的中断向量位置( <code>4*0x41 = 0x0000:0x0104</code> )存放的并不是中断程序的地址，而是第一个硬盘的基本参数表。 第二个硬盘的基本参数表入口地址存于 <code>int 0x46</code> 中断向量位置处。每个硬盘参数表有 <code>16</code> 个字节大小。</p>
<p>在PC机中BIOS设定的中断向量表中int 0x41的中断向量位置存放的并不是中断程序的地址,而是第一个硬盘的基本参数表。对于100%兼容的BIOS来说,这里存放着硬盘参数表阵列的首地址0xF000:0E401，第二个硬盘的基本参数表入口地址存于int 0x46中断向量位置处.每个硬盘参数表有16个字节大小.</p>
<p>这段话是重点，磁盘参数就存放在以0x0000:0x0104为首地址的单元中只存了4个字节，里面存放的是磁盘参数表的偏移地址和段地址，也就是上文所说这里存放着硬盘参数表阵列的首地址0xF000:0E401。</p>
<p>以十六进制方式显示比较简单。这是因为十六进制与二进制有很好的对应关系（每 4 位二进制数和 1 位十六进制数存在一一对应关系），显示时只需将原二进制数每 4 位划成一组，按组求对应的 ASCII 码送显示器即可。ASCII 码与十六进制数字的对应关系为：0x30 ～ 0x39 对应数字 0 ～ 9，0x41 ～ 0x46 对应数字 a ～ f。从数字 9 到 a，其 ASCII 码间隔了 7h，这一点在转换时要特别注意。为使一个十六进制数能按高位到低位依次显示，实际编程中，需对 bx 中的数每次循环左移一组（4 位二进制），然后屏蔽掉当前高 12 位，对当前余下的 4 位（即 1 位十六进制数）求其 ASCII 码，要判断它是 0 ～ 9 还是 a ～ f，是前者则加 0x30 得对应的 ASCII 码，后者则要加 0x37 才行，最后送显示器输出。以上步骤重复 4 次，就可以完成 bx 中数以 4 位十六进制的形式显示出来。</p>
<p>如下图：</p>
<p><img src="/2022/05/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/image-20220508215057266.png" alt="image-20220508215057266"></p>
<p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line">! 文件setup.s</span><br><span class="line">INITSEG = 0x9000</span><br><span class="line"></span><br><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">! 在显示字符串之前必须先获取当前光标的位置，这样就可以把字符串显示到当前光标处了</span><br><span class="line">    mov    ah,#0x03</span><br><span class="line">    xor    bh,bh</span><br><span class="line">    int    0x10</span><br><span class="line">    </span><br><span class="line">! 利用10号中断的13号功能打印字符串&quot;Now we are in SETUP.&quot;</span><br><span class="line">    mov    cx,#26</span><br><span class="line">    mov    bx,#0x0007</span><br><span class="line">    mov    bp,#msg1</span><br><span class="line">    mov     ax,cs</span><br><span class="line">    mov    es,ax</span><br><span class="line">    mov    ax,#0x1301</span><br><span class="line">    int    0x10</span><br><span class="line"></span><br><span class="line">! 下面开始读取一些硬件参数</span><br><span class="line"></span><br><span class="line">    ! 读入光标位置信息，保存到0x90000处</span><br><span class="line">    mov    ax,#INITSEG</span><br><span class="line">    mov    ds,ax</span><br><span class="line">    mov    ah,#0x03</span><br><span class="line">    xor    bh,bh</span><br><span class="line">    int    0x10</span><br><span class="line">    mov    [0],ds</span><br><span class="line"></span><br><span class="line">    ! 读入内存大小位置信息，保存到0x90002处</span><br><span class="line">    mov    ah,#0x88</span><br><span class="line">    int    0x15</span><br><span class="line">    mov    [2],ax</span><br><span class="line"></span><br><span class="line">    ! 从0x41处拷贝16个字节（磁盘参数表）到0x90004处</span><br><span class="line">    mov    ax,#0x0000</span><br><span class="line">    mov    ds,ax</span><br><span class="line">    lds    si,[4*0x41]</span><br><span class="line">    mov    ax,#INITSEG</span><br><span class="line">    mov    es,ax</span><br><span class="line">    mov    di,#0x0004</span><br><span class="line">    mov    cx,#0x10</span><br><span class="line">    rep       ! 重复16次</span><br><span class="line">    movsb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">! 先打印光标位置</span><br><span class="line">    ! 打印字符串之前要先读取光标位置，将字符串打印到当前光标处</span><br><span class="line">    mov    ah,#0x03</span><br><span class="line">    xor    bh,bh</span><br><span class="line">    int    0x10</span><br><span class="line"></span><br><span class="line">    ! 打印字符串 &quot;Cursor POS:&quot;</span><br><span class="line">    mov    cx,#11</span><br><span class="line">    mov    bx,#0x0007</span><br><span class="line">    mov    ax,cs</span><br><span class="line">    mov    es,ax</span><br><span class="line">    mov    bp,#msg2</span><br><span class="line">    mov    ax,#0x1301</span><br><span class="line">    int    0x10    </span><br><span class="line">    </span><br><span class="line">    ! 调用打印函数，打印光标位置</span><br><span class="line">    mov    ax,#0x9000</span><br><span class="line">    mov    ds,ax</span><br><span class="line">    mov    dx,0x0</span><br><span class="line">    call    print_hex</span><br><span class="line">    call    print_nl</span><br><span class="line"></span><br><span class="line">! 打印内存大小</span><br><span class="line">    ! 打印字符串&quot;Memory SIZE:&quot;</span><br><span class="line">    mov    ah,#0x03</span><br><span class="line">    xor    bh,bh</span><br><span class="line">    int    0x10    ! 读取光标位置</span><br><span class="line"></span><br><span class="line">    mov    cx,#12</span><br><span class="line">    mov    bx,#0x0007</span><br><span class="line">    mov    ax,cs</span><br><span class="line">    mov    es,ax</span><br><span class="line">    mov    bp,#msg3</span><br><span class="line">    mov    ax,#0x1301</span><br><span class="line">    int    0x10    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ! 调用打印函数，打印内存大小信息</span><br><span class="line">    mov    ax,#0x9000    </span><br><span class="line">    mov    ds,ax</span><br><span class="line">    mov    dx,0x2</span><br><span class="line">    call     print_hex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ! 打印字符串&quot;KB&quot;</span><br><span class="line">    mov    ah,#0x03</span><br><span class="line">    xor    bh,bh</span><br><span class="line">    int    0x10    ! 读取光标位置    </span><br><span class="line">    </span><br><span class="line">    mov    cx,#2</span><br><span class="line">    mov    bx,#0x0007</span><br><span class="line">    mov    ax,cs</span><br><span class="line">    mov    es,ax</span><br><span class="line">    mov    bp,#msg4</span><br><span class="line">    mov    ax,#0x1301</span><br><span class="line">    int    0x10    </span><br><span class="line">    call    print_nl    </span><br><span class="line"></span><br><span class="line">!打印柱面数</span><br><span class="line">    ! 打印字符串&quot;Cyls&quot;</span><br><span class="line">    mov    ah,#0x03</span><br><span class="line">    xor    bh,bh</span><br><span class="line">    int    0x10    ! 读取光标位置</span><br><span class="line"></span><br><span class="line">    mov    cx,#5</span><br><span class="line">    mov    bx,#0x0007</span><br><span class="line">    mov    ax,cs</span><br><span class="line">    mov    es,ax</span><br><span class="line">    mov    bp,#msg5</span><br><span class="line">    mov    ax,#0x1301</span><br><span class="line">    int    0x10    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    ! 调用打印函数打印磁盘柱面数</span><br><span class="line">    mov    ax,#0x9000    </span><br><span class="line">    mov    ds,ax</span><br><span class="line">    mov    dx,0x4</span><br><span class="line">    call    print_hex</span><br><span class="line">    call    print_nl</span><br><span class="line"></span><br><span class="line">! 打印磁头数</span><br><span class="line">    ! 打印字符串&quot;Heads:&quot;</span><br><span class="line">    mov    ah,#0x03</span><br><span class="line">    xor    bh,bh</span><br><span class="line">    int    0x10    ! 读取光标位置</span><br><span class="line"></span><br><span class="line">    mov    cx,#6</span><br><span class="line">    mov    bx,#0x0007</span><br><span class="line">    mov    ax,cs</span><br><span class="line">    mov    es,ax</span><br><span class="line">    mov    bp,#msg6</span><br><span class="line">    mov    ax,#0x1301</span><br><span class="line">    int    0x10    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ! 调用打印函数打印磁盘磁头数</span><br><span class="line">    mov    ax,#0x9000    </span><br><span class="line">    mov    ds,ax</span><br><span class="line">    mov    dx,0x6</span><br><span class="line">    call    print_hex</span><br><span class="line">    call    print_nl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">! 打印每磁道扇区数</span><br><span class="line">    ! 打印字符串&quot;sectors&quot;</span><br><span class="line">    mov    ah,#0x03</span><br><span class="line">    xor    bh,bh</span><br><span class="line">    int    0x10    ! 读取光标位置</span><br><span class="line"></span><br><span class="line">    mov    cx,#8</span><br><span class="line">    mov    bx,#0x0007</span><br><span class="line">    mov    ax,cs</span><br><span class="line">    mov    es,ax</span><br><span class="line">    mov    bp,#msg7</span><br><span class="line">    mov    ax,#0x1301</span><br><span class="line">    int    0x10    </span><br><span class="line"></span><br><span class="line">    ! 调用打印函数打印扇区数</span><br><span class="line">    mov    ax,#0x9000    </span><br><span class="line">    mov    ds,ax</span><br><span class="line">    mov    dx,0x12</span><br><span class="line">    call    print_hex</span><br><span class="line">    call    print_nl</span><br><span class="line"></span><br><span class="line">Inf_loop:</span><br><span class="line">    jmp Inf_loop    ! 无限循环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">! print_hex函数：将一个数字转换为ascii码字符，并打印到屏幕上</span><br><span class="line">! 参数值：dx</span><br><span class="line">! 返回值：无</span><br><span class="line">print_hex:</span><br><span class="line">    mov    cx,#4            ! 要打印4个十六进制数字,故循环4次</span><br><span class="line">print_digit:</span><br><span class="line">    rol    dx,#4            ! 循环以使低4比特用上 !! 取dx的高4比特移到低4比特处</span><br><span class="line">    mov    ax,#0xe0f        ! ah = 请求的功能值，al = 半字节(4个比特)掩码</span><br><span class="line">    and    al,dl            ! 取dl的低4比特值</span><br><span class="line">    add    al,#0x30        ! 给al数字加上十六进制0x30</span><br><span class="line">    cmp    al,#0x3a    </span><br><span class="line">    jl    outp            ! 如果是一个不大于十的数字</span><br><span class="line">    add    al,#0x07    ! 如果是a～f，要多加7</span><br><span class="line">outp:</span><br><span class="line">    int    0x10</span><br><span class="line">    loop    print_digit    ! 用loop重复4次</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">! 打印回车换行</span><br><span class="line">print_nl:</span><br><span class="line">    mov    ax,#0xe0d</span><br><span class="line">    int    0x10</span><br><span class="line">    mov    al,#0xa</span><br><span class="line">    int    0x10</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">msg1:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Now we are in SETUP.&quot;</span><br><span class="line">    .byte 13,10,13,10</span><br><span class="line"></span><br><span class="line">msg2:</span><br><span class="line">    .ascii &quot;Cursor POS:&quot;</span><br><span class="line"></span><br><span class="line">msg3:    </span><br><span class="line">    .ascii &quot;Memory SIZE:&quot;</span><br><span class="line"></span><br><span class="line">msg4:</span><br><span class="line">    .ascii &quot;KB&quot;</span><br><span class="line"></span><br><span class="line">msg5:    </span><br><span class="line">    .ascii &quot;Cyls:&quot;</span><br><span class="line"></span><br><span class="line">msg6:</span><br><span class="line">    .ascii &quot;Heads:&quot;</span><br><span class="line"></span><br><span class="line">msg7:</span><br><span class="line">    .ascii &quot;Sectors:&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">    .word 0xAA55</span><br></pre></td></tr></table></figure>
<h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当PC的电源打开后，80x86结构的CPU将自动进入实模式，并从地址0xFFFF0开始自动执行程序代码，这个地址通常是ROM—BIOS中的地址。PC机的BIOS将执行某些系统的检测，并在物理地址0处开始初始化中断向量。此后将启动设备的第一个扇区512字节读入内存绝对地址0x7C00处。因为当时system模块的长度不会超过0x80000字节大小512KB，所以bootsect程序把system模块读入物理地址0x10000开始位置处时并不会覆盖在0x90000处开始的bootsect和setup模块，多此一举的是system模块移到内存中相对靠后的位置，以便加载系统主模块。解决方案是在保证操作系统启动引导成功的前提下尽量扩大ROM—BIOS的内存寻址范围。</span><br></pre></td></tr></table></figure>
<h2 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h2><h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p><strong>AH&amp;AL=AX(accumulator)：</strong>累加寄存器，常用于运算;在乘除等指令中指定用来存放操作数，另外,所有的I/O指令都使用这一寄存器与外界设备传送数据。</p>
<p><strong>BH&amp;BL=BX(base)：</strong>基址寄存器，常用于地址索引</p>
<p><strong>CH&amp;CL=CX(count)：</strong>计数寄存器，常用于计数；常用于保存计算值，如在移位指令,循环(loop)和串处理指令中用作隐含的计数器.</p>
<p><strong>DH&amp;DL=DX(data)：</strong>数据寄存器，常用于数据传递。</p>
<p>他们的特点是，这4个16位的寄存器可以分为高8位: AH, BH, CH, DH.以及低八位：AL,BL,CL,DL。这2组8位寄存器可以分别寻址，并单独使用。</p>
<h3 id="中断知识"><a href="#中断知识" class="headerlink" title="中断知识"></a>中断知识</h3><h4 id="int-0x10"><a href="#int-0x10" class="headerlink" title="int 0x10"></a>int 0x10</h4><p><img src="/2022/05/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/image-20220509162715086.png" alt="image-20220509162715086"></p>
<p>注意，这里ah要先有值，代表内部子程序的编号</p>
<p>功能号ah=0x03，作用是读取光标的位置</p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bh = 页号</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = 扫描开始线；cl = 扫描结束线；dh = 行号；dl = 列号</span><br></pre></td></tr></table></figure>
<p>功能号ah=0x13，作用是显示字符串</p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">al = 放置光标的方式及规定属性，下文 al＝1，表示目标字符串仅仅包含字符，属性在BL中包含，光标停在字符串结尾处；es:bp = 字符串起始位置；cx = 显示的字符串字符数；bh = 页号；bl = 字符属性，下文 bl = 07H，表示正常的黑底白字；dh = 行号；dl = 列号</span><br></pre></td></tr></table></figure>
<p>功能号ah=0x0e，作用是显示字符</p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">al = 字符</span><br></pre></td></tr></table></figure>
<h4 id="int-0x13"><a href="#int-0x13" class="headerlink" title="int 0x13"></a>int 0x13</h4><p>在DOS等实模式操作系统下，调用INT 13h会跳转到计算机的ROM-BIOS代码中进行低级磁盘服务，对程序进行基于物理扇区的磁盘读写操作。</p>
<p>功能号ah=0x02，作用是读磁盘扇区到内存<br>输入：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>寄存器</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ah</td>
<td>读磁盘扇区到内存</td>
</tr>
<tr>
<td>al</td>
<td>需要读出的扇区数量</td>
</tr>
<tr>
<td>ch</td>
<td>磁道</td>
</tr>
<tr>
<td>cl</td>
<td>扇区</td>
</tr>
<tr>
<td>dh</td>
<td>磁头</td>
</tr>
<tr>
<td>dl</td>
<td>驱动器</td>
</tr>
<tr>
<td>es:bx</td>
<td>数据缓冲区的地址</td>
</tr>
</tbody>
</table>
</div>
<p>返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ah = 出错码（00H表示无错，01H表示非法命令，02H表示地址目标未发现…）；CF为进位标志位，如果没有出错CF=0</span><br></pre></td></tr></table></figure>
<p>功能号ah=0x00，作用是磁盘系统复位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：dl = 驱动器</span><br><span class="line">返回：如果操作成功———— C F = 0 CF=0CF=0，a h = 00 H ah=00Hah=00H</span><br></pre></td></tr></table></figure>
<h4 id="int-0x15"><a href="#int-0x15" class="headerlink" title="int 0x15"></a>int 0x15</h4><p>功能号ah=0x88，作用是获取系统所含扩展内存大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ah = 0x88</span><br><span class="line">返回：ax = 从0x100000(1M)处开始的拓展内存大小(KB)。若出错则CF置位，ax = 出错码。</span><br></pre></td></tr></table></figure>
<h4 id="int-0x41"><a href="#int-0x41" class="headerlink" title="int 0x41"></a>int 0x41</h4><p>在PC机中BIOS设定的中断向量表中int 0x41的中断向量位置 (4 ∗ 0 x 41 = 0 x 0000 : 0 x 0104 4*0x41 = 0x0000:0x01044∗0x41=0x0000:0x0104)存放的并不是中断程序的地址,而是第一个硬盘的基本参数表。对于100%兼容的BIOS来说,这里存放着硬盘参数表阵列的首地址0xF000:0E401，第二个硬盘的基本参数表入口地址存于int 0x46中断向量位置处.每个硬盘参数表有16个字节大小.</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="lds"><a href="#lds" class="headerlink" title="lds"></a>lds</h4><p>格式： LDS reg16，mem32</p>
<p>其意义是同时给一个段寄存器和一个16位通用寄存器同时赋值</p>
<p>举例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>地址</th>
<th>100H</th>
<th>101H</th>
<th>102H</th>
<th>103H</th>
</tr>
</thead>
<tbody>
<tr>
<td>内容</td>
<td>00H</td>
<td>41H</td>
<td>02H</td>
<td>03H</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LDS AX,[100H]</span><br><span class="line">! 结果：AX=4100H  DS=0302H</span><br><span class="line">可以理解为</span><br><span class="line">mov AX,[100H]</span><br><span class="line">mov DS,[100H+2]</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/04/%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-Linux-0-00-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/04/%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-Linux-0-00-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/" class="post-title-link" itemprop="url">调试分析 Linux 0.00 多任务切换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-04 15:17:11 / Modified: 21:51:59" itemprop="dateCreated datePublished" datetime="2022-05-04T15:17:11+08:00">2022-05-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="调试分析-Linux-0-00-多任务切换"><a href="#调试分析-Linux-0-00-多任务切换" class="headerlink" title="调试分析 Linux 0.00 多任务切换"></a>调试分析 Linux 0.00 多任务切换</h1><h2 id="执行-153-行-iret-时栈的变化"><a href="#执行-153-行-iret-时栈的变化" class="headerlink" title="执行 153 行 iret 时栈的变化"></a>执行 153 行 iret 时栈的变化</h2><p>执行前栈的内容</p>
<p><img src="/2022/05/04/%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-Linux-0-00-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/image-20220504154137710.png" alt="image-20220504154137710" style="zoom:50%;"></p>
<p>执行后栈的内容</p>
<p><img src="/2022/05/04/%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-Linux-0-00-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/image-20220504154156025.png" alt="image-20220504154156025" style="zoom:50%;"></p>
<p>在执行前后进行了栈的切换，从任务0的内核栈切换到了任务的用户栈。</p>
<h2 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h2><p>当进入和退出 <code>system_interrupt</code> 时，都发生了模式切换，请总结模式切换时，特权级是如何改变的？栈切换吗？如何进行切换的？</p>
<p>在进入中断时，通过查询IDT表，获得索引，之后进行特权级检查，要求CPL&lt;=调用门DPL；RPL&lt;=调用门DPL。DPL&lt;=CPL。特权级检查通过，则特权级改变。栈也进行切换。处理器从当前任务的TSS段获得该中断使用的堆栈的段选择符与栈指针，然后把被中断的栈选择符与栈指针压入新栈。EFLAGES、CS、EIP的值也被压栈。</p>
<p>当退出时，使用iret指令。把保存的寄存器内容恢复到EFLAGES中，完成特权级复原，即切换为3。同时栈也切换回原来的栈。</p>
<h2 id="任务切换过程"><a href="#任务切换过程" class="headerlink" title="任务切换过程"></a>任务切换过程</h2><p>当时钟中断发生，进入到 <code>timer_interrupt</code> 程序，请详细记录从任务 <code>0</code> 切换到任务 <code>1</code> 的过程。</p>
<p><img src="/2022/05/04/%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-Linux-0-00-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/image-20220504170543986.png" alt="image-20220504170543986" style="zoom: 33%;"></p>
<p>以本图为例分析。说明第一次切换时的状况，第一次切换，即时钟中断发生时，大概率会在227行，此时任务号为0，当跳入时钟中断后，从125行开始进行转换，首先将1写入寄存器eax，然后判断，因为此时任务号为0，所以不执行127行，执行128行，则将任务号改为1，然后在129行跳转到任务1的代码段。</p>
<p>任务0时的寄存器如下：</p>
<p><img src="/2022/05/04/%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-Linux-0-00-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/W30F_428FK4HUQ8]K0{NQS.jpg" alt="img" style="zoom:50%;"></p>
<p>任务1时的寄存器如下：</p>
<p><img src="/2022/05/04/%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-Linux-0-00-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/image-20220504205616009.png" alt="image-20220504205616009" style="zoom:50%;"></p>
<h2 id="任务切回过程"><a href="#任务切回过程" class="headerlink" title="任务切回过程"></a>任务切回过程</h2><p>又过了 <code>10ms</code> ，从任务1切换回到任务 <code>0</code> ，整个流程是怎样的？ <code>TSS</code> 是如何变化的？各个寄存器的值是如何变化的？</p>
<p><img src="/2022/05/04/%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-Linux-0-00-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/image-20220504170543986.png" alt="image-20220504170543986" style="zoom:33%;"></p>
<p>如图，承接上题叙述，从代码段228执行，在232循环，大概率在循环时进行时间中断发生，在126行比较时，由于此时任务号为1，所以跳转到131行，将任务号设为0，在132行处，跳转到任务0，由于任务0执行到129行，所以从130执行，再跳转到133行，弹栈后通过iret返回，由于上次为在226行触发中断，所以回到226行。</p>
<p>寄存器变化如下：</p>
<p><img src="/2022/05/04/%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-Linux-0-00-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/QQ图片20220504212642.png" alt="QQ图片20220504212642" style="zoom: 33%;"></p>
<p>变至</p>
<p><img src="/2022/05/04/%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-Linux-0-00-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/(PWOBGOQ)2`%MSLMDHDOG4X.png" alt="img" style="zoom:33%;"></p>
<p>下图为任务0的TSS</p>
<p><img src="/2022/05/04/%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-Linux-0-00-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/image-20220504214234727.png" alt="image-20220504214234727" style="zoom:33%;"></p>
<p>下图为任务1的TSS</p>
<p><img src="/2022/05/04/%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-Linux-0-00-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/image-20220504214319515.png" alt="image-20220504214319515" style="zoom: 33%;"></p>
<h2 id="详细总结任务切换的过程"><a href="#详细总结任务切换的过程" class="headerlink" title="详细总结任务切换的过程"></a>详细总结任务切换的过程</h2><p><img src="/2022/05/04/%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-Linux-0-00-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/image-20220504170543986.png" alt="image-20220504170543986" style="zoom:33%;"></p>
<p>还是对照这张图片，从头来讲。</p>
<p>第一次切换，即时钟中断发生时，大概率会在227行，此时任务号为0，当跳入时钟中断后，从125行开始进行转换，首先将1写入寄存器eax，然后判断，因为此时任务号为0，所以不执行127行，执行128行，则将任务号改为1，然后在129行跳转到任务1的代码段。</p>
<p>从代码段228执行，在232循环，大概率在循环时进行时间中断发生，在126行比较时，由于此时任务号为1，所以跳转到131行，将任务号设为0，在132行处，跳转到任务0，由于任务0执行到129行，所以从130执行，再跳转到133行，弹栈后通过iret返回，由于上次为在226行触发中断，所以回到226行。</p>
<p>然后大概率在此行，再次遇到时间中断，从125行开始进行转换，首先将1写入寄存器eax，然后判断，因为此时任务号为0，所以不执行127行，执行128行，则将任务号改为1，然后在129行跳转到任务1。由于任务1上次执行至</p>
<p>132行，所以从133行开始，到iret返回至232行。</p>
<p>又大概率在232行遇到时钟中断，执行到126行比较后跳转到131行，将任务号变为0，回到任务0的代码段。</p>
<p>至此为一个流程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
